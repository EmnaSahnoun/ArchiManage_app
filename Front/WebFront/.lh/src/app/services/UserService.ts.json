{
    "sourceFile": "src/app/services/UserService.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 34,
            "patches": [
                {
                    "date": 1744990690983,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1744990698333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,10 @@\n \r\n @Injectable({\r\n   providedIn: 'root'\r\n })\r\n-export class U {\r\n+export class UserService\r\n+ {\r\n   private keycloakUrl = 'https://esmm.systeo.tn';\r\n   private realm = 'systeodigital';\r\n   private accessToken: string | null = null;\r\n \r\n"
                },
                {
                    "date": 1744990980834,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,161 +8,5 @@\n export class UserService\r\n  {\r\n   private keycloakUrl = 'https://esmm.systeo.tn';\r\n   private realm = 'systeodigital';\r\n-  private accessToken: string | null = null;\r\n-\r\n-  constructor(private http: HttpClient) { }\r\n-\r\n-  // Authentification pour obtenir le token\r\n-  login(clientId: string, username: string, password: string): Observable<any> {\r\n-    const body = new URLSearchParams();\r\n-    body.set('client_id', clientId);\r\n-    body.set('username', username);\r\n-    body.set('password', password);\r\n-    body.set('grant_type', 'password');\r\n-\r\n-    const headers = new HttpHeaders({\r\n-      'Content-Type': 'application/x-www-form-urlencoded'\r\n-    });\r\n-\r\n-    return this.http.post(\r\n-      `${this.keycloakUrl}/realms/${this.realm}/protocol/openid-connect/token`,\r\n-      body.toString(),\r\n-      { headers }\r\n-    ).pipe(\r\n-      map((response: any) => {\r\n-        this.accessToken = response.access_token;\r\n-        return response;\r\n-      }),\r\n-      catchError(error => {\r\n-        console.error('Login error:', error);\r\n-        return throwError(() => error);\r\n-      })\r\n-    );\r\n-  }\r\n-\r\n-  // Créer un nouvel utilisateur\r\n-  createUser(userData: any): Observable<any> {\r\n-    if (!this.accessToken) {\r\n-      return throwError(() => new Error('Token non disponible. Veuillez vous authentifier d\\'abord.'));\r\n-    }\r\n-\r\n-    const headers = new HttpHeaders({\r\n-      'Content-Type': 'application/json',\r\n-      'Authorization': `Bearer ${this.accessToken}`\r\n-    });\r\n-\r\n-    const userPayload = {\r\n-      username: userData.email, // ou userData.name selon votre besoin\r\n-      email: userData.email,\r\n-      enabled: true,\r\n-      credentials: [{\r\n-        type: 'password',\r\n-        value: userData.password,\r\n-        temporary: false\r\n-      }]\r\n-    };\r\n-\r\n-    return this.http.post(\r\n-      `${this.keycloakUrl}/admin/realms/${this.realm}/users`,\r\n-      userPayload,\r\n-      { headers }\r\n-    ).pipe(\r\n-      catchError(error => {\r\n-        console.error('Erreur création utilisateur:', error);\r\n-        return throwError(() => error);\r\n-      })\r\n-    );\r\n-  }\r\n-\r\n-  // Récupérer tous les rôles disponibles\r\n-  getRoles(): Observable<any[]> {\r\n-    if (!this.accessToken) {\r\n-      return throwError(() => new Error('Token non disponible. Veuillez vous authentifier d\\'abord.'));\r\n-    }\r\n-\r\n-    const headers = new HttpHeaders({\r\n-      'Authorization': `Bearer ${this.accessToken}`\r\n-    });\r\n-\r\n-    return this.http.get<any[]>(\r\n-      `${this.keycloakUrl}/admin/realms/${this.realm}/roles`,\r\n-      { headers }\r\n-    ).pipe(\r\n-      catchError(error => {\r\n-        console.error('Erreur récupération rôles:', error);\r\n-        return throwError(() => error);\r\n-      })\r\n-    );\r\n-  }\r\n-\r\n-  // Assigner un rôle à un utilisateur\r\n-  assignRoleToUser(userId: string, roleName: string): Observable<any> {\r\n-    if (!this.accessToken) {\r\n-      return throwError(() => new Error('Token non disponible. Veuillez vous authentifier d\\'abord.'));\r\n-    }\r\n-\r\n-    return this.getRoles().pipe(\r\n-      mergeMap(roles => {\r\n-        const role = roles.find(r => r.name === roleName);\r\n-        if (!role) {\r\n-          return throwError(() => new Error(`Rôle ${roleName} non trouvé`));\r\n-        }\r\n-\r\n-        const headers = new HttpHeaders({\r\n-          'Content-Type': 'application/json',\r\n-          'Authorization': `Bearer ${this.accessToken}`\r\n-        });\r\n-\r\n-        return this.http.post(\r\n-          `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`,\r\n-          [role],\r\n-          { headers }\r\n-        );\r\n-      }),\r\n-      catchError(error => {\r\n-        console.error('Erreur assignation rôle:', error);\r\n-        return throwError(() => error);\r\n-      })\r\n-    );\r\n-  }\r\n-\r\n-  // Trouver un utilisateur par email\r\n-  findUserByEmail(email: string): Observable<any> {\r\n-    if (!this.accessToken) {\r\n-      return throwError(() => new Error('Token non disponible. Veuillez vous authentifier d\\'abord.'));\r\n-    }\r\n-\r\n-    const headers = new HttpHeaders({\r\n-      'Authorization': `Bearer ${this.accessToken}`\r\n-    });\r\n-\r\n-    return this.http.get<any[]>(\r\n-      `${this.keycloakUrl}/admin/realms/${this.realm}/users?email=${encodeURIComponent(email)}`,\r\n-      { headers }\r\n-    ).pipe(\r\n-      map(users => users.length > 0 ? users[0] : null),\r\n-      catchError(error => {\r\n-        console.error('Erreur recherche utilisateur:', error);\r\n-        return throwError(() => error);\r\n-      })\r\n-    );\r\n-  }\r\n-\r\n-  // Méthode complète pour créer un utilisateur et lui assigner un rôle\r\n-  createUserWithRole(userData: any): Observable<any> {\r\n-    return this.createUser(userData).pipe(\r\n-      mergeMap(() => this.findUserByEmail(userData.email)),\r\n-      mergeMap(user => {\r\n-        if (!user || !user.id) {\r\n-          return throwError(() => new Error('Utilisateur créé mais non trouvé pour assignation de rôle'));\r\n-        }\r\n-        return this.assignRoleToUser(user.id, userData.role);\r\n-      }),\r\n-      catchError(error => {\r\n-        console.error('Erreur dans createUserWithRole:', error);\r\n-        return throwError(() => error);\r\n-      })\r\n-    );\r\n-  }\r\n-}\n\\ No newline at end of file\n+  \n\\ No newline at end of file\n"
                },
                {
                    "date": 1744990999816,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,5 +8,80 @@\n export class UserService\r\n  {\r\n   private keycloakUrl = 'https://esmm.systeo.tn';\r\n   private realm = 'systeodigital';\r\n-  \n\\ No newline at end of file\n+  \r\n+  constructor(private http: HttpClient) {}\r\n+\r\n+  // Méthode pour obtenir le token d'accès (si nécessaire)\r\n+  getAccessToken(username: string, password: string): Observable<any> {\r\n+    const url = `${this.keycloakUrl}/realms/${this.realm}/protocol/openid-connect/token`;\r\n+    const body = new URLSearchParams();\r\n+    body.set('grant_type', 'password');\r\n+    body.set('client_id', 'app-pfeFront');\r\n+    body.set('username', username);\r\n+    body.set('password', password);\r\n+\r\n+    const headers = new HttpHeaders({\r\n+      'Content-Type': 'application/x-www-form-urlencoded'\r\n+    });\r\n+\r\n+    return this.http.post(url, body.toString(), { headers }).pipe(\r\n+      catchError(this.handleError)\r\n+    );\r\n+  }\r\n+\r\n+  // Créer un nouvel utilisateur\r\n+  createUser(userData: any): Observable<any> {\r\n+    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users`;\r\n+    const headers = this.getAdminHeaders();\r\n+\r\n+    return this.http.post(url, userData, { headers }).pipe(\r\n+      catchError(this.handleError)\r\n+    );\r\n+  }\r\n+\r\n+  // Obtenir la liste des utilisateurs\r\n+  getUsers(): Observable<any[]> {\r\n+    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users`;\r\n+    const headers = this.getAdminHeaders();\r\n+\r\n+    return this.http.get<any[]>(url, { headers }).pipe(\r\n+      catchError(this.handleError)\r\n+    );\r\n+  }\r\n+\r\n+  // Obtenir la liste des rôles\r\n+  getRoles(): Observable<any[]> {\r\n+    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n+    const headers = this.getAdminHeaders();\r\n+\r\n+    return this.http.get<any[]>(url, { headers }).pipe(\r\n+      catchError(this.handleError)\r\n+    );\r\n+  }\r\n+\r\n+  // Assigner un rôle à un utilisateur\r\n+  assignRoleToUser(userId: string, role: any): Observable<any> {\r\n+    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n+    const headers = this.getAdminHeaders();\r\n+\r\n+    return this.http.post(url, [role], { headers }).pipe(\r\n+      catchError(this.handleError)\r\n+    );\r\n+  }\r\n+\r\n+  // Méthode privée pour obtenir les headers avec le token d'admin\r\n+  private getAdminHeaders(): HttpHeaders {\r\n+    const token = localStorage.getItem('access_token'); // Supposons que le token est stocké ici\r\n+    return new HttpHeaders({\r\n+      'Content-Type': 'application/json',\r\n+      'Authorization': `Bearer ${token}`\r\n+    });\r\n+  }\r\n+\r\n+  // Gestion des erreurs\r\n+  private handleError(error: any): Observable<never> {\r\n+    console.error('An error occurred:', error);\r\n+    return throwError(() => new Error('Something went wrong; please try again later.'));\r\n+  }\r\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744991238012,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,9 +71,9 @@\n   }\r\n \r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n   private getAdminHeaders(): HttpHeaders {\r\n-    const token = localStorage.getItem('access_token'); // Supposons que le token est stocké ici\r\n+    const token = localStorage.getItem('token'); // Supposons que le token est stocké ici\r\n     return new HttpHeaders({\r\n       'Content-Type': 'application/json',\r\n       'Authorization': `Bearer ${token}`\r\n     });\r\n"
                },
                {
                    "date": 1744992549507,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,20 +1,21 @@\n import { Injectable } from '@angular/core';\r\n import { HttpClient, HttpHeaders } from '@angular/common/http';\r\n-import { Observable, catchError, forkJoin, map, mergeMap, of, throwError } from 'rxjs';\r\n+import { Observable, catchError, forkJoin, from, map, mergeMap, of, throwError } from 'rxjs';\r\n \r\n @Injectable({\r\n   providedIn: 'root'\r\n })\r\n-export class UserService\r\n- {\r\n+export class UserService {\r\n   private keycloakUrl = 'https://esmm.systeo.tn';\r\n   private realm = 'systeodigital';\r\n+  private tokenStorageKey = 'keycloak_token';\r\n+  private tokenRefreshTime = 300000; // 5 minutes en millisecondes\r\n   \r\n   constructor(private http: HttpClient) {}\r\n \r\n-  // Méthode pour obtenir le token d'accès (si nécessaire)\r\n-  getAccessToken(username: string, password: string): Observable<any> {\r\n+  // Méthode pour obtenir le token d'accès et le stocker\r\n+  login(username: string, password: string): Observable<any> {\r\n     const url = `${this.keycloakUrl}/realms/${this.realm}/protocol/openid-connect/token`;\r\n     const body = new URLSearchParams();\r\n     body.set('grant_type', 'password');\r\n     body.set('client_id', 'app-pfeFront');\r\n@@ -25,63 +26,152 @@\n       'Content-Type': 'application/x-www-form-urlencoded'\r\n     });\r\n \r\n     return this.http.post(url, body.toString(), { headers }).pipe(\r\n+      map((response: any) => {\r\n+        this.storeToken(response);\r\n+        return response;\r\n+      }),\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n-  // Créer un nouvel utilisateur\r\n+  // Stocker le token dans le localStorage\r\n+  private storeToken(tokenResponse: any): void {\r\n+    const tokenData = {\r\n+      token: tokenResponse.access_token,\r\n+      refreshToken: tokenResponse.refresh_token,\r\n+      expiresAt: Date.now() + (tokenResponse.expires_in * 1000)\r\n+    };\r\n+    localStorage.setItem(this.tokenStorageKey, JSON.stringify(tokenData));\r\n+  }\r\n+\r\n+  // Vérifier si le token est valide\r\n+  private isTokenValid(): boolean {\r\n+    const tokenData = this.getStoredToken();\r\n+    if (!tokenData) return false;\r\n+    return Date.now() < tokenData.expiresAt;\r\n+  }\r\n+\r\n+  // Obtenir le token stocké\r\n+  private getStoredToken(): any {\r\n+    const tokenString = localStorage.getItem(this.tokenStorageKey);\r\n+    return tokenString ? JSON.parse(tokenString) : null;\r\n+  }\r\n+\r\n+  // Rafraîchir le token si nécessaire\r\n+  private refreshTokenIfNeeded(): Observable<void> {\r\n+    const tokenData = this.getStoredToken();\r\n+    \r\n+    if (!tokenData) {\r\n+      return throwError(() => new Error('No token available'));\r\n+    }\r\n+\r\n+    // Si le token est encore valide, ne rien faire\r\n+    if (this.isTokenValid()) {\r\n+      return of(undefined);\r\n+    }\r\n+\r\n+    // Sinon, rafraîchir le token\r\n+    const url = `${this.keycloakUrl}/realms/${this.realm}/protocol/openid-connect/token`;\r\n+    const body = new URLSearchParams();\r\n+    body.set('grant_type', 'refresh_token');\r\n+    body.set('client_id', 'app-pfeFront');\r\n+    body.set('refresh_token', tokenData.refreshToken);\r\n+\r\n+    const headers = new HttpHeaders({\r\n+      'Content-Type': 'application/x-www-form-urlencoded'\r\n+    });\r\n+\r\n+    return this.http.post(url, body.toString(), { headers }).pipe(\r\n+      map((response: any) => {\r\n+        this.storeToken(response);\r\n+        return undefined;\r\n+      }),\r\n+      catchError(error => {\r\n+        this.clearToken();\r\n+        return throwError(() => new Error('Failed to refresh token'));\r\n+      })\r\n+    );\r\n+  }\r\n+\r\n+  // Effacer le token\r\n+  clearToken(): void {\r\n+    localStorage.removeItem(this.tokenStorageKey);\r\n+  }\r\n+\r\n+  // Méthode pour créer un utilisateur avec gestion du token\r\n   createUser(userData: any): Observable<any> {\r\n-    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users`;\r\n-    const headers = this.getAdminHeaders();\r\n-\r\n-    return this.http.post(url, userData, { headers }).pipe(\r\n+    return this.refreshTokenIfNeeded().pipe(\r\n+      mergeMap(() => {\r\n+        const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users`;\r\n+        return this.http.post(url, userData, { headers: this.getAdminHeaders() });\r\n+      }),\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n-  // Obtenir la liste des utilisateurs\r\n+  // Obtenir la liste des utilisateurs avec gestion du token\r\n   getUsers(): Observable<any[]> {\r\n-    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users`;\r\n-    const headers = this.getAdminHeaders();\r\n-\r\n-    return this.http.get<any[]>(url, { headers }).pipe(\r\n+    return this.refreshTokenIfNeeded().pipe(\r\n+      mergeMap(() => {\r\n+        const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users`;\r\n+        return this.http.get<any[]>(url, { headers: this.getAdminHeaders() });\r\n+      }),\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n-  // Obtenir la liste des rôles\r\n+  // Obtenir la liste des rôles avec gestion du token\r\n   getRoles(): Observable<any[]> {\r\n-    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n-    const headers = this.getAdminHeaders();\r\n-\r\n-    return this.http.get<any[]>(url, { headers }).pipe(\r\n+    return this.refreshTokenIfNeeded().pipe(\r\n+      mergeMap(() => {\r\n+        const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n+        return this.http.get<any[]>(url, { headers: this.getAdminHeaders() });\r\n+      }),\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n-  // Assigner un rôle à un utilisateur\r\n+  // Assigner un rôle à un utilisateur avec gestion du token\r\n   assignRoleToUser(userId: string, role: any): Observable<any> {\r\n-    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n-    const headers = this.getAdminHeaders();\r\n-\r\n-    return this.http.post(url, [role], { headers }).pipe(\r\n+    return this.refreshTokenIfNeeded().pipe(\r\n+      mergeMap(() => {\r\n+        const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n+        return this.http.post(url, [role], { headers: this.getAdminHeaders() });\r\n+      }),\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n   private getAdminHeaders(): HttpHeaders {\r\n-    const token = localStorage.getItem('token'); // Supposons que le token est stocké ici\r\n+    const tokenData = this.getStoredToken();\r\n+    if (!tokenData) {\r\n+      throw new Error('No authentication token available');\r\n+    }\r\n+    \r\n     return new HttpHeaders({\r\n       'Content-Type': 'application/json',\r\n-      'Authorization': `Bearer ${token}`\r\n+      'Authorization': `Bearer ${tokenData.token}`\r\n     });\r\n   }\r\n \r\n-  // Gestion des erreurs\r\n+  // Gestion des erreurs améliorée\r\n   private handleError(error: any): Observable<never> {\r\n     console.error('An error occurred:', error);\r\n-    return throwError(() => new Error('Something went wrong; please try again later.'));\r\n+    \r\n+    let errorMessage = 'Une erreur est survenue';\r\n+    if (error.status === 401) {\r\n+      errorMessage = 'Session expirée, veuillez vous reconnecter';\r\n+      this.clearToken();\r\n+    } else if (error.status === 403) {\r\n+      errorMessage = 'Permission refusée';\r\n+    } else if (error.status === 404) {\r\n+      errorMessage = 'Ressource non trouvée';\r\n+    } else if (error.status >= 500) {\r\n+      errorMessage = 'Erreur serveur';\r\n+    }\r\n+    \r\n+    return throwError(() => new Error(errorMessage));\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744992559317,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,21 +1,20 @@\n import { Injectable } from '@angular/core';\r\n import { HttpClient, HttpHeaders } from '@angular/common/http';\r\n-import { Observable, catchError, forkJoin, from, map, mergeMap, of, throwError } from 'rxjs';\r\n+import { Observable, catchError, forkJoin, map, mergeMap, of, throwError } from 'rxjs';\r\n \r\n @Injectable({\r\n   providedIn: 'root'\r\n })\r\n-export class UserService {\r\n+export class UserService\r\n+ {\r\n   private keycloakUrl = 'https://esmm.systeo.tn';\r\n   private realm = 'systeodigital';\r\n-  private tokenStorageKey = 'keycloak_token';\r\n-  private tokenRefreshTime = 300000; // 5 minutes en millisecondes\r\n   \r\n   constructor(private http: HttpClient) {}\r\n \r\n-  // Méthode pour obtenir le token d'accès et le stocker\r\n-  login(username: string, password: string): Observable<any> {\r\n+  // Méthode pour obtenir le token d'accès (si nécessaire)\r\n+  getAccessToken(username: string, password: string): Observable<any> {\r\n     const url = `${this.keycloakUrl}/realms/${this.realm}/protocol/openid-connect/token`;\r\n     const body = new URLSearchParams();\r\n     body.set('grant_type', 'password');\r\n     body.set('client_id', 'app-pfeFront');\r\n@@ -26,152 +25,63 @@\n       'Content-Type': 'application/x-www-form-urlencoded'\r\n     });\r\n \r\n     return this.http.post(url, body.toString(), { headers }).pipe(\r\n-      map((response: any) => {\r\n-        this.storeToken(response);\r\n-        return response;\r\n-      }),\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n-  // Stocker le token dans le localStorage\r\n-  private storeToken(tokenResponse: any): void {\r\n-    const tokenData = {\r\n-      token: tokenResponse.access_token,\r\n-      refreshToken: tokenResponse.refresh_token,\r\n-      expiresAt: Date.now() + (tokenResponse.expires_in * 1000)\r\n-    };\r\n-    localStorage.setItem(this.tokenStorageKey, JSON.stringify(tokenData));\r\n-  }\r\n+  // Créer un nouvel utilisateur\r\n+  createUser(userData: any): Observable<any> {\r\n+    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users`;\r\n+    const headers = this.getAdminHeaders();\r\n \r\n-  // Vérifier si le token est valide\r\n-  private isTokenValid(): boolean {\r\n-    const tokenData = this.getStoredToken();\r\n-    if (!tokenData) return false;\r\n-    return Date.now() < tokenData.expiresAt;\r\n-  }\r\n-\r\n-  // Obtenir le token stocké\r\n-  private getStoredToken(): any {\r\n-    const tokenString = localStorage.getItem(this.tokenStorageKey);\r\n-    return tokenString ? JSON.parse(tokenString) : null;\r\n-  }\r\n-\r\n-  // Rafraîchir le token si nécessaire\r\n-  private refreshTokenIfNeeded(): Observable<void> {\r\n-    const tokenData = this.getStoredToken();\r\n-    \r\n-    if (!tokenData) {\r\n-      return throwError(() => new Error('No token available'));\r\n-    }\r\n-\r\n-    // Si le token est encore valide, ne rien faire\r\n-    if (this.isTokenValid()) {\r\n-      return of(undefined);\r\n-    }\r\n-\r\n-    // Sinon, rafraîchir le token\r\n-    const url = `${this.keycloakUrl}/realms/${this.realm}/protocol/openid-connect/token`;\r\n-    const body = new URLSearchParams();\r\n-    body.set('grant_type', 'refresh_token');\r\n-    body.set('client_id', 'app-pfeFront');\r\n-    body.set('refresh_token', tokenData.refreshToken);\r\n-\r\n-    const headers = new HttpHeaders({\r\n-      'Content-Type': 'application/x-www-form-urlencoded'\r\n-    });\r\n-\r\n-    return this.http.post(url, body.toString(), { headers }).pipe(\r\n-      map((response: any) => {\r\n-        this.storeToken(response);\r\n-        return undefined;\r\n-      }),\r\n-      catchError(error => {\r\n-        this.clearToken();\r\n-        return throwError(() => new Error('Failed to refresh token'));\r\n-      })\r\n-    );\r\n-  }\r\n-\r\n-  // Effacer le token\r\n-  clearToken(): void {\r\n-    localStorage.removeItem(this.tokenStorageKey);\r\n-  }\r\n-\r\n-  // Méthode pour créer un utilisateur avec gestion du token\r\n-  createUser(userData: any): Observable<any> {\r\n-    return this.refreshTokenIfNeeded().pipe(\r\n-      mergeMap(() => {\r\n-        const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users`;\r\n-        return this.http.post(url, userData, { headers: this.getAdminHeaders() });\r\n-      }),\r\n+    return this.http.post(url, userData, { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n-  // Obtenir la liste des utilisateurs avec gestion du token\r\n+  // Obtenir la liste des utilisateurs\r\n   getUsers(): Observable<any[]> {\r\n-    return this.refreshTokenIfNeeded().pipe(\r\n-      mergeMap(() => {\r\n-        const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users`;\r\n-        return this.http.get<any[]>(url, { headers: this.getAdminHeaders() });\r\n-      }),\r\n+    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users`;\r\n+    const headers = this.getAdminHeaders();\r\n+\r\n+    return this.http.get<any[]>(url, { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n-  // Obtenir la liste des rôles avec gestion du token\r\n+  // Obtenir la liste des rôles\r\n   getRoles(): Observable<any[]> {\r\n-    return this.refreshTokenIfNeeded().pipe(\r\n-      mergeMap(() => {\r\n-        const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n-        return this.http.get<any[]>(url, { headers: this.getAdminHeaders() });\r\n-      }),\r\n+    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n+    const headers = this.getAdminHeaders();\r\n+\r\n+    return this.http.get<any[]>(url, { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n-  // Assigner un rôle à un utilisateur avec gestion du token\r\n+  // Assigner un rôle à un utilisateur\r\n   assignRoleToUser(userId: string, role: any): Observable<any> {\r\n-    return this.refreshTokenIfNeeded().pipe(\r\n-      mergeMap(() => {\r\n-        const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n-        return this.http.post(url, [role], { headers: this.getAdminHeaders() });\r\n-      }),\r\n+    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n+    const headers = this.getAdminHeaders();\r\n+\r\n+    return this.http.post(url, [role], { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n   private getAdminHeaders(): HttpHeaders {\r\n-    const tokenData = this.getStoredToken();\r\n-    if (!tokenData) {\r\n-      throw new Error('No authentication token available');\r\n-    }\r\n-    \r\n+    const token = localStorage.getItem('token'); // Supposons que le token est stocké ici\r\n     return new HttpHeaders({\r\n       'Content-Type': 'application/json',\r\n-      'Authorization': `Bearer ${tokenData.token}`\r\n+      'Authorization': `Bearer ${token}`\r\n     });\r\n   }\r\n \r\n-  // Gestion des erreurs améliorée\r\n+  // Gestion des erreurs\r\n   private handleError(error: any): Observable<never> {\r\n     console.error('An error occurred:', error);\r\n-    \r\n-    let errorMessage = 'Une erreur est survenue';\r\n-    if (error.status === 401) {\r\n-      errorMessage = 'Session expirée, veuillez vous reconnecter';\r\n-      this.clearToken();\r\n-    } else if (error.status === 403) {\r\n-      errorMessage = 'Permission refusée';\r\n-    } else if (error.status === 404) {\r\n-      errorMessage = 'Ressource non trouvée';\r\n-    } else if (error.status >= 500) {\r\n-      errorMessage = 'Erreur serveur';\r\n-    }\r\n-    \r\n-    return throwError(() => new Error(errorMessage));\r\n+    return throwError(() => new Error('Something went wrong; please try again later.'));\r\n   }\r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1744993245684,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,9 +71,9 @@\n   }\r\n \r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n   private getAdminHeaders(): HttpHeaders {\r\n-    const token = localStorage.getItem('token'); // Supposons que le token est stocké ici\r\n+   \r\n     return new HttpHeaders({\r\n       'Content-Type': 'application/json',\r\n       'Authorization': `Bearer ${token}`\r\n     });\r\n"
                },
                {
                    "date": 1744993276864,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n  {\r\n   private keycloakUrl = 'https://esmm.systeo.tn';\r\n   private realm = 'systeodigital';\r\n   \r\n-  constructor(private http: HttpClient) {}\r\n+  constructor(private http: HttpClient,private authService: AuthService) {}\r\n \r\n   // Méthode pour obtenir le token d'accès (si nécessaire)\r\n   getAccessToken(username: string, password: string): Observable<any> {\r\n     const url = `${this.keycloakUrl}/realms/${this.realm}/protocol/openid-connect/token`;\r\n@@ -71,9 +71,12 @@\n   }\r\n \r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n   private getAdminHeaders(): HttpHeaders {\r\n-   \r\n+    const token = this.authService.getAccessToken();\r\n+    if (!token) {\r\n+      throw new Error('No access token available');\r\n+    }\r\n     return new HttpHeaders({\r\n       'Content-Type': 'application/json',\r\n       'Authorization': `Bearer ${token}`\r\n     });\r\n"
                },
                {
                    "date": 1744994502529,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n import { Injectable } from '@angular/core';\r\n import { HttpClient, HttpHeaders } from '@angular/common/http';\r\n import { Observable, catchError, forkJoin, map, mergeMap, of, throwError } from 'rxjs';\r\n+import { AuthService } from './auth.service';\r\n \r\n @Injectable({\r\n   providedIn: 'root'\r\n })\r\n@@ -71,9 +72,9 @@\n   }\r\n \r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n   private getAdminHeaders(): HttpHeaders {\r\n-    const token = this.authService.getAccessToken();\r\n+    const token = localStorage;\r\n     if (!token) {\r\n       throw new Error('No access token available');\r\n     }\r\n     return new HttpHeaders({\r\n"
                },
                {
                    "date": 1744994508905,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,9 +72,9 @@\n   }\r\n \r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n   private getAdminHeaders(): HttpHeaders {\r\n-    const token = localStorage;\r\n+    const token = localStorage.getItem(\"token\");\r\n     if (!token) {\r\n       throw new Error('No access token available');\r\n     }\r\n     return new HttpHeaders({\r\n"
                },
                {
                    "date": 1745013324282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -87,5 +87,7 @@\n   private handleError(error: any): Observable<never> {\r\n     console.error('An error occurred:', error);\r\n     return throwError(() => new Error('Something went wrong; please try again later.'));\r\n   }\r\n+\r\n+  \r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745065388870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n   // Obtenir la liste des rôles\r\n   getRoles(): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n     const headers = this.getAdminHeaders();\r\n-\r\n+    console\r\n     return this.http.get<any[]>(url, { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n"
                },
                {
                    "date": 1745065395435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n   // Obtenir la liste des rôles\r\n   getRoles(): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n     const headers = this.getAdminHeaders();\r\n-    console\r\n+    console.log()\r\n     return this.http.get<any[]>(url, { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n"
                },
                {
                    "date": 1745065404484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n   // Obtenir la liste des rôles\r\n   getRoles(): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n     const headers = this.getAdminHeaders();\r\n-    console.log()\r\n+    console.log(\"headers dasn roles\")\r\n     return this.http.get<any[]>(url, { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n"
                },
                {
                    "date": 1745069259986,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,11 +54,14 @@\n   // Obtenir la liste des rôles\r\n   getRoles(): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n     const headers = this.getAdminHeaders();\r\n-    console.log(\"headers dasn roles\")\r\n+\r\n     return this.http.get<any[]>(url, { headers }).pipe(\r\n-      catchError(this.handleError)\r\n+      catchError((error) => {\r\n+        console.error('Error fetching roles:', error);\r\n+        return throwError(() => new Error('Failed to load roles. Please check your permissions.'));\r\n+      })\r\n     );\r\n   }\r\n \r\n   // Assigner un rôle à un utilisateur\r\n"
                },
                {
                    "date": 1745069287151,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -75,15 +75,17 @@\n   }\r\n \r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n   private getAdminHeaders(): HttpHeaders {\r\n-    const token = localStorage.getItem(\"token\");\r\n+    const token = this.authService.getAccessToken();\r\n     if (!token) {\r\n       throw new Error('No access token available');\r\n     }\r\n+\r\n     return new HttpHeaders({\r\n-      'Content-Type': 'application/json',\r\n+      'Accept': 'application/json',\r\n       'Authorization': `Bearer ${token}`\r\n+      // Ne pas inclure 'Content-Type' pour les requêtes GET\r\n     });\r\n   }\r\n \r\n   // Gestion des erreurs\r\n"
                },
                {
                    "date": 1745069413188,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n   providedIn: 'root'\r\n })\r\n export class UserService\r\n  {\r\n-  private keycloakUrl = 'https://esmm.systeo.tn';\r\n+  private keycloakUrl = '\"proxyConfig\": \"proxy.conf.json\"';\r\n   private realm = 'systeodigital';\r\n   \r\n   constructor(private http: HttpClient,private authService: AuthService) {}\r\n \r\n"
                },
                {
                    "date": 1745074501939,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n   providedIn: 'root'\r\n })\r\n export class UserService\r\n  {\r\n-  private keycloakUrl = '\"proxyConfig\": \"proxy.conf.json\"';\r\n+  private keycloakUrl = '/api';\r\n   private realm = 'systeodigital';\r\n   \r\n   constructor(private http: HttpClient,private authService: AuthService) {}\r\n \r\n@@ -49,9 +49,16 @@\n     return this.http.get<any[]>(url, { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n-\r\n+  getUserRoles(userId: string): Observable<any[]> {\r\n+    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n+    const headers = this.getAdminHeaders();\r\n+  \r\n+    return this.http.get<any[]>(url, { headers }).pipe(\r\n+      catchError(this.handleError)\r\n+    );\r\n+  }\r\n   // Obtenir la liste des rôles\r\n   getRoles(): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n     const headers = this.getAdminHeaders();\r\n"
                },
                {
                    "date": 1745074533286,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,8 +48,9 @@\n \r\n     return this.http.get<any[]>(url, { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n+    \r\n   }\r\n   getUserRoles(userId: string): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n     const headers = this.getAdminHeaders();\r\n"
                },
                {
                    "date": 1745074541473,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,10 +48,11 @@\n \r\n     return this.http.get<any[]>(url, { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n-    \r\n   }\r\n+\r\n+  //get \r\n   getUserRoles(userId: string): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n     const headers = this.getAdminHeaders();\r\n   \r\n"
                },
                {
                    "date": 1745074552000,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n-  //get \r\n+  //obteni roles user \r\n   getUserRoles(userId: string): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n     const headers = this.getAdminHeaders();\r\n   \r\n"
                },
                {
                    "date": 1745074558131,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n-  //obteni roles user \r\n+  //obtenir les roles d'un  roles user \r\n   getUserRoles(userId: string): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n     const headers = this.getAdminHeaders();\r\n   \r\n"
                },
                {
                    "date": 1745074566863,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,13 +50,12 @@\n       catchError(this.handleError)\r\n     );\r\n   }\r\n \r\n-  //obtenir les roles d'un  roles user \r\n+  //obtenir les roles d'un user \r\n   getUserRoles(userId: string): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n     const headers = this.getAdminHeaders();\r\n-  \r\n     return this.http.get<any[]>(url, { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n"
                },
                {
                    "date": 1745084108487,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -100,7 +100,7 @@\n   private handleError(error: any): Observable<never> {\r\n     console.error('An error occurred:', error);\r\n     return throwError(() => new Error('Something went wrong; please try again later.'));\r\n   }\r\n-\r\n   \r\n+  \r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745084121053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -100,7 +100,16 @@\n   private handleError(error: any): Observable<never> {\r\n     console.error('An error occurred:', error);\r\n     return throwError(() => new Error('Something went wrong; please try again later.'));\r\n   }\r\n+\r\n+  //supprimer user\r\n+  deleteUser(userId: string): Observable<any> {\r\n+    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}`;\r\n+    const headers = this.getAdminHeaders();\r\n   \r\n+    return this.http.delete(url, { headers }).pipe(\r\n+      catchError(this.handleError)\r\n+    );\r\n+  }\r\n   \r\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745084138870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,9 +105,8 @@\n   //supprimer user\r\n   deleteUser(userId: string): Observable<any> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}`;\r\n     const headers = this.getAdminHeaders();\r\n-  \r\n     return this.http.delete(url, { headers }).pipe(\r\n       catchError(this.handleError)\r\n     );\r\n   }\r\n"
                },
                {
                    "date": 1745148284435,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,9 +82,9 @@\n     );\r\n   }\r\n \r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n-  private getAdminHeaders(): HttpHeaders {\r\n+   getAdminHeaders(): HttpHeaders {\r\n     const token = this.authService.getAccessToken();\r\n     if (!token) {\r\n       throw new Error('No access token available');\r\n     }\r\n"
                },
                {
                    "date": 1745148891171,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,9 +82,9 @@\n     );\r\n   }\r\n \r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n-   getAdminHeaders(): HttpHeaders {\r\n+  private getAdminHeaders(): HttpHeaders {\r\n     const token = this.authService.getAccessToken();\r\n     if (!token) {\r\n       throw new Error('No access token available');\r\n     }\r\n"
                },
                {
                    "date": 1745312756354,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,18 +71,10 @@\n       })\r\n     );\r\n   }\r\n \r\n-  // Assigner un rôle à un utilisateur\r\n-  assignRoleToUser(userId: string, role: any): Observable<any> {\r\n-    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n-    const headers = this.getAdminHeaders();\r\n+  \r\n \r\n-    return this.http.post(url, [role], { headers }).pipe(\r\n-      catchError(this.handleError)\r\n-    );\r\n-  }\r\n-\r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n   private getAdminHeaders(): HttpHeaders {\r\n     const token = this.authService.getAccessToken();\r\n     if (!token) {\r\n"
                },
                {
                    "date": 1745317850439,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -71,10 +71,18 @@\n       })\r\n     );\r\n   }\r\n \r\n-  \r\n+  // Assigner un rôle à un utilisateur\r\n+  assignRoleToUser(userId: string, role: any): Observable<any> {\r\n+    const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n+    const headers = this.getAdminHeaders();\r\n \r\n+    return this.http.post(url, [role], { headers }).pipe(\r\n+      catchError(this.handleError)\r\n+    );\r\n+  }\r\n+\r\n   // Méthode privée pour obtenir les headers avec le token d'admin\r\n   private getAdminHeaders(): HttpHeaders {\r\n     const token = this.authService.getAccessToken();\r\n     if (!token) {\r\n"
                },
                {
                    "date": 1745318525448,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n       catchError(this.handleError)\r\n     );\r\n   }\r\n   // Obtenir la liste des rôles\r\n-  getRoles(): Observable<any[]> {\r\n+  /* getRoles(): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n     const headers = this.getAdminHeaders();\r\n \r\n     return this.http.get<any[]>(url, { headers }).pipe(\r\n@@ -69,9 +69,9 @@\n         console.error('Error fetching roles:', error);\r\n         return throwError(() => new Error('Failed to load roles. Please check your permissions.'));\r\n       })\r\n     );\r\n-  }\r\n+  } */\r\n \r\n   // Assigner un rôle à un utilisateur\r\n   assignRoleToUser(userId: string, role: any): Observable<any> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n"
                },
                {
                    "date": 1745318599853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n       catchError(this.handleError)\r\n     );\r\n   }\r\n   // Obtenir la liste des rôles\r\n-  /* getRoles(): Observable<any[]> {\r\n+  getRoles(): Observable<any[]> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/roles`;\r\n     const headers = this.getAdminHeaders();\r\n \r\n     return this.http.get<any[]>(url, { headers }).pipe(\r\n@@ -69,9 +69,9 @@\n         console.error('Error fetching roles:', error);\r\n         return throwError(() => new Error('Failed to load roles. Please check your permissions.'));\r\n       })\r\n     );\r\n-  } */\r\n+  }\r\n \r\n   // Assigner un rôle à un utilisateur\r\n   assignRoleToUser(userId: string, role: any): Observable<any> {\r\n     const url = `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`;\r\n"
                },
                {
                    "date": 1746121637454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n   providedIn: 'root'\r\n })\r\n export class UserService\r\n  {\r\n-  private keycloakUrl = '/api';\r\n+  private keycloakUrl = '/keycloak';\r\n   private realm = 'systeodigital';\r\n   \r\n   constructor(private http: HttpClient,private authService: AuthService) {}\r\n \r\n"
                },
                {
                    "date": 1746122364726,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n   providedIn: 'root'\r\n })\r\n export class UserService\r\n  {\r\n-  private keycloakUrl = '/keycloak';\r\n+  private keycloakUrl = '/api';\r\n   private realm = 'systeodigital';\r\n   \r\n   constructor(private http: HttpClient,private authService: AuthService) {}\r\n \r\n"
                }
            ],
            "date": 1744990690983,
            "name": "Commit-0",
            "content": "import { Injectable } from '@angular/core';\r\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\r\nimport { Observable, catchError, forkJoin, map, mergeMap, of, throwError } from 'rxjs';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class U {\r\n  private keycloakUrl = 'https://esmm.systeo.tn';\r\n  private realm = 'systeodigital';\r\n  private accessToken: string | null = null;\r\n\r\n  constructor(private http: HttpClient) { }\r\n\r\n  // Authentification pour obtenir le token\r\n  login(clientId: string, username: string, password: string): Observable<any> {\r\n    const body = new URLSearchParams();\r\n    body.set('client_id', clientId);\r\n    body.set('username', username);\r\n    body.set('password', password);\r\n    body.set('grant_type', 'password');\r\n\r\n    const headers = new HttpHeaders({\r\n      'Content-Type': 'application/x-www-form-urlencoded'\r\n    });\r\n\r\n    return this.http.post(\r\n      `${this.keycloakUrl}/realms/${this.realm}/protocol/openid-connect/token`,\r\n      body.toString(),\r\n      { headers }\r\n    ).pipe(\r\n      map((response: any) => {\r\n        this.accessToken = response.access_token;\r\n        return response;\r\n      }),\r\n      catchError(error => {\r\n        console.error('Login error:', error);\r\n        return throwError(() => error);\r\n      })\r\n    );\r\n  }\r\n\r\n  // Créer un nouvel utilisateur\r\n  createUser(userData: any): Observable<any> {\r\n    if (!this.accessToken) {\r\n      return throwError(() => new Error('Token non disponible. Veuillez vous authentifier d\\'abord.'));\r\n    }\r\n\r\n    const headers = new HttpHeaders({\r\n      'Content-Type': 'application/json',\r\n      'Authorization': `Bearer ${this.accessToken}`\r\n    });\r\n\r\n    const userPayload = {\r\n      username: userData.email, // ou userData.name selon votre besoin\r\n      email: userData.email,\r\n      enabled: true,\r\n      credentials: [{\r\n        type: 'password',\r\n        value: userData.password,\r\n        temporary: false\r\n      }]\r\n    };\r\n\r\n    return this.http.post(\r\n      `${this.keycloakUrl}/admin/realms/${this.realm}/users`,\r\n      userPayload,\r\n      { headers }\r\n    ).pipe(\r\n      catchError(error => {\r\n        console.error('Erreur création utilisateur:', error);\r\n        return throwError(() => error);\r\n      })\r\n    );\r\n  }\r\n\r\n  // Récupérer tous les rôles disponibles\r\n  getRoles(): Observable<any[]> {\r\n    if (!this.accessToken) {\r\n      return throwError(() => new Error('Token non disponible. Veuillez vous authentifier d\\'abord.'));\r\n    }\r\n\r\n    const headers = new HttpHeaders({\r\n      'Authorization': `Bearer ${this.accessToken}`\r\n    });\r\n\r\n    return this.http.get<any[]>(\r\n      `${this.keycloakUrl}/admin/realms/${this.realm}/roles`,\r\n      { headers }\r\n    ).pipe(\r\n      catchError(error => {\r\n        console.error('Erreur récupération rôles:', error);\r\n        return throwError(() => error);\r\n      })\r\n    );\r\n  }\r\n\r\n  // Assigner un rôle à un utilisateur\r\n  assignRoleToUser(userId: string, roleName: string): Observable<any> {\r\n    if (!this.accessToken) {\r\n      return throwError(() => new Error('Token non disponible. Veuillez vous authentifier d\\'abord.'));\r\n    }\r\n\r\n    return this.getRoles().pipe(\r\n      mergeMap(roles => {\r\n        const role = roles.find(r => r.name === roleName);\r\n        if (!role) {\r\n          return throwError(() => new Error(`Rôle ${roleName} non trouvé`));\r\n        }\r\n\r\n        const headers = new HttpHeaders({\r\n          'Content-Type': 'application/json',\r\n          'Authorization': `Bearer ${this.accessToken}`\r\n        });\r\n\r\n        return this.http.post(\r\n          `${this.keycloakUrl}/admin/realms/${this.realm}/users/${userId}/role-mappings/realm`,\r\n          [role],\r\n          { headers }\r\n        );\r\n      }),\r\n      catchError(error => {\r\n        console.error('Erreur assignation rôle:', error);\r\n        return throwError(() => error);\r\n      })\r\n    );\r\n  }\r\n\r\n  // Trouver un utilisateur par email\r\n  findUserByEmail(email: string): Observable<any> {\r\n    if (!this.accessToken) {\r\n      return throwError(() => new Error('Token non disponible. Veuillez vous authentifier d\\'abord.'));\r\n    }\r\n\r\n    const headers = new HttpHeaders({\r\n      'Authorization': `Bearer ${this.accessToken}`\r\n    });\r\n\r\n    return this.http.get<any[]>(\r\n      `${this.keycloakUrl}/admin/realms/${this.realm}/users?email=${encodeURIComponent(email)}`,\r\n      { headers }\r\n    ).pipe(\r\n      map(users => users.length > 0 ? users[0] : null),\r\n      catchError(error => {\r\n        console.error('Erreur recherche utilisateur:', error);\r\n        return throwError(() => error);\r\n      })\r\n    );\r\n  }\r\n\r\n  // Méthode complète pour créer un utilisateur et lui assigner un rôle\r\n  createUserWithRole(userData: any): Observable<any> {\r\n    return this.createUser(userData).pipe(\r\n      mergeMap(() => this.findUserByEmail(userData.email)),\r\n      mergeMap(user => {\r\n        if (!user || !user.id) {\r\n          return throwError(() => new Error('Utilisateur créé mais non trouvé pour assignation de rôle'));\r\n        }\r\n        return this.assignRoleToUser(user.id, userData.role);\r\n      }),\r\n      catchError(error => {\r\n        console.error('Erreur dans createUserWithRole:', error);\r\n        return throwError(() => error);\r\n      })\r\n    );\r\n  }\r\n}"
        }
    ]
}
{
    "sourceFile": "server.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 89,
            "patches": [
                {
                    "date": 1748453070534,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748453536091,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,5 +19,7 @@\n \r\n const PORT = process.env.PORT || 3000;\r\n app.listen(PORT, () => {\r\n   console.log(`Server running on port ${PORT}`);\r\n-});\n\\ No newline at end of file\n+});\r\n+\r\n+\r\n"
                },
                {
                    "date": 1748453554817,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n const express = require('express');\r\n const cors = require('cors');\r\n const authRoutes = require('./routes/auth');\r\n const emailRoutes = require('./routes/email');\r\n-\r\n+const { google } = require('googleapis');\r\n const app = express();\r\n \r\n // Middleware\r\n app.use(cors({\r\n"
                },
                {
                    "date": 1748453562635,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,25 +1,21 @@\n require('dotenv').config();\r\n const express = require('express');\r\n+const { google } = require('googleapis');\r\n const cors = require('cors');\r\n-const authRoutes = require('./routes/auth');\r\n-const emailRoutes = require('./routes/email');\r\n-const { google } = require('googleapis');\r\n+\r\n const app = express();\r\n-\r\n-// Middleware\r\n-app.use(cors({\r\n-  origin: process.env.FRONTEND_URL,\r\n-  credentials: true\r\n-}));\r\n+app.use(cors());\r\n app.use(express.json());\r\n \r\n-// Routes\r\n-app.use('/auth', authRoutes);\r\n-app.use('/email', emailRoutes);\r\n+const PORT = process.env.PORT || 3000;\r\n+const oAuth2Client = new google.auth.OAuth2(\r\n+  process.env.CLIENT_ID,\r\n+  process.env.CLIENT_SECRET,\r\n+  process.env.REDIRECT_URI\r\n+);\r\n \r\n-const PORT = process.env.PORT || 3000;\r\n+// Routes seront ajoutées ici\r\n+\r\n app.listen(PORT, () => {\r\n   console.log(`Server running on port ${PORT}`);\r\n-});\r\n-\r\n-\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748453585946,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,10 +12,38 @@\n   process.env.CLIENT_ID,\r\n   process.env.CLIENT_SECRET,\r\n   process.env.REDIRECT_URI\r\n );\r\n+// Générer l'URL d'authentification\r\n+app.get('/auth/google', (req, res) => {\r\n+  const url = oAuth2Client.generateAuthUrl({\r\n+    access_type: 'offline',\r\n+    scope: [\r\n+      'https://www.googleapis.com/auth/gmail.readonly',\r\n+      'https://www.googleapis.com/auth/gmail.send',\r\n+      'https://www.googleapis.com/auth/gmail.modify',\r\n+      'https://mail.google.com/'\r\n+    ],\r\n+    prompt: 'consent'\r\n+  });\r\n+  res.redirect(url);\r\n+});\r\n \r\n-// Routes seront ajoutées ici\r\n+// Callback pour récupérer le token\r\n+app.get('/auth/google/callback', async (req, res) => {\r\n+  const { code } = req.query;\r\n+  \r\n+  try {\r\n+    const { tokens } = await oAuth2Client.getToken(code);\r\n+    oAuth2Client.setCredentials(tokens);\r\n+    \r\n+    // Rediriger vers le frontend avec les tokens\r\n+    res.redirect(`${process.env.FRONTEND_REDIRECT_URI}?access_token=${tokens.access_token}&refresh_token=${tokens.refresh_token}`);\r\n+  } catch (error) {\r\n+    console.error('Error retrieving access token', error);\r\n+    res.status(500).send('Authentication failed');\r\n+  }\r\n+});\r\n \r\n app.listen(PORT, () => {\r\n   console.log(`Server running on port ${PORT}`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748453599384,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,49 +1,25 @@\n require('dotenv').config();\r\n const express = require('express');\r\n+const cors = require('cors');\r\n+const authRoutes = require('./routes/auth');\r\n+const emailRoutes = require('./routes/email');\r\n const { google } = require('googleapis');\r\n-const cors = require('cors');\r\n+const app = express();\r\n \r\n-const app = express();\r\n-app.use(cors());\r\n+// Middleware\r\n+app.use(cors({\r\n+  origin: process.env.FRONTEND_URL,\r\n+  credentials: true\r\n+}));\r\n app.use(express.json());\r\n \r\n+// Routes\r\n+app.use('/auth', authRoutes);\r\n+app.use('/email', emailRoutes);\r\n+\r\n const PORT = process.env.PORT || 3000;\r\n-const oAuth2Client = new google.auth.OAuth2(\r\n-  process.env.CLIENT_ID,\r\n-  process.env.CLIENT_SECRET,\r\n-  process.env.REDIRECT_URI\r\n-);\r\n-// Générer l'URL d'authentification\r\n-app.get('/auth/google', (req, res) => {\r\n-  const url = oAuth2Client.generateAuthUrl({\r\n-    access_type: 'offline',\r\n-    scope: [\r\n-      'https://www.googleapis.com/auth/gmail.readonly',\r\n-      'https://www.googleapis.com/auth/gmail.send',\r\n-      'https://www.googleapis.com/auth/gmail.modify',\r\n-      'https://mail.google.com/'\r\n-    ],\r\n-    prompt: 'consent'\r\n-  });\r\n-  res.redirect(url);\r\n+app.listen(PORT, () => {\r\n+  console.log(`Server running on port ${PORT}`);\r\n });\r\n \r\n-// Callback pour récupérer le token\r\n-app.get('/auth/google/callback', async (req, res) => {\r\n-  const { code } = req.query;\r\n-  \r\n\\ No newline at end of file\n-  try {\r\n-    const { tokens } = await oAuth2Client.getToken(code);\r\n-    oAuth2Client.setCredentials(tokens);\r\n-    \r\n-    // Rediriger vers le frontend avec les tokens\r\n-    res.redirect(`${process.env.FRONTEND_REDIRECT_URI}?access_token=${tokens.access_token}&refresh_token=${tokens.refresh_token}`);\r\n-  } catch (error) {\r\n-    console.error('Error retrieving access token', error);\r\n-    res.status(500).send('Authentication failed');\r\n-  }\r\n-});\r\n \r\n-app.listen(PORT, () => {\r\n-  console.log(`Server running on port ${PORT}`);\r\n-});\n"
                },
                {
                    "date": 1748453638127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,25 +1,49 @@\n require('dotenv').config();\r\n const express = require('express');\r\n+const { google } = require('googleapis');\r\n const cors = require('cors');\r\n-const authRoutes = require('./routes/auth');\r\n-const emailRoutes = require('./routes/email');\r\n-const { google } = require('googleapis');\r\n+\r\n const app = express();\r\n-\r\n-// Middleware\r\n-app.use(cors({\r\n-  origin: process.env.FRONTEND_URL,\r\n-  credentials: true\r\n-}));\r\n+app.use(cors());\r\n app.use(express.json());\r\n \r\n-// Routes\r\n-app.use('/auth', authRoutes);\r\n-app.use('/email', emailRoutes);\r\n-\r\n const PORT = process.env.PORT || 3000;\r\n-app.listen(PORT, () => {\r\n-  console.log(`Server running on port ${PORT}`);\r\n+const oAuth2Client = new google.auth.OAuth2(\r\n+  process.env.CLIENT_ID,\r\n+  process.env.CLIENT_SECRET,\r\n+  process.env.REDIRECT_URI\r\n+);\r\n+// Générer l'URL d'authentification\r\n+app.get('/auth/google', (req, res) => {\r\n+  const url = oAuth2Client.generateAuthUrl({\r\n+    access_type: 'offline',\r\n+    scope: [\r\n+      'https://www.googleapis.com/auth/gmail.readonly',\r\n+      'https://www.googleapis.com/auth/gmail.send',\r\n+      'https://www.googleapis.com/auth/gmail.modify',\r\n+      'https://mail.google.com/'\r\n+    ],\r\n+    prompt: 'consent'\r\n+  });\r\n+  res.redirect(url);\r\n });\r\n \r\n+// Callback pour récupérer le token\r\n+app.get('/auth/google/callback', async (req, res) => {\r\n+  const { code } = req.query;\r\n+  \r\n+  try {\r\n+    const { tokens } = await oAuth2Client.getToken(code);\r\n+    oAuth2Client.setCredentials(tokens);\r\n+    \r\n+    // Rediriger vers le frontend avec les tokens\r\n+    res.redirect(`${process.env.FRONTEND_REDIRECT_URI}?access_token=${tokens.access_token}&refresh_token=${tokens.refresh_token}`);\r\n+  } catch (error) {\r\n+    console.error('Error retrieving access token', error);\r\n+    res.status(500).send('Authentication failed');\r\n+  }\r\n+});\r\n \r\n+app.listen(PORT, () => {\r\n+  console.log(`Server running on port ${PORT}`);\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748453662312,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,8 +42,47 @@\n     console.error('Error retrieving access token', error);\r\n     res.status(500).send('Authentication failed');\r\n   }\r\n });\r\n+app.post('/send-email', async (req, res) => {\r\n+  const { accessToken, emailData } = req.body;\r\n+  \r\n+  if (!accessToken || !emailData) {\r\n+    return res.status(400).send('Missing required parameters');\r\n+  }\r\n \r\n+  try {\r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+    const message = [\r\n+      `From: ${emailData.from}`,\r\n+      `To: ${emailData.to}`,\r\n+      'Content-Type: text/html; charset=utf-8',\r\n+      'MIME-Version: 1.0',\r\n+      `Subject: ${emailData.subject}`,\r\n+      '',\r\n+      emailData.body\r\n+    ].join('\\n');\r\n+\r\n+    const encodedMessage = Buffer.from(message)\r\n+      .toString('base64')\r\n+      .replace(/\\+/g, '-')\r\n+      .replace(/\\//g, '_')\r\n+      .replace(/=+$/, '');\r\n+\r\n+    const response = await gmail.users.messages.send({\r\n+      userId: 'me',\r\n+      requestBody: {\r\n+        raw: encodedMessage\r\n+      }\r\n+    });\r\n+\r\n+    res.json({ success: true, data: response.data });\r\n+  } catch (error) {\r\n+    console.error('Error sending email', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n app.listen(PORT, () => {\r\n   console.log(`Server running on port ${PORT}`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748453675274,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,7 +82,41 @@\n     console.error('Error sending email', error);\r\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n+app.get('/get-emails', async (req, res) => {\r\n+  const { accessToken, maxResults = 10 } = req.query;\r\n+  \r\n+  if (!accessToken) {\r\n+    return res.status(400).send('Access token is required');\r\n+  }\r\n+\r\n+  try {\r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+    const response = await gmail.users.messages.list({\r\n+      userId: 'me',\r\n+      maxResults: parseInt(maxResults)\r\n+    });\r\n+\r\n+    const messages = response.data.messages || [];\r\n+    const emails = [];\r\n+\r\n+    for (const message of messages) {\r\n+      const email = await gmail.users.messages.get({\r\n+        userId: 'me',\r\n+        id: message.id,\r\n+        format: 'full'\r\n+      });\r\n+      emails.push(email.data);\r\n+    }\r\n+\r\n+    res.json({ success: true, data: emails });\r\n+  } catch (error) {\r\n+    console.error('Error retrieving emails', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n app.listen(PORT, () => {\r\n   console.log(`Server running on port ${PORT}`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748453682422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -116,7 +116,8 @@\n     console.error('Error retrieving emails', error);\r\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n+\r\n app.listen(PORT, () => {\r\n   console.log(`Server running on port ${PORT}`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748454086719,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n       'https://www.googleapis.com/auth/gmail.send',\r\n       'https://www.googleapis.com/auth/gmail.modify',\r\n       'https://mail.google.com/'\r\n     ],\r\n-    prompt: 'consent'\r\n+    prompt: 'consent\r\n   });\r\n   res.redirect(url);\r\n });\r\n \r\n@@ -116,8 +116,28 @@\n     console.error('Error retrieving emails', error);\r\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n+app.post('/refresh-token', async (req, res) => {\r\n+  const { refreshToken } = req.body;\r\n+  \r\n+  if (!refreshToken) {\r\n+    return res.status(400).send('Refresh token is required');\r\n+  }\r\n \r\n+  try {\r\n+    oAuth2Client.setCredentials({ refresh_token: refreshToken });\r\n+    const { credentials } = await oAuth2Client.refreshAccessToken();\r\n+    \r\n+    res.json({ \r\n+      success: true, \r\n+      access_token: credentials.access_token,\r\n+      expiry_date: credentials.expiry_date\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error refreshing token', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n app.listen(PORT, () => {\r\n   console.log(`Server running on port ${PORT}`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748454154134,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n       'https://www.googleapis.com/auth/gmail.send',\r\n       'https://www.googleapis.com/auth/gmail.modify',\r\n       'https://mail.google.com/'\r\n     ],\r\n-    prompt: 'consent\r\n+    prompt: 'consent'\r\n   });\r\n   res.redirect(url);\r\n });\r\n \r\n@@ -33,14 +33,23 @@\n   const { code } = req.query;\r\n   \r\n   try {\r\n     const { tokens } = await oAuth2Client.getToken(code);\r\n-    oAuth2Client.setCredentials(tokens);\r\n     \r\n-    // Rediriger vers le frontend avec les tokens\r\n-    res.redirect(`${process.env.FRONTEND_REDIRECT_URI}?access_token=${tokens.access_token}&refresh_token=${tokens.refresh_token}`);\r\n+    // Vérifiez la présence du refresh token\r\n+    if (!tokens.refresh_token) {\r\n+      console.warn('No refresh token received. User might need to re-authenticate.');\r\n+    }\r\n+    \r\n+    // Stockez ces tokens en sécurité (DB ou session)\r\n+    console.log('Access Token:', tokens.access_token);\r\n+    console.log('Refresh Token:', tokens.refresh_token);\r\n+    console.log('Expiry Date:', new Date(tokens.expiry_date));\r\n+    \r\n+    // Redirection avec tous les tokens\r\n+    res.redirect(`${process.env.FRONTEND_REDIRECT_URI}?access_token=${tokens.access_token}&refresh_token=${tokens.refresh_token || ''}&expires_in=${tokens.expiry_date}`);\r\n   } catch (error) {\r\n-    console.error('Error retrieving access token', error);\r\n+    console.error('Error retrieving tokens', error);\r\n     res.status(500).send('Authentication failed');\r\n   }\r\n });\r\n app.post('/send-email', async (req, res) => {\r\n"
                },
                {
                    "date": 1748455905836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n const PORT = process.env.PORT || 3000;\r\n const oAuth2Client = new google.auth.OAuth2(\r\n   process.env.CLIENT_ID,\r\n   process.env.CLIENT_SECRET,\r\n-  process.env.REDIRECT_URI\r\n+  'http://localhost:3000/auth/google/callback'\r\n );\r\n // Générer l'URL d'authentification\r\n app.get('/auth/google', (req, res) => {\r\n   const url = oAuth2Client.generateAuthUrl({\r\n"
                },
                {
                    "date": 1748455929624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,9 @@\n     access_type: 'offline',\r\n     scope: [\r\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n       'https://www.googleapis.com/auth/gmail.send',\r\n-      'https://www.googleapis.com/auth/gmail.modify',\r\n+      //'https://www.googleapis.com/auth/gmail.modify',\r\n       'https://mail.google.com/'\r\n     ],\r\n     prompt: 'consent'\r\n   });\r\n"
                },
                {
                    "date": 1748455936838,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,11 +18,11 @@\n   const url = oAuth2Client.generateAuthUrl({\r\n     access_type: 'offline',\r\n     scope: [\r\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n-      'https://www.googleapis.com/auth/gmail.send',\r\n+      'https://www.googleapis.com/auth/gmail.send'\r\n       //'https://www.googleapis.com/auth/gmail.modify',\r\n-      'https://mail.google.com/'\r\n+      //'https://mail.google.com/'\r\n     ],\r\n     prompt: 'consent'\r\n   });\r\n   res.redirect(url);\r\n"
                },
                {
                    "date": 1748459180749,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,52 +7,50 @@\n app.use(cors());\r\n app.use(express.json());\r\n \r\n const PORT = process.env.PORT || 3000;\r\n+const express = require('express');\r\n+const { google } = require('googleapis');\r\n+const app = express();\r\n+\r\n const oAuth2Client = new google.auth.OAuth2(\r\n-  process.env.CLIENT_ID,\r\n-  process.env.CLIENT_SECRET,\r\n-  'http://localhost:3000/auth/google/callback'\r\n+  '272700212454-9s5a11um6udgkmpgiin3j0mngvbua4pa.apps.googleusercontent.com',\r\n+  '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',\r\n+  'http://localhost:3000/auth/google/callback' // Doit MATCHER exactement\r\n );\r\n-// Générer l'URL d'authentification\r\n+\r\n+// Endpoint d'initiation\r\n app.get('/auth/google', (req, res) => {\r\n   const url = oAuth2Client.generateAuthUrl({\r\n     access_type: 'offline',\r\n     scope: [\r\n-      'https://www.googleapis.com/auth/gmail.readonly',\r\n-      'https://www.googleapis.com/auth/gmail.send'\r\n-      //'https://www.googleapis.com/auth/gmail.modify',\r\n-      //'https://mail.google.com/'\r\n+      'https://www.googleapis.com/auth/gmail.send',\r\n+      'https://www.googleapis.com/auth/gmail.readonly'\r\n     ],\r\n     prompt: 'consent'\r\n   });\r\n   res.redirect(url);\r\n });\r\n \r\n-// Callback pour récupérer le token\r\n+// Endpoint de callback\r\n app.get('/auth/google/callback', async (req, res) => {\r\n-  const { code } = req.query;\r\n-  \r\n   try {\r\n+    const { code } = req.query;\r\n+    if (!code) throw new Error('No code received');\r\n+    \r\n     const { tokens } = await oAuth2Client.getToken(code);\r\n+    console.log('Tokens received:', tokens);\r\n     \r\n-    // Vérifiez la présence du refresh token\r\n-    if (!tokens.refresh_token) {\r\n-      console.warn('No refresh token received. User might need to re-authenticate.');\r\n-    }\r\n-    \r\n-    // Stockez ces tokens en sécurité (DB ou session)\r\n-    console.log('Access Token:', tokens.access_token);\r\n-    console.log('Refresh Token:', tokens.refresh_token);\r\n-    console.log('Expiry Date:', new Date(tokens.expiry_date));\r\n-    \r\n-    // Redirection avec tous les tokens\r\n-    res.redirect(`${process.env.FRONTEND_REDIRECT_URI}?access_token=${tokens.access_token}&refresh_token=${tokens.refresh_token || ''}&expires_in=${tokens.expiry_date}`);\r\n+    res.send(`Authentification réussie !<br>\r\n+      Access Token: ${tokens.access_token}<br>\r\n+      Refresh Token: ${tokens.refresh_token}`);\r\n   } catch (error) {\r\n-    console.error('Error retrieving tokens', error);\r\n-    res.status(500).send('Authentication failed');\r\n+    console.error('Error:', error);\r\n+    res.status(500).send('Erreur d\\'authentification');\r\n   }\r\n });\r\n+\r\n+app.listen(3000, () => console.log('Server running on http://localhost:3000'));\r\n app.post('/send-email', async (req, res) => {\r\n   const { accessToken, emailData } = req.body;\r\n   \r\n   if (!accessToken || !emailData) {\r\n"
                },
                {
                    "date": 1748459187848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,12 +7,10 @@\n app.use(cors());\r\n app.use(express.json());\r\n \r\n const PORT = process.env.PORT || 3000;\r\n-const express = require('express');\r\n-const { google } = require('googleapis');\r\n-const app = express();\r\n \r\n+\r\n const oAuth2Client = new google.auth.OAuth2(\r\n   '272700212454-9s5a11um6udgkmpgiin3j0mngvbua4pa.apps.googleusercontent.com',\r\n   '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',\r\n   'http://localhost:3000/auth/google/callback' // Doit MATCHER exactement\r\n"
                },
                {
                    "date": 1748459784562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,24 +47,20 @@\n   }\r\n });\r\n \r\n app.listen(3000, () => console.log('Server running on http://localhost:3000'));\r\n+// Envoi d'email\r\n app.post('/send-email', async (req, res) => {\r\n   const { accessToken, emailData } = req.body;\r\n   \r\n-  if (!accessToken || !emailData) {\r\n-    return res.status(400).send('Missing required parameters');\r\n-  }\r\n-\r\n   try {\r\n     oAuth2Client.setCredentials({ access_token: accessToken });\r\n     const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n \r\n     const message = [\r\n       `From: ${emailData.from}`,\r\n       `To: ${emailData.to}`,\r\n       'Content-Type: text/html; charset=utf-8',\r\n-      'MIME-Version: 1.0',\r\n       `Subject: ${emailData.subject}`,\r\n       '',\r\n       emailData.body\r\n     ].join('\\n');\r\n@@ -74,19 +70,21 @@\n       .replace(/\\+/g, '-')\r\n       .replace(/\\//g, '_')\r\n       .replace(/=+$/, '');\r\n \r\n-    const response = await gmail.users.messages.send({\r\n+    await gmail.users.messages.send({\r\n       userId: 'me',\r\n-      requestBody: {\r\n-        raw: encodedMessage\r\n-      }\r\n+      requestBody: { raw: encodedMessage }\r\n     });\r\n \r\n-    res.json({ success: true, data: response.data });\r\n+    res.json({ success: true });\r\n   } catch (error) {\r\n-    console.error('Error sending email', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n+    console.error('Error sending email:', error);\r\n+    res.status(500).json({ \r\n+      success: false,\r\n+      error: error.message,\r\n+      details: error.response?.data\r\n+    });\r\n   }\r\n });\r\n app.get('/get-emails', async (req, res) => {\r\n   const { accessToken, maxResults = 10 } = req.query;\r\n"
                },
                {
                    "date": 1748459853198,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,11 +10,11 @@\n const PORT = process.env.PORT || 3000;\r\n \r\n \r\n const oAuth2Client = new google.auth.OAuth2(\r\n-  '272700212454-9s5a11um6udgkmpgiin3j0mngvbua4pa.apps.googleusercontent.com',\r\n-  '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',\r\n-  'http://localhost:3000/auth/google/callback' // Doit MATCHER exactement\r\n+  process.env.CLIENT_ID,\r\n+  process.env.CLIENT_SECRET,\r\n+  process.env.REDIRECT_URI\r\n );\r\n \r\n // Endpoint d'initiation\r\n app.get('/auth/google', (req, res) => {\r\n"
                },
                {
                    "date": 1748459961310,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,11 +10,11 @@\n const PORT = process.env.PORT || 3000;\r\n \r\n \r\n const oAuth2Client = new google.auth.OAuth2(\r\n-  process.env.CLIENT_ID,\r\n-  process.env.CLIENT_SECRET,\r\n-  process.env.REDIRECT_URI\r\n+  '272700212454-9s5a11um6udgkmpgiin3j0mngvbua4pa.apps.googleusercontent.com',\r\n+  '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',\r\n+  'http://localhost:3000/auth/google/callback' // Doit MATCHER exactement\r\n );\r\n \r\n // Endpoint d'initiation\r\n app.get('/auth/google', (req, res) => {\r\n"
                },
                {
                    "date": 1748459981591,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -47,20 +47,24 @@\n   }\r\n });\r\n \r\n app.listen(3000, () => console.log('Server running on http://localhost:3000'));\r\n-// Envoi d'email\r\n app.post('/send-email', async (req, res) => {\r\n   const { accessToken, emailData } = req.body;\r\n   \r\n+  if (!accessToken || !emailData) {\r\n+    return res.status(400).send('Missing required parameters');\r\n+  }\r\n+\r\n   try {\r\n     oAuth2Client.setCredentials({ access_token: accessToken });\r\n     const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n \r\n     const message = [\r\n       `From: ${emailData.from}`,\r\n       `To: ${emailData.to}`,\r\n       'Content-Type: text/html; charset=utf-8',\r\n+      'MIME-Version: 1.0',\r\n       `Subject: ${emailData.subject}`,\r\n       '',\r\n       emailData.body\r\n     ].join('\\n');\r\n@@ -70,21 +74,19 @@\n       .replace(/\\+/g, '-')\r\n       .replace(/\\//g, '_')\r\n       .replace(/=+$/, '');\r\n \r\n-    await gmail.users.messages.send({\r\n+    const response = await gmail.users.messages.send({\r\n       userId: 'me',\r\n-      requestBody: { raw: encodedMessage }\r\n+      requestBody: {\r\n+        raw: encodedMessage\r\n+      }\r\n     });\r\n \r\n-    res.json({ success: true });\r\n+    res.json({ success: true, data: response.data });\r\n   } catch (error) {\r\n-    console.error('Error sending email:', error);\r\n-    res.status(500).json({ \r\n-      success: false,\r\n-      error: error.message,\r\n-      details: error.response?.data\r\n-    });\r\n+    console.error('Error sending email', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n app.get('/get-emails', async (req, res) => {\r\n   const { accessToken, maxResults = 10 } = req.query;\r\n"
                },
                {
                    "date": 1748460124238,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,39 +16,10 @@\n   'http://localhost:3000/auth/google/callback' // Doit MATCHER exactement\r\n );\r\n \r\n // Endpoint d'initiation\r\n-app.get('/auth/google', (req, res) => {\r\n-  const url = oAuth2Client.generateAuthUrl({\r\n-    access_type: 'offline',\r\n-    scope: [\r\n-      'https://www.googleapis.com/auth/gmail.send',\r\n-      'https://www.googleapis.com/auth/gmail.readonly'\r\n-    ],\r\n-    prompt: 'consent'\r\n-  });\r\n-  res.redirect(url);\r\n-});\r\n \r\n-// Endpoint de callback\r\n-app.get('/auth/google/callback', async (req, res) => {\r\n-  try {\r\n-    const { code } = req.query;\r\n-    if (!code) throw new Error('No code received');\r\n-    \r\n-    const { tokens } = await oAuth2Client.getToken(code);\r\n-    console.log('Tokens received:', tokens);\r\n-    \r\n-    res.send(`Authentification réussie !<br>\r\n-      Access Token: ${tokens.access_token}<br>\r\n-      Refresh Token: ${tokens.refresh_token}`);\r\n-  } catch (error) {\r\n-    console.error('Error:', error);\r\n-    res.status(500).send('Erreur d\\'authentification');\r\n-  }\r\n-});\r\n \r\n-app.listen(3000, () => console.log('Server running on http://localhost:3000'));\r\n app.post('/send-email', async (req, res) => {\r\n   const { accessToken, emailData } = req.body;\r\n   \r\n   if (!accessToken || !emailData) {\r\n"
                },
                {
                    "date": 1748460264679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,10 +16,40 @@\n   'http://localhost:3000/auth/google/callback' // Doit MATCHER exactement\r\n );\r\n \r\n // Endpoint d'initiation\r\n+app.get('/auth/google', (req, res) => {\r\n+  const url = oAuth2Client.generateAuthUrl({\r\n+    access_type: 'offline',\r\n+    scope: [\r\n+      'https://www.googleapis.com/auth/gmail.send',\r\n+      'https://www.googleapis.com/auth/gmail.readonly'\r\n+    ],\r\n+    prompt: 'consent'\r\n+  });\r\n+  res.redirect(url);\r\n+});\r\n \r\n+// Endpoint de callback\r\n+app.get('/auth/google/callback', async (req, res) => {\r\n+  try {\r\n+    const { code } = req.query;\r\n+    if (!code) throw new Error('No code received');\r\n+    \r\n+    const { tokens } = await oAuth2Client.getToken(code);\r\n+    console.log('Tokens received:', tokens);\r\n+    \r\n+    res.send(`Authentification réussie !<br>\r\n+      Access Token: ${tokens.access_token}<br>\r\n+      Refresh Token: ${tokens.refresh_token}`);\r\n+  } catch (error) {\r\n+    console.error('Error:', error);\r\n+    res.status(500).send('Erreur d\\'authentification');\r\n+  }\r\n+});\r\n \r\n+app.listen(PORT, () => console.log('Server running on http://localhost:3000'));\r\n+\r\n app.post('/send-email', async (req, res) => {\r\n   const { accessToken, emailData } = req.body;\r\n   \r\n   if (!accessToken || !emailData) {\r\n"
                },
                {
                    "date": 1748460502129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,16 +8,29 @@\n app.use(express.json());\r\n \r\n const PORT = process.env.PORT || 3000;\r\n \r\n-\r\n+// Configuration OAuth2\r\n const oAuth2Client = new google.auth.OAuth2(\r\n   '272700212454-9s5a11um6udgkmpgiin3j0mngvbua4pa.apps.googleusercontent.com',\r\n   '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',\r\n-  'http://localhost:3000/auth/google/callback' // Doit MATCHER exactement\r\n+  'http://localhost:3000/auth/google/callback'\r\n );\r\n \r\n-// Endpoint d'initiation\r\n+// Stockage en mémoire (remplacez par une base de données en production)\r\n+let tokenStore = {};\r\n+\r\n+// Middleware pour vérifier l'authentification\r\n+const authenticate = (req, res, next) => {\r\n+  const { accessToken } = req.query || req.body;\r\n+  if (!accessToken) {\r\n+    return res.status(401).json({ error: 'Access token required' });\r\n+  }\r\n+  oAuth2Client.setCredentials({ access_token: accessToken });\r\n+  next();\r\n+};\r\n+\r\n+// Endpoint d'authentification\r\n app.get('/auth/google', (req, res) => {\r\n   const url = oAuth2Client.generateAuthUrl({\r\n     access_type: 'offline',\r\n     scope: [\r\n@@ -28,44 +41,42 @@\n   });\r\n   res.redirect(url);\r\n });\r\n \r\n-// Endpoint de callback\r\n+// Callback OAuth\r\n app.get('/auth/google/callback', async (req, res) => {\r\n   try {\r\n     const { code } = req.query;\r\n-    if (!code) throw new Error('No code received');\r\n-    \r\n+    if (!code) throw new Error('Authorization code missing');\r\n+\r\n     const { tokens } = await oAuth2Client.getToken(code);\r\n-    console.log('Tokens received:', tokens);\r\n-    \r\n-    res.send(`Authentification réussie !<br>\r\n-      Access Token: ${tokens.access_token}<br>\r\n-      Refresh Token: ${tokens.refresh_token}`);\r\n+    tokenStore = tokens; // Stockez en base de données en production\r\n+\r\n+    res.send(`\r\n+      <h1>Authentification réussie</h1>\r\n+      <p>Access Token: ${tokens.access_token}</p>\r\n+      <p>Refresh Token: ${tokens.refresh_token || 'Non fourni'}</p>\r\n+      <p>Expire dans: ${Math.round((tokens.expiry_date - Date.now()) / 1000} secondes</p>\r\n+    `);\r\n   } catch (error) {\r\n-    console.error('Error:', error);\r\n-    res.status(500).send('Erreur d\\'authentification');\r\n+    console.error('OAuth callback error:', error);\r\n+    res.status(500).send('Authentication failed: ' + error.message);\r\n   }\r\n });\r\n \r\n-app.listen(PORT, () => console.log('Server running on http://localhost:3000'));\r\n+// Envoi d'email\r\n+app.post('/send-email', authenticate, async (req, res) => {\r\n+  try {\r\n+    const { emailData } = req.body;\r\n+    if (!emailData || !emailData.to || !emailData.subject || !emailData.body) {\r\n+      return res.status(400).json({ error: 'Invalid email data' });\r\n+    }\r\n \r\n-app.post('/send-email', async (req, res) => {\r\n-  const { accessToken, emailData } = req.body;\r\n-  \r\n-  if (!accessToken || !emailData) {\r\n-    return res.status(400).send('Missing required parameters');\r\n-  }\r\n-\r\n-  try {\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n     const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n     const message = [\r\n-      `From: ${emailData.from}`,\r\n+      `From: ${emailData.from || 'me'}`,\r\n       `To: ${emailData.to}`,\r\n       'Content-Type: text/html; charset=utf-8',\r\n-      'MIME-Version: 1.0',\r\n       `Subject: ${emailData.subject}`,\r\n       '',\r\n       emailData.body\r\n     ].join('\\n');\r\n@@ -77,73 +88,80 @@\n       .replace(/=+$/, '');\r\n \r\n     const response = await gmail.users.messages.send({\r\n       userId: 'me',\r\n-      requestBody: {\r\n-        raw: encodedMessage\r\n-      }\r\n+      requestBody: { raw: encodedMessage }\r\n     });\r\n \r\n-    res.json({ success: true, data: response.data });\r\n+    res.json({ \r\n+      success: true, \r\n+      messageId: response.data.id \r\n+    });\r\n   } catch (error) {\r\n-    console.error('Error sending email', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n+    console.error('Send email error:', error);\r\n+    res.status(500).json({ \r\n+      error: error.message,\r\n+      details: error.response?.data \r\n+    });\r\n   }\r\n });\r\n-app.get('/get-emails', async (req, res) => {\r\n-  const { accessToken, maxResults = 10 } = req.query;\r\n-  \r\n-  if (!accessToken) {\r\n-    return res.status(400).send('Access token is required');\r\n-  }\r\n \r\n+// Récupération des emails\r\n+app.get('/get-emails', authenticate, async (req, res) => {\r\n   try {\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const { maxResults = 10 } = req.query;\r\n     const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n \r\n     const response = await gmail.users.messages.list({\r\n       userId: 'me',\r\n       maxResults: parseInt(maxResults)\r\n     });\r\n \r\n-    const messages = response.data.messages || [];\r\n-    const emails = [];\r\n-\r\n-    for (const message of messages) {\r\n-      const email = await gmail.users.messages.get({\r\n-        userId: 'me',\r\n-        id: message.id,\r\n-        format: 'full'\r\n-      });\r\n-      emails.push(email.data);\r\n-    }\r\n-\r\n-    res.json({ success: true, data: emails });\r\n+    res.json({ \r\n+      success: true, \r\n+      messages: response.data.messages || [] \r\n+    });\r\n   } catch (error) {\r\n-    console.error('Error retrieving emails', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n+    console.error('Get emails error:', error);\r\n+    res.status(500).json({ \r\n+      error: error.message,\r\n+      details: error.response?.data \r\n+    });\r\n   }\r\n });\r\n+\r\n+// Rafraîchissement du token\r\n app.post('/refresh-token', async (req, res) => {\r\n-  const { refreshToken } = req.body;\r\n-  \r\n-  if (!refreshToken) {\r\n-    return res.status(400).send('Refresh token is required');\r\n-  }\r\n+  try {\r\n+    const { refreshToken } = req.body;\r\n+    if (!refreshToken) {\r\n+      return res.status(400).json({ error: 'Refresh token required' });\r\n+    }\r\n \r\n-  try {\r\n     oAuth2Client.setCredentials({ refresh_token: refreshToken });\r\n     const { credentials } = await oAuth2Client.refreshAccessToken();\r\n-    \r\n-    res.json({ \r\n-      success: true, \r\n+    tokenStore = credentials; // Mise à jour du stockage\r\n+\r\n+    res.json({\r\n+      success: true,\r\n       access_token: credentials.access_token,\r\n       expiry_date: credentials.expiry_date\r\n     });\r\n   } catch (error) {\r\n-    console.error('Error refreshing token', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n+    console.error('Refresh token error:', error);\r\n+    res.status(500).json({ \r\n+      error: error.message,\r\n+      details: error.response?.data \r\n+    });\r\n   }\r\n });\r\n+\r\n+// Démarrer le serveur\r\n app.listen(PORT, () => {\r\n-  console.log(`Server running on port ${PORT}`);\r\n+  console.log(`Server running on http://localhost:${PORT}`);\r\n+  console.log('Available endpoints:');\r\n+  console.log(`- GET  /auth/google`);\r\n+  console.log(`- GET  /auth/google/callback`);\r\n+  console.log(`- POST /send-email`);\r\n+  console.log(`- GET  /get-emails`);\r\n+  console.log(`- POST /refresh-token`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748460518621,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,167 +0,0 @@\n-require('dotenv').config();\r\n-const express = require('express');\r\n-const { google } = require('googleapis');\r\n-const cors = require('cors');\r\n-\r\n-const app = express();\r\n-app.use(cors());\r\n-app.use(express.json());\r\n-\r\n-const PORT = process.env.PORT || 3000;\r\n-\r\n-// Configuration OAuth2\r\n-const oAuth2Client = new google.auth.OAuth2(\r\n-  '272700212454-9s5a11um6udgkmpgiin3j0mngvbua4pa.apps.googleusercontent.com',\r\n-  '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',\r\n-  'http://localhost:3000/auth/google/callback'\r\n-);\r\n-\r\n-// Stockage en mémoire (remplacez par une base de données en production)\r\n-let tokenStore = {};\r\n-\r\n-// Middleware pour vérifier l'authentification\r\n-const authenticate = (req, res, next) => {\r\n-  const { accessToken } = req.query || req.body;\r\n-  if (!accessToken) {\r\n-    return res.status(401).json({ error: 'Access token required' });\r\n-  }\r\n-  oAuth2Client.setCredentials({ access_token: accessToken });\r\n-  next();\r\n-};\r\n-\r\n-// Endpoint d'authentification\r\n-app.get('/auth/google', (req, res) => {\r\n-  const url = oAuth2Client.generateAuthUrl({\r\n-    access_type: 'offline',\r\n-    scope: [\r\n-      'https://www.googleapis.com/auth/gmail.send',\r\n-      'https://www.googleapis.com/auth/gmail.readonly'\r\n-    ],\r\n-    prompt: 'consent'\r\n-  });\r\n-  res.redirect(url);\r\n-});\r\n-\r\n-// Callback OAuth\r\n-app.get('/auth/google/callback', async (req, res) => {\r\n-  try {\r\n-    const { code } = req.query;\r\n-    if (!code) throw new Error('Authorization code missing');\r\n-\r\n-    const { tokens } = await oAuth2Client.getToken(code);\r\n-    tokenStore = tokens; // Stockez en base de données en production\r\n-\r\n-    res.send(`\r\n-      <h1>Authentification réussie</h1>\r\n-      <p>Access Token: ${tokens.access_token}</p>\r\n-      <p>Refresh Token: ${tokens.refresh_token || 'Non fourni'}</p>\r\n-      <p>Expire dans: ${Math.round((tokens.expiry_date - Date.now()) / 1000} secondes</p>\r\n-    `);\r\n-  } catch (error) {\r\n-    console.error('OAuth callback error:', error);\r\n-    res.status(500).send('Authentication failed: ' + error.message);\r\n-  }\r\n-});\r\n-\r\n-// Envoi d'email\r\n-app.post('/send-email', authenticate, async (req, res) => {\r\n-  try {\r\n-    const { emailData } = req.body;\r\n-    if (!emailData || !emailData.to || !emailData.subject || !emailData.body) {\r\n-      return res.status(400).json({ error: 'Invalid email data' });\r\n-    }\r\n-\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-    const message = [\r\n-      `From: ${emailData.from || 'me'}`,\r\n-      `To: ${emailData.to}`,\r\n-      'Content-Type: text/html; charset=utf-8',\r\n-      `Subject: ${emailData.subject}`,\r\n-      '',\r\n-      emailData.body\r\n-    ].join('\\n');\r\n-\r\n-    const encodedMessage = Buffer.from(message)\r\n-      .toString('base64')\r\n-      .replace(/\\+/g, '-')\r\n-      .replace(/\\//g, '_')\r\n-      .replace(/=+$/, '');\r\n-\r\n-    const response = await gmail.users.messages.send({\r\n-      userId: 'me',\r\n-      requestBody: { raw: encodedMessage }\r\n-    });\r\n-\r\n-    res.json({ \r\n-      success: true, \r\n-      messageId: response.data.id \r\n-    });\r\n-  } catch (error) {\r\n-    console.error('Send email error:', error);\r\n-    res.status(500).json({ \r\n-      error: error.message,\r\n-      details: error.response?.data \r\n-    });\r\n-  }\r\n-});\r\n-\r\n-// Récupération des emails\r\n-app.get('/get-emails', authenticate, async (req, res) => {\r\n-  try {\r\n-    const { maxResults = 10 } = req.query;\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    const response = await gmail.users.messages.list({\r\n-      userId: 'me',\r\n-      maxResults: parseInt(maxResults)\r\n-    });\r\n-\r\n-    res.json({ \r\n-      success: true, \r\n-      messages: response.data.messages || [] \r\n-    });\r\n-  } catch (error) {\r\n-    console.error('Get emails error:', error);\r\n-    res.status(500).json({ \r\n-      error: error.message,\r\n-      details: error.response?.data \r\n-    });\r\n-  }\r\n-});\r\n-\r\n-// Rafraîchissement du token\r\n-app.post('/refresh-token', async (req, res) => {\r\n-  try {\r\n-    const { refreshToken } = req.body;\r\n-    if (!refreshToken) {\r\n-      return res.status(400).json({ error: 'Refresh token required' });\r\n-    }\r\n-\r\n-    oAuth2Client.setCredentials({ refresh_token: refreshToken });\r\n-    const { credentials } = await oAuth2Client.refreshAccessToken();\r\n-    tokenStore = credentials; // Mise à jour du stockage\r\n-\r\n-    res.json({\r\n-      success: true,\r\n-      access_token: credentials.access_token,\r\n-      expiry_date: credentials.expiry_date\r\n-    });\r\n-  } catch (error) {\r\n-    console.error('Refresh token error:', error);\r\n-    res.status(500).json({ \r\n-      error: error.message,\r\n-      details: error.response?.data \r\n-    });\r\n-  }\r\n-});\r\n-\r\n-// Démarrer le serveur\r\n-app.listen(PORT, () => {\r\n-  console.log(`Server running on http://localhost:${PORT}`);\r\n-  console.log('Available endpoints:');\r\n-  console.log(`- GET  /auth/google`);\r\n-  console.log(`- GET  /auth/google/callback`);\r\n-  console.log(`- POST /send-email`);\r\n-  console.log(`- GET  /get-emails`);\r\n-  console.log(`- POST /refresh-token`);\r\n-});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748460584420,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,167 @@\n+require('dotenv').config();\r\n+const express = require('express');\r\n+const { google } = require('googleapis');\r\n+const cors = require('cors');\r\n+\r\n+const app = express();\r\n+app.use(cors());\r\n+app.use(express.json());\r\n+\r\n+const PORT = process.env.PORT || 3000;\r\n+\r\n+// Configuration OAuth2\r\n+const oAuth2Client = new google.auth.OAuth2(\r\n+  '272700212454-9s5a11um6udgkmpgiin3j0mngvbua4pa.apps.googleusercontent.com',\r\n+  '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',\r\n+  'http://localhost:3000/auth/google/callback'\r\n+);\r\n+\r\n+// Stockage en mémoire (remplacez par une base de données en production)\r\n+let tokenStore = {};\r\n+\r\n+// Middleware pour vérifier l'authentification\r\n+const authenticate = (req, res, next) => {\r\n+  const { accessToken } = req.query || req.body;\r\n+  if (!accessToken) {\r\n+    return res.status(401).json({ error: 'Access token required' });\r\n+  }\r\n+  oAuth2Client.setCredentials({ access_token: accessToken });\r\n+  next();\r\n+};\r\n+\r\n+// Endpoint d'authentification\r\n+app.get('/auth/google', (req, res) => {\r\n+  const url = oAuth2Client.generateAuthUrl({\r\n+    access_type: 'offline',\r\n+    scope: [\r\n+      'https://www.googleapis.com/auth/gmail.send',\r\n+      'https://www.googleapis.com/auth/gmail.readonly'\r\n+    ],\r\n+    prompt: 'consent'\r\n+  });\r\n+  res.redirect(url);\r\n+});\r\n+\r\n+// Callback OAuth\r\n+app.get('/auth/google/callback', async (req, res) => {\r\n+  try {\r\n+    const { code } = req.query;\r\n+    if (!code) throw new Error('Authorization code missing');\r\n+\r\n+    const { tokens } = await oAuth2Client.getToken(code);\r\n+    tokenStore = tokens; // Stockez en base de données en production\r\n+\r\n+    res.send(`\r\n+      <h1>Authentification réussie</h1>\r\n+      <p>Access Token: ${tokens.access_token}</p>\r\n+      <p>Refresh Token: ${tokens.refresh_token || 'Non fourni'}</p>\r\n+      <p>Expire dans: ${Math.round((tokens.expiry_date - Date.now()) / 1000}) secondes</p>\r\n+    `);\r\n+  } catch (error) {\r\n+    console.error('OAuth callback error:', error);\r\n+    res.status(500).send('Authentication failed: ' + error.message);\r\n+  }\r\n+});\r\n+\r\n+// Envoi d'email\r\n+app.post('/send-email', authenticate, async (req, res) => {\r\n+  try {\r\n+    const { emailData } = req.body;\r\n+    if (!emailData || !emailData.to || !emailData.subject || !emailData.body) {\r\n+      return res.status(400).json({ error: 'Invalid email data' });\r\n+    }\r\n+\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+    const message = [\r\n+      `From: ${emailData.from || 'me'}`,\r\n+      `To: ${emailData.to}`,\r\n+      'Content-Type: text/html; charset=utf-8',\r\n+      `Subject: ${emailData.subject}`,\r\n+      '',\r\n+      emailData.body\r\n+    ].join('\\n');\r\n+\r\n+    const encodedMessage = Buffer.from(message)\r\n+      .toString('base64')\r\n+      .replace(/\\+/g, '-')\r\n+      .replace(/\\//g, '_')\r\n+      .replace(/=+$/, '');\r\n+\r\n+    const response = await gmail.users.messages.send({\r\n+      userId: 'me',\r\n+      requestBody: { raw: encodedMessage }\r\n+    });\r\n+\r\n+    res.json({ \r\n+      success: true, \r\n+      messageId: response.data.id \r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Send email error:', error);\r\n+    res.status(500).json({ \r\n+      error: error.message,\r\n+      details: error.response?.data \r\n+    });\r\n+  }\r\n+});\r\n+\r\n+// Récupération des emails\r\n+app.get('/get-emails', authenticate, async (req, res) => {\r\n+  try {\r\n+    const { maxResults = 10 } = req.query;\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+    const response = await gmail.users.messages.list({\r\n+      userId: 'me',\r\n+      maxResults: parseInt(maxResults)\r\n+    });\r\n+\r\n+    res.json({ \r\n+      success: true, \r\n+      messages: response.data.messages || [] \r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Get emails error:', error);\r\n+    res.status(500).json({ \r\n+      error: error.message,\r\n+      details: error.response?.data \r\n+    });\r\n+  }\r\n+});\r\n+\r\n+// Rafraîchissement du token\r\n+app.post('/refresh-token', async (req, res) => {\r\n+  try {\r\n+    const { refreshToken } = req.body;\r\n+    if (!refreshToken) {\r\n+      return res.status(400).json({ error: 'Refresh token required' });\r\n+    }\r\n+\r\n+    oAuth2Client.setCredentials({ refresh_token: refreshToken });\r\n+    const { credentials } = await oAuth2Client.refreshAccessToken();\r\n+    tokenStore = credentials; // Mise à jour du stockage\r\n+\r\n+    res.json({\r\n+      success: true,\r\n+      access_token: credentials.access_token,\r\n+      expiry_date: credentials.expiry_date\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Refresh token error:', error);\r\n+    res.status(500).json({ \r\n+      error: error.message,\r\n+      details: error.response?.data \r\n+    });\r\n+  }\r\n+});\r\n+\r\n+// Démarrer le serveur\r\n+app.listen(PORT, () => {\r\n+  console.log(`Server running on http://localhost:${PORT}`);\r\n+  console.log('Available endpoints:');\r\n+  console.log(`- GET  /auth/google`);\r\n+  console.log(`- GET  /auth/google/callback`);\r\n+  console.log(`- POST /send-email`);\r\n+  console.log(`- GET  /get-emails`);\r\n+  console.log(`- POST /refresh-token`);\r\n+});\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748460590214,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n     res.send(`\r\n       <h1>Authentification réussie</h1>\r\n       <p>Access Token: ${tokens.access_token}</p>\r\n       <p>Refresh Token: ${tokens.refresh_token || 'Non fourni'}</p>\r\n-      <p>Expire dans: ${Math.round((tokens.expiry_date - Date.now()) / 1000}) secondes</p>\r\n+      <p>Expire dans: ${Math.round((tokens.expiry_date - Date.now()) / 1000} secondes</p>\r\n     `);\r\n   } catch (error) {\r\n     console.error('OAuth callback error:', error);\r\n     res.status(500).send('Authentication failed: ' + error.message);\r\n"
                },
                {
                    "date": 1748460596061,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n     res.send(`\r\n       <h1>Authentification réussie</h1>\r\n       <p>Access Token: ${tokens.access_token}</p>\r\n       <p>Refresh Token: ${tokens.refresh_token || 'Non fourni'}</p>\r\n-      <p>Expire dans: ${Math.round((tokens.expiry_date - Date.now()) / 1000} secondes</p>\r\n+      <p>Expire dans: ${Math.round((tokens.expiry_date - Date.now())) / 1000} secondes</p>\r\n     `);\r\n   } catch (error) {\r\n     console.error('OAuth callback error:', error);\r\n     res.status(500).send('Authentication failed: ' + error.message);\r\n"
                },
                {
                    "date": 1748460625856,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n     res.send(`\r\n       <h1>Authentification réussie</h1>\r\n       <p>Access Token: ${tokens.access_token}</p>\r\n       <p>Refresh Token: ${tokens.refresh_token || 'Non fourni'}</p>\r\n-      <p>Expire dans: ${Math.round((tokens.expiry_date - Date.now())) / 1000} secondes</p>\r\n+      <p>Expire dans: ${Math.round((tokens.expiry_date - Date.now()) / 1000} secondes</p>\r\n     `);\r\n   } catch (error) {\r\n     console.error('OAuth callback error:', error);\r\n     res.status(500).send('Authentication failed: ' + error.message);\r\n"
                },
                {
                    "date": 1748467364319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,29 +8,15 @@\n app.use(express.json());\r\n \r\n const PORT = process.env.PORT || 3000;\r\n \r\n-// Configuration OAuth2\r\n+\r\n const oAuth2Client = new google.auth.OAuth2(\r\n-  '272700212454-9s5a11um6udgkmpgiin3j0mngvbua4pa.apps.googleusercontent.com',\r\n-  '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',\r\n-  'http://localhost:3000/auth/google/callback'\r\n-);\r\n+  process.env.CLIENT_ID,\r\n+  process.env.CLIENT_SECRET,\r\n+  process.env.REDIRECT_URI);\r\n \r\n-// Stockage en mémoire (remplacez par une base de données en production)\r\n-let tokenStore = {};\r\n-\r\n-// Middleware pour vérifier l'authentification\r\n-const authenticate = (req, res, next) => {\r\n-  const { accessToken } = req.query || req.body;\r\n-  if (!accessToken) {\r\n-    return res.status(401).json({ error: 'Access token required' });\r\n-  }\r\n-  oAuth2Client.setCredentials({ access_token: accessToken });\r\n-  next();\r\n-};\r\n-\r\n-// Endpoint d'authentification\r\n+// Endpoint d'initiation\r\n app.get('/auth/google', (req, res) => {\r\n   const url = oAuth2Client.generateAuthUrl({\r\n     access_type: 'offline',\r\n     scope: [\r\n@@ -41,42 +27,44 @@\n   });\r\n   res.redirect(url);\r\n });\r\n \r\n-// Callback OAuth\r\n+// Endpoint de callback\r\n app.get('/auth/google/callback', async (req, res) => {\r\n   try {\r\n     const { code } = req.query;\r\n-    if (!code) throw new Error('Authorization code missing');\r\n-\r\n+    if (!code) throw new Error('No code received');\r\n+    \r\n     const { tokens } = await oAuth2Client.getToken(code);\r\n-    tokenStore = tokens; // Stockez en base de données en production\r\n-\r\n-    res.send(`\r\n-      <h1>Authentification réussie</h1>\r\n-      <p>Access Token: ${tokens.access_token}</p>\r\n-      <p>Refresh Token: ${tokens.refresh_token || 'Non fourni'}</p>\r\n-      <p>Expire dans: ${Math.round((tokens.expiry_date - Date.now()) / 1000} secondes</p>\r\n-    `);\r\n+    console.log('Tokens received:', tokens);\r\n+    \r\n+    res.send(`Authentification réussie !<br>\r\n+      Access Token: ${tokens.access_token}<br>\r\n+      Refresh Token: ${tokens.refresh_token}`);\r\n   } catch (error) {\r\n-    console.error('OAuth callback error:', error);\r\n-    res.status(500).send('Authentication failed: ' + error.message);\r\n+    console.error('Error:', error);\r\n+    res.status(500).send('Erreur d\\'authentification');\r\n   }\r\n });\r\n \r\n-// Envoi d'email\r\n-app.post('/send-email', authenticate, async (req, res) => {\r\n+app.listen(PORT, () => console.log('Server running on http://localhost:3000'));\r\n+\r\n+app.post('/send-email', async (req, res) => {\r\n+  const { accessToken, emailData } = req.body;\r\n+  \r\n+  if (!accessToken || !emailData) {\r\n+    return res.status(400).send('Missing required parameters');\r\n+  }\r\n+\r\n   try {\r\n-    const { emailData } = req.body;\r\n-    if (!emailData || !emailData.to || !emailData.subject || !emailData.body) {\r\n-      return res.status(400).json({ error: 'Invalid email data' });\r\n-    }\r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n \r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n     const message = [\r\n-      `From: ${emailData.from || 'me'}`,\r\n+      `From: ${emailData.from}`,\r\n       `To: ${emailData.to}`,\r\n       'Content-Type: text/html; charset=utf-8',\r\n+      'MIME-Version: 1.0',\r\n       `Subject: ${emailData.subject}`,\r\n       '',\r\n       emailData.body\r\n     ].join('\\n');\r\n@@ -88,80 +76,73 @@\n       .replace(/=+$/, '');\r\n \r\n     const response = await gmail.users.messages.send({\r\n       userId: 'me',\r\n-      requestBody: { raw: encodedMessage }\r\n+      requestBody: {\r\n+        raw: encodedMessage\r\n+      }\r\n     });\r\n \r\n-    res.json({ \r\n-      success: true, \r\n-      messageId: response.data.id \r\n-    });\r\n+    res.json({ success: true, data: response.data });\r\n   } catch (error) {\r\n-    console.error('Send email error:', error);\r\n-    res.status(500).json({ \r\n-      error: error.message,\r\n-      details: error.response?.data \r\n-    });\r\n+    console.error('Error sending email', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n+app.get('/get-emails', async (req, res) => {\r\n+  const { accessToken, maxResults = 10 } = req.query;\r\n+  \r\n+  if (!accessToken) {\r\n+    return res.status(400).send('Access token is required');\r\n+  }\r\n \r\n-// Récupération des emails\r\n-app.get('/get-emails', authenticate, async (req, res) => {\r\n   try {\r\n-    const { maxResults = 10 } = req.query;\r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n     const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n \r\n     const response = await gmail.users.messages.list({\r\n       userId: 'me',\r\n       maxResults: parseInt(maxResults)\r\n     });\r\n \r\n-    res.json({ \r\n-      success: true, \r\n-      messages: response.data.messages || [] \r\n-    });\r\n+    const messages = response.data.messages || [];\r\n+    const emails = [];\r\n+\r\n+    for (const message of messages) {\r\n+      const email = await gmail.users.messages.get({\r\n+        userId: 'me',\r\n+        id: message.id,\r\n+        format: 'full'\r\n+      });\r\n+      emails.push(email.data);\r\n+    }\r\n+\r\n+    res.json({ success: true, data: emails });\r\n   } catch (error) {\r\n-    console.error('Get emails error:', error);\r\n-    res.status(500).json({ \r\n-      error: error.message,\r\n-      details: error.response?.data \r\n-    });\r\n+    console.error('Error retrieving emails', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n+app.post('/refresh-token', async (req, res) => {\r\n+  const { refreshToken } = req.body;\r\n+  \r\n+  if (!refreshToken) {\r\n+    return res.status(400).send('Refresh token is required');\r\n+  }\r\n \r\n-// Rafraîchissement du token\r\n-app.post('/refresh-token', async (req, res) => {\r\n   try {\r\n-    const { refreshToken } = req.body;\r\n-    if (!refreshToken) {\r\n-      return res.status(400).json({ error: 'Refresh token required' });\r\n-    }\r\n-\r\n     oAuth2Client.setCredentials({ refresh_token: refreshToken });\r\n     const { credentials } = await oAuth2Client.refreshAccessToken();\r\n-    tokenStore = credentials; // Mise à jour du stockage\r\n-\r\n-    res.json({\r\n-      success: true,\r\n+    \r\n+    res.json({ \r\n+      success: true, \r\n       access_token: credentials.access_token,\r\n       expiry_date: credentials.expiry_date\r\n     });\r\n   } catch (error) {\r\n-    console.error('Refresh token error:', error);\r\n-    res.status(500).json({ \r\n-      error: error.message,\r\n-      details: error.response?.data \r\n-    });\r\n+    console.error('Error refreshing token', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n-\r\n-// Démarrer le serveur\r\n app.listen(PORT, () => {\r\n-  console.log(`Server running on http://localhost:${PORT}`);\r\n-  console.log('Available endpoints:');\r\n-  console.log(`- GET  /auth/google`);\r\n-  console.log(`- GET  /auth/google/callback`);\r\n-  console.log(`- POST /send-email`);\r\n-  console.log(`- GET  /get-emails`);\r\n-  console.log(`- POST /refresh-token`);\r\n+  console.log(`Server running on port ${PORT}`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748472632498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,9 +20,10 @@\n   const url = oAuth2Client.generateAuthUrl({\r\n     access_type: 'offline',\r\n     scope: [\r\n       'https://www.googleapis.com/auth/gmail.send',\r\n-      'https://www.googleapis.com/auth/gmail.readonly'\r\n+      'https://www.googleapis.com/auth/gmail.readonly',\r\n+      \r\n     ],\r\n     prompt: 'consent'\r\n   });\r\n   res.redirect(url);\r\n"
                },
                {
                    "date": 1748472637714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,10 @@\n     access_type: 'offline',\r\n     scope: [\r\n       'https://www.googleapis.com/auth/gmail.send',\r\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n-      \r\n+      'https://www.googleapis.com/auth/userinfo.email',\r\n+      'https://www.googleapis.com/auth/userinfo.profile'\r\n     ],\r\n     prompt: 'consent'\r\n   });\r\n   res.redirect(url);\r\n"
                },
                {
                    "date": 1748472643349,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,10 @@\n     scope: [\r\n       'https://www.googleapis.com/auth/gmail.send',\r\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n       'https://www.googleapis.com/auth/userinfo.email',\r\n-      'https://www.googleapis.com/auth/userinfo.profile'\r\n+      'https://www.googleapis.com/auth/userinfo.profile',\r\n+      'https://www.googleapis.com/auth/gmail.modify',\r\n     ],\r\n     prompt: 'consent'\r\n   });\r\n   res.redirect(url);\r\n"
                },
                {
                    "date": 1748472649420,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,8 +24,12 @@\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n       'https://www.googleapis.com/auth/userinfo.email',\r\n       'https://www.googleapis.com/auth/userinfo.profile',\r\n       'https://www.googleapis.com/auth/gmail.modify',\r\n+      'https://www.googleapis.com/auth/gmail.labels',\r\n+      'https://www.googleapis.com/auth/gmail.metadata',\r\n+      'https://www.googleapis.com/auth/gmail.compose',\r\n+      'https://www.googleapis.com/auth/gmail.settings.basic',\r\n     ],\r\n     prompt: 'consent'\r\n   });\r\n   res.redirect(url);\r\n"
                },
                {
                    "date": 1748472654904,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,8 +28,12 @@\n       'https://www.googleapis.com/auth/gmail.labels',\r\n       'https://www.googleapis.com/auth/gmail.metadata',\r\n       'https://www.googleapis.com/auth/gmail.compose',\r\n       'https://www.googleapis.com/auth/gmail.settings.basic',\r\n+      'https://www.googleapis.com/auth/gmail.settings.sharing',\r\n+      'https://www.googleapis.com/auth/gmail.settings.readonly',\r\n+      'https://www.googleapis.com/auth/gmail.metadata.readonly',\r\n+      'https://www.googleapis.com/auth/gmail.modify',\r\n     ],\r\n     prompt: 'consent'\r\n   });\r\n   res.redirect(url);\r\n"
                },
                {
                    "date": 1748472663583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n       'https://www.googleapis.com/auth/gmail.settings.basic',\r\n       'https://www.googleapis.com/auth/gmail.settings.sharing',\r\n       'https://www.googleapis.com/auth/gmail.settings.readonly',\r\n       'https://www.googleapis.com/auth/gmail.metadata.readonly',\r\n-      'https://www.googleapis.com/auth/gmail.modify',\r\n+      ',\r\n     ],\r\n     prompt: 'consent'\r\n   });\r\n   res.redirect(url);\r\n"
                },
                {
                    "date": 1748472673644,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,16 +24,10 @@\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n       'https://www.googleapis.com/auth/userinfo.email',\r\n       'https://www.googleapis.com/auth/userinfo.profile',\r\n       'https://www.googleapis.com/auth/gmail.modify',\r\n-      'https://www.googleapis.com/auth/gmail.labels',\r\n-      'https://www.googleapis.com/auth/gmail.metadata',\r\n-      'https://www.googleapis.com/auth/gmail.compose',\r\n-      'https://www.googleapis.com/auth/gmail.settings.basic',\r\n-      'https://www.googleapis.com/auth/gmail.settings.sharing',\r\n-      'https://www.googleapis.com/auth/gmail.settings.readonly',\r\n-      'https://www.googleapis.com/auth/gmail.metadata.readonly',\r\n-      ',\r\n+\r\n+      \r\n     ],\r\n     prompt: 'consent'\r\n   });\r\n   res.redirect(url);\r\n"
                },
                {
                    "date": 1748472681897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,11 +21,10 @@\n     access_type: 'offline',\r\n     scope: [\r\n       'https://www.googleapis.com/auth/gmail.send',\r\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n-      'https://www.googleapis.com/auth/userinfo.email',\r\n-      'https://www.googleapis.com/auth/userinfo.profile',\r\n       'https://www.googleapis.com/auth/gmail.modify',\r\n+      \r\n \r\n       \r\n     ],\r\n     prompt: 'consent'\r\n"
                },
                {
                    "date": 1748472687474,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n     scope: [\r\n       'https://www.googleapis.com/auth/gmail.send',\r\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n       'https://www.googleapis.com/auth/gmail.modify',\r\n-      \r\n+      'h'\r\n \r\n       \r\n     ],\r\n     prompt: 'consent'\r\n"
                },
                {
                    "date": 1748472692983,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n     scope: [\r\n       'https://www.googleapis.com/auth/gmail.send',\r\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n       'https://www.googleapis.com/auth/gmail.modify',\r\n-      'h'\r\n+      'https:'\r\n \r\n       \r\n     ],\r\n     prompt: 'consent'\r\n"
                },
                {
                    "date": 1748472700586,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n     scope: [\r\n       'https://www.googleapis.com/auth/gmail.send',\r\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n       'https://www.googleapis.com/auth/gmail.modify',\r\n-      'https:'\r\n+      'https://mail'\r\n \r\n       \r\n     ],\r\n     prompt: 'consent'\r\n"
                },
                {
                    "date": 1748472706113,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,10 @@\n     scope: [\r\n       'https://www.googleapis.com/auth/gmail.send',\r\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n       'https://www.googleapis.com/auth/gmail.modify',\r\n-      'https://mail'\r\n+      'https://mail.google.com/',\r\n+      'https://www.googleapis.com/auth/userinfo.email'\r\n \r\n       \r\n     ],\r\n     prompt: 'consent'\r\n"
                },
                {
                    "date": 1748472716104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,11 +22,9 @@\n     scope: [\r\n       'https://www.googleapis.com/auth/gmail.send',\r\n       'https://www.googleapis.com/auth/gmail.readonly',\r\n       'https://www.googleapis.com/auth/gmail.modify',\r\n-      'https://mail.google.com/',\r\n-      'https://www.googleapis.com/auth/userinfo.email'\r\n-\r\n+      'https://mail.google.com/'\r\n       \r\n     ],\r\n     prompt: 'consent'\r\n   });\r\n"
                },
                {
                    "date": 1748474344273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,10 +28,239 @@\n     ],\r\n     prompt: 'consent'\r\n   });\r\n   res.redirect(url);\r\n+});require('dotenv').config();\r\n+const express = require('express');\r\n+const { google } = require('googleapis');\r\n+const cors = require('cors');\r\n+\r\n+const app = express();\r\n+app.use(cors());\r\n+app.use(express.json());\r\n+\r\n+const PORT = process.env.PORT || 3000;\r\n+\r\n+const oAuth2Client = new google.auth.OAuth2(\r\n+  process.env.CLIENT_ID,\r\n+  process.env.CLIENT_SECRET,\r\n+  process.env.REDIRECT_URI\r\n+);\r\n+\r\n+// Authentification\r\n+app.get('/auth/google', (req, res) => {\r\n+  const url = oAuth2Client.generateAuthUrl({\r\n+    access_type: 'offline',\r\n+    scope: [\r\n+      'https://www.googleapis.com/auth/gmail.send',\r\n+      'https://www.googleapis.com/auth/gmail.readonly',\r\n+      'https://www.googleapis.com/auth/gmail.modify',\r\n+      'https://mail.google.com/'\r\n+    ],\r\n+    prompt: 'consent'\r\n+  });\r\n+  res.redirect(url);\r\n });\r\n \r\n+app.get('/auth/google/callback', async (req, res) => {\r\n+  try {\r\n+    const { code } = req.query;\r\n+    if (!code) throw new Error('No code received');\r\n+    \r\n+    const { tokens } = await oAuth2Client.getToken(code);\r\n+    res.send(`Authentification réussie!<br>\r\n+      Access Token: ${tokens.access_token}<br>\r\n+      Refresh Token: ${tokens.refresh_token}`);\r\n+  } catch (error) {\r\n+    console.error('Error:', error);\r\n+    res.status(500).send('Erreur d\\'authentification');\r\n+  }\r\n+});\r\n+\r\n+// Gestion des emails\r\n+app.post('/send-email', async (req, res) => {\r\n+  try {\r\n+    const { accessToken, emailData } = req.body;\r\n+    if (!accessToken || !emailData) {\r\n+      return res.status(400).send('Paramètres manquants');\r\n+    }\r\n+\r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+    const message = [\r\n+      `From: ${emailData.from}`,\r\n+      `To: ${emailData.to}`,\r\n+      'Content-Type: text/html; charset=utf-8',\r\n+      `Subject: ${emailData.subject}`,\r\n+      '',\r\n+      emailData.body\r\n+    ].join('\\n');\r\n+\r\n+    const encodedMessage = Buffer.from(message)\r\n+      .toString('base64')\r\n+      .replace(/\\+/g, '-')\r\n+      .replace(/\\//g, '_')\r\n+      .replace(/=+$/, '');\r\n+\r\n+    const response = await gmail.users.messages.send({\r\n+      userId: 'me',\r\n+      requestBody: { raw: encodedMessage }\r\n+    });\r\n+\r\n+    res.json({ success: true, data: response.data });\r\n+  } catch (error) {\r\n+    console.error('Error sending email:', error);\r\n+    res.status(500).json({ \r\n+      success: false, \r\n+      error: error.message,\r\n+      details: error.response?.data\r\n+    });\r\n+  }\r\n+});\r\n+\r\n+// Récupérer les emails envoyés\r\n+app.get('/sent-emails', async (req, res) => {\r\n+  try {\r\n+    const { accessToken, maxResults = 10 } = req.query;\r\n+    if (!accessToken) return res.status(400).send('Access token requis');\r\n+\r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+    const response = await gmail.users.messages.list({\r\n+      userId: 'me',\r\n+      labelIds: ['SENT'],\r\n+      maxResults: parseInt(maxResults)\r\n+    });\r\n+\r\n+    const messages = await Promise.all(\r\n+      response.data.messages.map(async (message) => {\r\n+        const msg = await gmail.users.messages.get({\r\n+          userId: 'me',\r\n+          id: message.id,\r\n+          format: 'full'\r\n+        });\r\n+        return {\r\n+          id: msg.data.id,\r\n+          snippet: msg.data.snippet,\r\n+          payload: msg.data.payload,\r\n+          internalDate: msg.data.internalDate,\r\n+          labelIds: msg.data.labelIds,\r\n+          // Vérifier si l'email a été lu\r\n+          isRead: !msg.data.labelIds.includes('UNREAD')\r\n+        };\r\n+      })\r\n+    );\r\n+\r\n+    res.json({ success: true, data: messages });\r\n+  } catch (error) {\r\n+    console.error('Error retrieving sent emails:', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+// Récupérer les brouillons\r\n+app.get('/drafts', async (req, res) => {\r\n+  try {\r\n+    const { accessToken, maxResults = 10 } = req.query;\r\n+    if (!accessToken) return res.status(400).send('Access token requis');\r\n+\r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+    const response = await gmail.users.drafts.list({\r\n+      userId: 'me',\r\n+      maxResults: parseInt(maxResults)\r\n+    });\r\n+\r\n+    const drafts = await Promise.all(\r\n+      response.data.drafts.map(async (draft) => {\r\n+        const draftDetails = await gmail.users.drafts.get({\r\n+          userId: 'me',\r\n+          id: draft.id,\r\n+          format: 'full'\r\n+        });\r\n+        return {\r\n+          id: draft.id,\r\n+          message: draftDetails.data.message\r\n+        };\r\n+      })\r\n+    );\r\n+\r\n+    res.json({ success: true, data: drafts });\r\n+  } catch (error) {\r\n+    console.error('Error retrieving drafts:', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+// Vérifier si un email a été lu\r\n+app.get('/check-email-read/:emailId', async (req, res) => {\r\n+  try {\r\n+    const { accessToken } = req.query;\r\n+    const { emailId } = req.params;\r\n+    if (!accessToken || !emailId) {\r\n+      return res.status(400).send('Paramètres manquants');\r\n+    }\r\n+\r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+    const response = await gmail.users.messages.get({\r\n+      userId: 'me',\r\n+      id: emailId,\r\n+      format: 'metadata',\r\n+      metadataHeaders: ['From', 'To', 'Subject']\r\n+    });\r\n+\r\n+    const isRead = !response.data.labelIds.includes('UNREAD');\r\n+    res.json({ \r\n+      success: true, \r\n+      data: {\r\n+        isRead,\r\n+        labels: response.data.labelIds,\r\n+        snippet: response.data.snippet\r\n+      }\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error checking email status:', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+// Rafraîchir le token\r\n+app.post('/refresh-token', async (req, res) => {\r\n+  try {\r\n+    const { refreshToken } = req.body;\r\n+    if (!refreshToken) return res.status(400).send('Refresh token requis');\r\n+\r\n+    oAuth2Client.setCredentials({ refresh_token: refreshToken });\r\n+    const { credentials } = await oAuth2Client.refreshAccessToken();\r\n+    \r\n+    res.json({ \r\n+      success: true, \r\n+      access_token: credentials.access_token,\r\n+      expiry_date: credentials.expiry_date\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error refreshing token:', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n+\r\n+app.listen(PORT, () => {\r\n+  console.log(`Server running on port ${PORT}`);\r\n+  console.log('Endpoints disponibles:');\r\n+  console.log('GET  /auth/google');\r\n+  console.log('GET  /auth/google/callback');\r\n+  console.log('POST /send-email');\r\n+  console.log('GET  /sent-emails');\r\n+  console.log('GET  /drafts');\r\n+  console.log('GET  /check-email-read/:emailId');\r\n+  console.log('POST /refresh-token');\r\n+});\r\n+\r\n // Endpoint de callback\r\n app.get('/auth/google/callback', async (req, res) => {\r\n   try {\r\n     const { code } = req.query;\r\n"
                },
                {
                    "date": 1748475527602,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,42 +8,11 @@\n app.use(express.json());\r\n \r\n const PORT = process.env.PORT || 3000;\r\n \r\n-\r\n const oAuth2Client = new google.auth.OAuth2(\r\n   process.env.CLIENT_ID,\r\n   process.env.CLIENT_SECRET,\r\n-  process.env.REDIRECT_URI);\r\n-\r\n-// Endpoint d'initiation\r\n-app.get('/auth/google', (req, res) => {\r\n-  const url = oAuth2Client.generateAuthUrl({\r\n-    access_type: 'offline',\r\n-    scope: [\r\n-      'https://www.googleapis.com/auth/gmail.send',\r\n-      'https://www.googleapis.com/auth/gmail.readonly',\r\n-      'https://www.googleapis.com/auth/gmail.modify',\r\n-      'https://mail.google.com/'\r\n-      \r\n-    ],\r\n-    prompt: 'consent'\r\n-  });\r\n-  res.redirect(url);\r\n-});require('dotenv').config();\r\n-const express = require('express');\r\n-const { google } = require('googleapis');\r\n-const cors = require('cors');\r\n-\r\n-const app = express();\r\n-app.use(cors());\r\n-app.use(express.json());\r\n-\r\n-const PORT = process.env.PORT || 3000;\r\n-\r\n-const oAuth2Client = new google.auth.OAuth2(\r\n-  process.env.CLIENT_ID,\r\n-  process.env.CLIENT_SECRET,\r\n   process.env.REDIRECT_URI\r\n );\r\n \r\n // Authentification\r\n@@ -192,9 +161,55 @@\n     console.error('Error retrieving drafts:', error);\r\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n+// Récupérer les emails entrants avec statut de lecture\r\n+app.get('/inbox-emails', async (req, res) => {\r\n+  try {\r\n+    const { accessToken, maxResults = 20 } = req.query;\r\n+    if (!accessToken) return res.status(400).json({ error: 'Access token requis' });\r\n \r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+    // Récupère les emails de la boîte de réception\r\n+    const response = await gmail.users.messages.list({\r\n+      userId: 'me',\r\n+      labelIds: ['INBOX'],\r\n+      maxResults: parseInt(maxResults)\r\n+    });\r\n+\r\n+    // Traitement détaillé de chaque email\r\n+    const emails = await Promise.all(\r\n+      response.data.messages.map(async (message) => {\r\n+        const msg = await gmail.users.messages.get({\r\n+          userId: 'me',\r\n+          id: message.id,\r\n+          format: 'metadata',\r\n+          metadataHeaders: ['From', 'To', 'Subject', 'Date']\r\n+        });\r\n+\r\n+        return {\r\n+          id: msg.data.id,\r\n+          from: msg.data.payload.headers.find(h => h.name === 'From').value,\r\n+          subject: msg.data.payload.headers.find(h => h.name === 'Subject').value,\r\n+          date: msg.data.payload.headers.find(h => h.name === 'Date').value,\r\n+          isRead: !msg.data.labelIds.includes('UNREAD'), // Statut de lecture\r\n+          labels: msg.data.labelIds\r\n+        };\r\n+      })\r\n+    );\r\n+\r\n+    res.json({ success: true, data: emails });\r\n+  } catch (error) {\r\n+    console.error('Error fetching inbox:', error);\r\n+    res.status(500).json({ \r\n+      success: false, \r\n+      error: error.message,\r\n+      details: error.response?.data\r\n+    });\r\n+  }\r\n+});\r\n // Vérifier si un email a été lu\r\n app.get('/check-email-read/:emailId', async (req, res) => {\r\n   try {\r\n     const { accessToken } = req.query;\r\n@@ -257,124 +272,5 @@\n   console.log('GET  /sent-emails');\r\n   console.log('GET  /drafts');\r\n   console.log('GET  /check-email-read/:emailId');\r\n   console.log('POST /refresh-token');\r\n-});\r\n-\r\n-// Endpoint de callback\r\n-app.get('/auth/google/callback', async (req, res) => {\r\n-  try {\r\n-    const { code } = req.query;\r\n-    if (!code) throw new Error('No code received');\r\n-    \r\n-    const { tokens } = await oAuth2Client.getToken(code);\r\n-    console.log('Tokens received:', tokens);\r\n-    \r\n-    res.send(`Authentification réussie !<br>\r\n-      Access Token: ${tokens.access_token}<br>\r\n-      Refresh Token: ${tokens.refresh_token}`);\r\n-  } catch (error) {\r\n-    console.error('Error:', error);\r\n-    res.status(500).send('Erreur d\\'authentification');\r\n-  }\r\n-});\r\n-\r\n-app.listen(PORT, () => console.log('Server running on http://localhost:3000'));\r\n-\r\n-app.post('/send-email', async (req, res) => {\r\n-  const { accessToken, emailData } = req.body;\r\n-  \r\n-  if (!accessToken || !emailData) {\r\n-    return res.status(400).send('Missing required parameters');\r\n-  }\r\n-\r\n-  try {\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    const message = [\r\n-      `From: ${emailData.from}`,\r\n-      `To: ${emailData.to}`,\r\n-      'Content-Type: text/html; charset=utf-8',\r\n-      'MIME-Version: 1.0',\r\n-      `Subject: ${emailData.subject}`,\r\n-      '',\r\n-      emailData.body\r\n-    ].join('\\n');\r\n-\r\n-    const encodedMessage = Buffer.from(message)\r\n-      .toString('base64')\r\n-      .replace(/\\+/g, '-')\r\n-      .replace(/\\//g, '_')\r\n-      .replace(/=+$/, '');\r\n-\r\n-    const response = await gmail.users.messages.send({\r\n-      userId: 'me',\r\n-      requestBody: {\r\n-        raw: encodedMessage\r\n-      }\r\n-    });\r\n-\r\n-    res.json({ success: true, data: response.data });\r\n-  } catch (error) {\r\n-    console.error('Error sending email', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n-  }\r\n-});\r\n-app.get('/get-emails', async (req, res) => {\r\n-  const { accessToken, maxResults = 10 } = req.query;\r\n-  \r\n-  if (!accessToken) {\r\n-    return res.status(400).send('Access token is required');\r\n-  }\r\n-\r\n-  try {\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    const response = await gmail.users.messages.list({\r\n-      userId: 'me',\r\n-      maxResults: parseInt(maxResults)\r\n-    });\r\n-\r\n-    const messages = response.data.messages || [];\r\n-    const emails = [];\r\n-\r\n-    for (const message of messages) {\r\n-      const email = await gmail.users.messages.get({\r\n-        userId: 'me',\r\n-        id: message.id,\r\n-        format: 'full'\r\n-      });\r\n-      emails.push(email.data);\r\n-    }\r\n-\r\n-    res.json({ success: true, data: emails });\r\n-  } catch (error) {\r\n-    console.error('Error retrieving emails', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n-  }\r\n-});\r\n-app.post('/refresh-token', async (req, res) => {\r\n-  const { refreshToken } = req.body;\r\n-  \r\n-  if (!refreshToken) {\r\n-    return res.status(400).send('Refresh token is required');\r\n-  }\r\n-\r\n-  try {\r\n-    oAuth2Client.setCredentials({ refresh_token: refreshToken });\r\n-    const { credentials } = await oAuth2Client.refreshAccessToken();\r\n-    \r\n-    res.json({ \r\n-      success: true, \r\n-      access_token: credentials.access_token,\r\n-      expiry_date: credentials.expiry_date\r\n-    });\r\n-  } catch (error) {\r\n-    console.error('Error refreshing token', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n-  }\r\n-});\r\n-app.listen(PORT, () => {\r\n-  console.log(`Server running on port ${PORT}`);\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748475645269,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,8 +208,9 @@\n       details: error.response?.data\r\n     });\r\n   }\r\n });\r\n+//marquer un email non \r\n // Vérifier si un email a été lu\r\n app.get('/check-email-read/:emailId', async (req, res) => {\r\n   try {\r\n     const { accessToken } = req.query;\r\n"
                },
                {
                    "date": 1748475650630,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -208,9 +208,33 @@\n       details: error.response?.data\r\n     });\r\n   }\r\n });\r\n-//marquer un email non \r\n+//marquer un email comme lu\r\n+app.post('/mark-as-read', async (req, res) => {\r\n+  try {\r\n+    const { accessToken, emailId } = req.body;\r\n+    if (!accessToken || !emailId) {\r\n+      return res.status(400).json({ error: 'Paramètres manquants' });\r\n+    }\r\n+\r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+    await gmail.users.messages.modify({\r\n+      userId: 'me',\r\n+      id: emailId,\r\n+      requestBody: {\r\n+        removeLabelIds: ['UNREAD']\r\n+      }\r\n+    });\r\n+\r\n+    res.json({ success: true });\r\n+  } catch (error) {\r\n+    console.error('Error marking as read:', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n // Vérifier si un email a été lu\r\n app.get('/check-email-read/:emailId', async (req, res) => {\r\n   try {\r\n     const { accessToken } = req.query;\r\n"
                },
                {
                    "date": 1748475927233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -161,8 +161,36 @@\n     console.error('Error retrieving drafts:', error);\r\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n+// Supprimer un brouillon spécifique\r\n+app.delete('/drafts/:draftId', async (req, res) => {\r\n+  try {\r\n+    const { accessToken } = req.query;\r\n+    const { draftId } = req.params;\r\n+    \r\n+    if (!accessToken || !draftId) {\r\n+      return res.status(400).json({ error: 'Paramètres manquants' });\r\n+    }\r\n+\r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+    await gmail.users.drafts.delete({\r\n+      userId: 'me',\r\n+      id: draftId\r\n+    });\r\n+\r\n+    res.json({ success: true, message: 'Brouillon supprimé avec succès' });\r\n+  } catch (error) {\r\n+    console.error('Error deleting draft:', error);\r\n+    res.status(500).json({ \r\n+      success: false, \r\n+      error: error.message,\r\n+      details: error.response?.data\r\n+    });\r\n+  }\r\n+});\r\n // Récupérer les emails entrants avec statut de lecture\r\n app.get('/inbox-emails', async (req, res) => {\r\n   try {\r\n     const { accessToken, maxResults = 20 } = req.query;\r\n"
                },
                {
                    "date": 1748475954805,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -126,9 +126,48 @@\n     console.error('Error retrieving sent emails:', error);\r\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n+// Supprimer un email spécifique\r\n+app.delete('/emails/:emailId', async (req, res) => {\r\n+  try {\r\n+    const { accessToken, permanent = false } = req.query;\r\n+    const { emailId } = req.params;\r\n+    \r\n+    if (!accessToken || !emailId) {\r\n+      return res.status(400).json({ error: 'Paramètres manquants' });\r\n+    }\r\n \r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+    if (permanent === 'true') {\r\n+      // Suppression définitive (corbeille bypassée)\r\n+      await gmail.users.messages.delete({\r\n+        userId: 'me',\r\n+        id: emailId\r\n+      });\r\n+    } else {\r\n+      // Déplacement vers la corbeille\r\n+      await gmail.users.messages.trash({\r\n+        userId: 'me',\r\n+        id: emailId\r\n+      });\r\n+    }\r\n+\r\n+    res.json({ \r\n+      success: true, \r\n+      message: permanent ? 'Email supprimé définitivement' : 'Email déplacé vers la corbeille'\r\n+    });\r\n+  } catch (error) {\r\n+    console.error('Error deleting email:', error);\r\n+    res.status(500).json({ \r\n+      success: false, \r\n+      error: error.message,\r\n+      details: error.response?.data\r\n+    });\r\n+  }\r\n+});\r\n // Récupérer les brouillons\r\n app.get('/drafts', async (req, res) => {\r\n   try {\r\n     const { accessToken, maxResults = 10 } = req.query;\r\n"
                },
                {
                    "date": 1748476065331,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -333,8 +333,9 @@\n     console.error('Error checking email status:', error);\r\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n+//Restaurer un email depuis la corbeille\r\n \r\n // Rafraîchir le token\r\n app.post('/refresh-token', async (req, res) => {\r\n   try {\r\n"
                },
                {
                    "date": 1748476084429,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -228,8 +228,9 @@\n       details: error.response?.data\r\n     });\r\n   }\r\n });\r\n+\r\n // Récupérer les emails entrants avec statut de lecture\r\n app.get('/inbox-emails', async (req, res) => {\r\n   try {\r\n     const { accessToken, maxResults = 20 } = req.query;\r\n@@ -333,9 +334,8 @@\n     console.error('Error checking email status:', error);\r\n     res.status(500).json({ success: false, error: error.message });\r\n   }\r\n });\r\n-//Restaurer un email depuis la corbeille\r\n \r\n // Rafraîchir le token\r\n app.post('/refresh-token', async (req, res) => {\r\n   try {\r\n"
                },
                {
                    "date": 1748476090556,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -228,9 +228,28 @@\n       details: error.response?.data\r\n     });\r\n   }\r\n });\r\n+//Restaurer un email depuis la corbeille\r\n+app.post('/emails/:emailId/restore', async (req, res) => {\r\n+  try {\r\n+    const { accessToken } = req.query;\r\n+    const { emailId } = req.params;\r\n+    \r\n+    oAuth2Client.setCredentials({ access_token: accessToken });\r\n+    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n \r\n+    await gmail.users.messages.untrash({\r\n+      userId: 'me',\r\n+      id: emailId\r\n+    });\r\n+\r\n+    res.json({ success: true, message: 'Email restauré depuis la corbeille' });\r\n+  } catch (error) {\r\n+    console.error('Error restoring email:', error);\r\n+    res.status(500).json({ success: false, error: error.message });\r\n+  }\r\n+});\r\n // Récupérer les emails entrants avec statut de lecture\r\n app.get('/inbox-emails', async (req, res) => {\r\n   try {\r\n     const { accessToken, maxResults = 20 } = req.query;\r\n"
                },
                {
                    "date": 1748478630583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,381 +1,9 @@\n require('dotenv').config();\r\n-const express = require('express');\r\n-const { google } = require('googleapis');\r\n-const cors = require('cors');\r\n+const app = require('./app');\r\n \r\n-const app = express();\r\n-app.use(cors());\r\n-app.use(express.json());\r\n-\r\n const PORT = process.env.PORT || 3000;\r\n \r\n-const oAuth2Client = new google.auth.OAuth2(\r\n-  process.env.CLIENT_ID,\r\n-  process.env.CLIENT_SECRET,\r\n-  process.env.REDIRECT_URI\r\n-);\r\n-\r\n-// Authentification\r\n-app.get('/auth/google', (req, res) => {\r\n-  const url = oAuth2Client.generateAuthUrl({\r\n-    access_type: 'offline',\r\n-    scope: [\r\n-      'https://www.googleapis.com/auth/gmail.send',\r\n-      'https://www.googleapis.com/auth/gmail.readonly',\r\n-      'https://www.googleapis.com/auth/gmail.modify',\r\n-      'https://mail.google.com/'\r\n-    ],\r\n-    prompt: 'consent'\r\n-  });\r\n-  res.redirect(url);\r\n-});\r\n-\r\n-app.get('/auth/google/callback', async (req, res) => {\r\n-  try {\r\n-    const { code } = req.query;\r\n-    if (!code) throw new Error('No code received');\r\n-    \r\n-    const { tokens } = await oAuth2Client.getToken(code);\r\n-    res.send(`Authentification réussie!<br>\r\n-      Access Token: ${tokens.access_token}<br>\r\n-      Refresh Token: ${tokens.refresh_token}`);\r\n-  } catch (error) {\r\n-    console.error('Error:', error);\r\n-    res.status(500).send('Erreur d\\'authentification');\r\n-  }\r\n-});\r\n-\r\n-// Gestion des emails\r\n-app.post('/send-email', async (req, res) => {\r\n-  try {\r\n-    const { accessToken, emailData } = req.body;\r\n-    if (!accessToken || !emailData) {\r\n-      return res.status(400).send('Paramètres manquants');\r\n-    }\r\n-\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    const message = [\r\n-      `From: ${emailData.from}`,\r\n-      `To: ${emailData.to}`,\r\n-      'Content-Type: text/html; charset=utf-8',\r\n-      `Subject: ${emailData.subject}`,\r\n-      '',\r\n-      emailData.body\r\n-    ].join('\\n');\r\n-\r\n-    const encodedMessage = Buffer.from(message)\r\n-      .toString('base64')\r\n-      .replace(/\\+/g, '-')\r\n-      .replace(/\\//g, '_')\r\n-      .replace(/=+$/, '');\r\n-\r\n-    const response = await gmail.users.messages.send({\r\n-      userId: 'me',\r\n-      requestBody: { raw: encodedMessage }\r\n-    });\r\n-\r\n-    res.json({ success: true, data: response.data });\r\n-  } catch (error) {\r\n-    console.error('Error sending email:', error);\r\n-    res.status(500).json({ \r\n-      success: false, \r\n-      error: error.message,\r\n-      details: error.response?.data\r\n-    });\r\n-  }\r\n-});\r\n-\r\n-// Récupérer les emails envoyés\r\n-app.get('/sent-emails', async (req, res) => {\r\n-  try {\r\n-    const { accessToken, maxResults = 10 } = req.query;\r\n-    if (!accessToken) return res.status(400).send('Access token requis');\r\n-\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    const response = await gmail.users.messages.list({\r\n-      userId: 'me',\r\n-      labelIds: ['SENT'],\r\n-      maxResults: parseInt(maxResults)\r\n-    });\r\n-\r\n-    const messages = await Promise.all(\r\n-      response.data.messages.map(async (message) => {\r\n-        const msg = await gmail.users.messages.get({\r\n-          userId: 'me',\r\n-          id: message.id,\r\n-          format: 'full'\r\n-        });\r\n-        return {\r\n-          id: msg.data.id,\r\n-          snippet: msg.data.snippet,\r\n-          payload: msg.data.payload,\r\n-          internalDate: msg.data.internalDate,\r\n-          labelIds: msg.data.labelIds,\r\n-          // Vérifier si l'email a été lu\r\n-          isRead: !msg.data.labelIds.includes('UNREAD')\r\n-        };\r\n-      })\r\n-    );\r\n-\r\n-    res.json({ success: true, data: messages });\r\n-  } catch (error) {\r\n-    console.error('Error retrieving sent emails:', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n-  }\r\n-});\r\n-// Supprimer un email spécifique\r\n-app.delete('/emails/:emailId', async (req, res) => {\r\n-  try {\r\n-    const { accessToken, permanent = false } = req.query;\r\n-    const { emailId } = req.params;\r\n-    \r\n-    if (!accessToken || !emailId) {\r\n-      return res.status(400).json({ error: 'Paramètres manquants' });\r\n-    }\r\n-\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    if (permanent === 'true') {\r\n-      // Suppression définitive (corbeille bypassée)\r\n-      await gmail.users.messages.delete({\r\n-        userId: 'me',\r\n-        id: emailId\r\n-      });\r\n-    } else {\r\n-      // Déplacement vers la corbeille\r\n-      await gmail.users.messages.trash({\r\n-        userId: 'me',\r\n-        id: emailId\r\n-      });\r\n-    }\r\n-\r\n-    res.json({ \r\n-      success: true, \r\n-      message: permanent ? 'Email supprimé définitivement' : 'Email déplacé vers la corbeille'\r\n-    });\r\n-  } catch (error) {\r\n-    console.error('Error deleting email:', error);\r\n-    res.status(500).json({ \r\n-      success: false, \r\n-      error: error.message,\r\n-      details: error.response?.data\r\n-    });\r\n-  }\r\n-});\r\n-// Récupérer les brouillons\r\n-app.get('/drafts', async (req, res) => {\r\n-  try {\r\n-    const { accessToken, maxResults = 10 } = req.query;\r\n-    if (!accessToken) return res.status(400).send('Access token requis');\r\n-\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    const response = await gmail.users.drafts.list({\r\n-      userId: 'me',\r\n-      maxResults: parseInt(maxResults)\r\n-    });\r\n-\r\n-    const drafts = await Promise.all(\r\n-      response.data.drafts.map(async (draft) => {\r\n-        const draftDetails = await gmail.users.drafts.get({\r\n-          userId: 'me',\r\n-          id: draft.id,\r\n-          format: 'full'\r\n-        });\r\n-        return {\r\n-          id: draft.id,\r\n-          message: draftDetails.data.message\r\n-        };\r\n-      })\r\n-    );\r\n-\r\n-    res.json({ success: true, data: drafts });\r\n-  } catch (error) {\r\n-    console.error('Error retrieving drafts:', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n-  }\r\n-});\r\n-// Supprimer un brouillon spécifique\r\n-app.delete('/drafts/:draftId', async (req, res) => {\r\n-  try {\r\n-    const { accessToken } = req.query;\r\n-    const { draftId } = req.params;\r\n-    \r\n-    if (!accessToken || !draftId) {\r\n-      return res.status(400).json({ error: 'Paramètres manquants' });\r\n-    }\r\n-\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    await gmail.users.drafts.delete({\r\n-      userId: 'me',\r\n-      id: draftId\r\n-    });\r\n-\r\n-    res.json({ success: true, message: 'Brouillon supprimé avec succès' });\r\n-  } catch (error) {\r\n-    console.error('Error deleting draft:', error);\r\n-    res.status(500).json({ \r\n-      success: false, \r\n-      error: error.message,\r\n-      details: error.response?.data\r\n-    });\r\n-  }\r\n-});\r\n-//Restaurer un email depuis la corbeille\r\n-app.post('/emails/:emailId/restore', async (req, res) => {\r\n-  try {\r\n-    const { accessToken } = req.query;\r\n-    const { emailId } = req.params;\r\n-    \r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    await gmail.users.messages.untrash({\r\n-      userId: 'me',\r\n-      id: emailId\r\n-    });\r\n-\r\n-    res.json({ success: true, message: 'Email restauré depuis la corbeille' });\r\n-  } catch (error) {\r\n-    console.error('Error restoring email:', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n-  }\r\n-});\r\n-// Récupérer les emails entrants avec statut de lecture\r\n-app.get('/inbox-emails', async (req, res) => {\r\n-  try {\r\n-    const { accessToken, maxResults = 20 } = req.query;\r\n-    if (!accessToken) return res.status(400).json({ error: 'Access token requis' });\r\n-\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    // Récupère les emails de la boîte de réception\r\n-    const response = await gmail.users.messages.list({\r\n-      userId: 'me',\r\n-      labelIds: ['INBOX'],\r\n-      maxResults: parseInt(maxResults)\r\n-    });\r\n-\r\n-    // Traitement détaillé de chaque email\r\n-    const emails = await Promise.all(\r\n-      response.data.messages.map(async (message) => {\r\n-        const msg = await gmail.users.messages.get({\r\n-          userId: 'me',\r\n-          id: message.id,\r\n-          format: 'metadata',\r\n-          metadataHeaders: ['From', 'To', 'Subject', 'Date']\r\n-        });\r\n-\r\n-        return {\r\n-          id: msg.data.id,\r\n-          from: msg.data.payload.headers.find(h => h.name === 'From').value,\r\n-          subject: msg.data.payload.headers.find(h => h.name === 'Subject').value,\r\n-          date: msg.data.payload.headers.find(h => h.name === 'Date').value,\r\n-          isRead: !msg.data.labelIds.includes('UNREAD'), // Statut de lecture\r\n-          labels: msg.data.labelIds\r\n-        };\r\n-      })\r\n-    );\r\n-\r\n-    res.json({ success: true, data: emails });\r\n-  } catch (error) {\r\n-    console.error('Error fetching inbox:', error);\r\n-    res.status(500).json({ \r\n-      success: false, \r\n-      error: error.message,\r\n-      details: error.response?.data\r\n-    });\r\n-  }\r\n-});\r\n-//marquer un email comme lu\r\n-app.post('/mark-as-read', async (req, res) => {\r\n-  try {\r\n-    const { accessToken, emailId } = req.body;\r\n-    if (!accessToken || !emailId) {\r\n-      return res.status(400).json({ error: 'Paramètres manquants' });\r\n-    }\r\n-\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    await gmail.users.messages.modify({\r\n-      userId: 'me',\r\n-      id: emailId,\r\n-      requestBody: {\r\n-        removeLabelIds: ['UNREAD']\r\n-      }\r\n-    });\r\n-\r\n-    res.json({ success: true });\r\n-  } catch (error) {\r\n-    console.error('Error marking as read:', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n-  }\r\n-});\r\n-// Vérifier si un email a été lu\r\n-app.get('/check-email-read/:emailId', async (req, res) => {\r\n-  try {\r\n-    const { accessToken } = req.query;\r\n-    const { emailId } = req.params;\r\n-    if (!accessToken || !emailId) {\r\n-      return res.status(400).send('Paramètres manquants');\r\n-    }\r\n-\r\n-    oAuth2Client.setCredentials({ access_token: accessToken });\r\n-    const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-    const response = await gmail.users.messages.get({\r\n-      userId: 'me',\r\n-      id: emailId,\r\n-      format: 'metadata',\r\n-      metadataHeaders: ['From', 'To', 'Subject']\r\n-    });\r\n-\r\n-    const isRead = !response.data.labelIds.includes('UNREAD');\r\n-    res.json({ \r\n-      success: true, \r\n-      data: {\r\n-        isRead,\r\n-        labels: response.data.labelIds,\r\n-        snippet: response.data.snippet\r\n-      }\r\n-    });\r\n-  } catch (error) {\r\n-    console.error('Error checking email status:', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n-  }\r\n-});\r\n-\r\n-// Rafraîchir le token\r\n-app.post('/refresh-token', async (req, res) => {\r\n-  try {\r\n-    const { refreshToken } = req.body;\r\n-    if (!refreshToken) return res.status(400).send('Refresh token requis');\r\n-\r\n-    oAuth2Client.setCredentials({ refresh_token: refreshToken });\r\n-    const { credentials } = await oAuth2Client.refreshAccessToken();\r\n-    \r\n-    res.json({ \r\n-      success: true, \r\n-      access_token: credentials.access_token,\r\n-      expiry_date: credentials.expiry_date\r\n-    });\r\n-  } catch (error) {\r\n-    console.error('Error refreshing token:', error);\r\n-    res.status(500).json({ success: false, error: error.message });\r\n-  }\r\n-});\r\n-\r\n app.listen(PORT, () => {\r\n   console.log(`Server running on port ${PORT}`);\r\n   console.log('Endpoints disponibles:');\r\n   console.log('GET  /auth/google');\r\n"
                },
                {
                    "date": 1748479579960,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,16 +1,38 @@\n require('dotenv').config();\r\n-const app = require('./app');\r\n+const express = require('express');\r\n+const cors = require('cors');\r\n \r\n+// Import des routes\r\n+const authRoutes = require('./src/routes/auth.routes');\r\n+const emailRoutes = require('./src/routes/email.routes');\r\n+const draftRoutes = require('./src/routes/draft.routes');\r\n+const tokenRoutes = require('./src/routes/token.routes');\r\n+\r\n+const app = express();\r\n+app.use(cors());\r\n+app.use(express.json());\r\n+\r\n const PORT = process.env.PORT || 3000;\r\n \r\n+// Routes\r\n+app.use('/auth', authRoutes);\r\n+app.use('/emails', emailRoutes);\r\n+app.use('/drafts', draftRoutes);\r\n+app.use('/token', tokenRoutes);\r\n+\r\n+// Route de test\r\n+app.get('/', (req, res) => {\r\n+  res.send('API Gmail Manager is running');\r\n+});\r\n+\r\n app.listen(PORT, () => {\r\n   console.log(`Server running on port ${PORT}`);\r\n   console.log('Endpoints disponibles:');\r\n   console.log('GET  /auth/google');\r\n   console.log('GET  /auth/google/callback');\r\n-  console.log('POST /send-email');\r\n-  console.log('GET  /sent-emails');\r\n+  console.log('POST /emails/send');\r\n+  console.log('GET  /emails/sent');\r\n+  console.log('GET  /emails/inbox');\r\n   console.log('GET  /drafts');\r\n-  console.log('GET  /check-email-read/:emailId');\r\n-  console.log('POST /refresh-token');\r\n+  console.log('POST /token/refresh');\r\n });\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748481116987,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,9 +2,9 @@\n const express = require('express');\r\n const cors = require('cors');\r\n \r\n // Import des routes\r\n-const authRoutes = require('./src/routes/auth.routes');\r\n+const authRoutes = require('./src/routes/authRoutes');\r\n const emailRoutes = require('./src/routes/email.routes');\r\n const draftRoutes = require('./src/routes/draft.routes');\r\n const tokenRoutes = require('./src/routes/token.routes');\r\n \r\n"
                },
                {
                    "date": 1748481135317,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n \r\n // Import des routes\r\n const authRoutes = require('./src/routes/authRoutes');\r\n const emailRoutes = require('./src/routes/email.routes');\r\n-const draftRoutes = require('./src/routes/draft.routes');\r\n+const draftRoutes = require('./src/routes/draftRoutes');\r\n const tokenRoutes = require('./src/routes/token.routes');\r\n \r\n const app = express();\r\n app.use(cors());\r\n"
                },
                {
                    "date": 1748481154692,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n const cors = require('cors');\r\n \r\n // Import des routes\r\n const authRoutes = require('./src/routes/authRoutes');\r\n-const emailRoutes = require('./src/routes/email.routes');\r\n+const emailRoutes = require('./src/routes/emailRoutes.js');\r\n const draftRoutes = require('./src/routes/draftRoutes');\r\n const tokenRoutes = require('./src/routes/token.routes');\r\n \r\n const app = express();\r\n"
                },
                {
                    "date": 1748481206359,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,38 +1,49 @@\n-require('dotenv').config();\r\n-const express = require('express');\r\n-const cors = require('cors');\r\n+require(\"dotenv\").config();\r\n+const express = require(\"express\");\r\n+const cors = require(\"cors\");\r\n \r\n-// Import des routes\r\n-const authRoutes = require('./src/routes/authRoutes');\r\n-const emailRoutes = require('./src/routes/emailRoutes.js');\r\n-const draftRoutes = require('./src/routes/draftRoutes');\r\n-const tokenRoutes = require('./src/routes/token.routes');\r\n+// Importer les routes\r\n+const authRoutes = require(\"./src/routes/authRoutes\");\r\n+const emailRoutes = require(\"./src/routes/emailRoutes\");\r\n+const draftRoutes = require(\"./src/routes/draftRoutes\");\r\n \r\n const app = express();\r\n-app.use(cors());\r\n-app.use(express.json());\r\n \r\n+// Middlewares\r\n+app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n+app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n+\r\n const PORT = process.env.PORT || 3000;\r\n \r\n-// Routes\r\n-app.use('/auth', authRoutes);\r\n-app.use('/emails', emailRoutes);\r\n-app.use('/drafts', draftRoutes);\r\n-app.use('/token', tokenRoutes);\r\n+// Utiliser les routes\r\n+app.use(\"/auth\", authRoutes);\r\n+app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n+app.use(\"/drafts\", draftRoutes); // Préfixe pour toutes les routes liées aux brouillons\r\n \r\n-// Route de test\r\n\\ No newline at end of file\n-app.get('/', (req, res) => {\r\n-  res.send('API Gmail Manager is running');\r\n+// Route de base pour vérifier si le serveur fonctionne\r\n+app.get(\"/\", (req, res) => {\r\n+  res.send(\"Serveur API Gmail fonctionnel.\");\r\n });\r\n \r\n+// Gestionnaire d'erreurs global (optionnel mais recommandé)\r\n+app.use((err, req, res, next) => {\r\n+  console.error(\"Erreur non gérée:\", err.stack);\r\n+  res.status(500).json({ success: false, error: \"Erreur interne du serveur.\" });\r\n+});\r\n+\r\n app.listen(PORT, () => {\r\n-  console.log(`Server running on port ${PORT}`);\r\n-  console.log('Endpoints disponibles:');\r\n-  console.log('GET  /auth/google');\r\n-  console.log('GET  /auth/google/callback');\r\n-  console.log('POST /emails/send');\r\n-  console.log('GET  /emails/sent');\r\n-  console.log('GET  /emails/inbox');\r\n-  console.log('GET  /drafts');\r\n-  console.log('POST /token/refresh');\r\n-});\n+  console.log(`Serveur démarré sur le port ${PORT}`);\r\n+  console.log(\"Endpoints disponibles:\");\r\n+  console.log(`GET  /auth/google`);\r\n+  console.log(`GET  /auth/google/callback`);\r\n+  console.log(`POST /auth/refresh-token`);\r\n+  console.log(`POST /emails/send`);\r\n+  console.log(`GET  /emails/sent`);\r\n+  console.log(`GET  /emails/inbox`);\r\n+  console.log(`POST /emails/mark-as-read`);\r\n+  console.log(`GET  /emails/check-read/:emailId`);\r\n+  console.log(`DELETE /emails/:emailId`);\r\n+  console.log(`POST /emails/:emailId/restore`);\r\n+  console.log(`GET  /drafts`);\r\n+  console.log(`DELETE /drafts/:draftId`);\r\n+});\r\n"
                },
                {
                    "date": 1748541427868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n // Middlewares\r\n app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n-const PORT = process.env.PORT || 3000;\r\n+const PORT = process.env.SERVER_PORT=8079 || 3000;\r\n \r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n"
                },
                {
                    "date": 1748541434383,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n // Middlewares\r\n app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n-const PORT = process.env.SERVER_PORT=8079 || 3000;\r\n+const PORT = process.env.SERVER_PORT || =8079;\r\n \r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n"
                },
                {
                    "date": 1748543122555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n // Middlewares\r\n app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n-const PORT = process.env.SERVER_PORT || =8079;\r\n+const PORT = process.env.PORT || 8079;\r\n \r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n"
                },
                {
                    "date": 1748544522129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n require(\"dotenv\").config();\r\n const express = require(\"express\");\r\n const cors = require(\"cors\");\r\n-\r\n+const Eureka = require('eureka-js-client').Eureka;\r\n // Importer les routes\r\n const authRoutes = require(\"./src/routes/authRoutes\");\r\n const emailRoutes = require(\"./src/routes/emailRoutes\");\r\n const draftRoutes = require(\"./src/routes/draftRoutes\");\r\n"
                },
                {
                    "date": 1748544534253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n require(\"dotenv\").config();\r\n const express = require(\"express\");\r\n const cors = require(\"cors\");\r\n-const Eureka = require('eureka-js-client').Eureka;\r\n+\r\n // Importer les routes\r\n const authRoutes = require(\"./src/routes/authRoutes\");\r\n const emailRoutes = require(\"./src/routes/emailRoutes\");\r\n const draftRoutes = require(\"./src/routes/draftRoutes\");\r\n"
                },
                {
                    "date": 1748546175638,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n require(\"dotenv\").config();\r\n const express = require(\"express\");\r\n const cors = require(\"cors\");\r\n-\r\n+const Eureka = require('eureka-js-client').Eureka;\r\n // Importer les routes\r\n const authRoutes = require(\"./src/routes/authRoutes\");\r\n const emailRoutes = require(\"./src/routes/emailRoutes\");\r\n const draftRoutes = require(\"./src/routes/draftRoutes\");\r\n"
                },
                {
                    "date": 1748546186922,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -30,8 +30,10 @@\n   console.error(\"Erreur non gérée:\", err.stack);\r\n   res.status(500).json({ success: false, error: \"Erreur interne du serveur.\" });\r\n });\r\n \r\n+\r\n+\r\n app.listen(PORT, () => {\r\n   console.log(`Serveur démarré sur le port ${PORT}`);\r\n   console.log(\"Endpoints disponibles:\");\r\n   console.log(`GET  /auth/google`);\r\n"
                },
                {
                    "date": 1748546206232,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,44 @@\n   res.status(500).json({ success: false, error: \"Erreur interne du serveur.\" });\r\n });\r\n \r\n \r\n+const eurekaClient = new Eureka({\r\n+  instance: {\r\n+    app: process.env.APP_NAME,\r\n+    instanceId: `${process.env.APP_NAME}:${process.env.PORT}`,\r\n+    hostName: process.env.EUREKA_INSTANCE_HOSTNAME,\r\n+    ipAddr: '127.0.0.1', // À remplacer par votre IP si nécessaire\r\n+    port: {\r\n+      '$': parseInt(process.env.PORT),\r\n+      '@enabled': true\r\n+    },\r\n+    vipAddress: process.env.APP_NAME,\r\n+    dataCenterInfo: {\r\n+      '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n+      name: 'MyOwn'\r\n+    },\r\n+    preferIpAddress: process.env.EUREKA_PREFER_IP_ADDRESS === 'true'\r\n+  },\r\n+  eureka: {\r\n+    serviceUrls: {\r\n+      default: [\r\n+        process.env.EUREKA_SERVICE_URL\r\n+      ]\r\n+    },\r\n+    registerWithEureka: true,\r\n+    fetchRegistry: true\r\n+  }\r\n+});\r\n \r\n+// Démarrer Eureka une fois que le serveur Express est prêt\r\n+eurekaClient.start(error => {\r\n+  if (error) {\r\n+    console.error('Erreur lors de l’enregistrement auprès d’Eureka:', error);\r\n+  } else {\r\n+    console.log('Enregistré auprès d’Eureka avec succès');\r\n+  }\r\n+});\r\n app.listen(PORT, () => {\r\n   console.log(`Serveur démarré sur le port ${PORT}`);\r\n   console.log(\"Endpoints disponibles:\");\r\n   console.log(`GET  /auth/google`);\r\n"
                },
                {
                    "date": 1748546275984,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,9 +36,9 @@\n   instance: {\r\n     app: process.env.APP_NAME,\r\n     instanceId: `${process.env.APP_NAME}:${process.env.PORT}`,\r\n     hostName: process.env.EUREKA_INSTANCE_HOSTNAME,\r\n-    ipAddr: '127.0.0.1', // À remplacer par votre IP si nécessaire\r\n+    ipAddr: '161.97.88.195', // À remplacer par votre IP si nécessaire\r\n     port: {\r\n       '$': parseInt(process.env.PORT),\r\n       '@enabled': true\r\n     },\r\n@@ -67,8 +67,9 @@\n   } else {\r\n     console.log('Enregistré auprès d’Eureka avec succès');\r\n   }\r\n });\r\n+\r\n app.listen(PORT, () => {\r\n   console.log(`Serveur démarré sur le port ${PORT}`);\r\n   console.log(\"Endpoints disponibles:\");\r\n   console.log(`GET  /auth/google`);\r\n"
                },
                {
                    "date": 1748549413418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,77 +1,118 @@\n require(\"dotenv\").config();\r\n const express = require(\"express\");\r\n const cors = require(\"cors\");\r\n-const Eureka = require('eureka-js-client').Eureka;\r\n+const { Eureka } = require('eureka-js-client'); // Import Eureka client\r\n+\r\n // Importer les routes\r\n const authRoutes = require(\"./src/routes/authRoutes\");\r\n const emailRoutes = require(\"./src/routes/emailRoutes\");\r\n const draftRoutes = require(\"./src/routes/draftRoutes\");\r\n \r\n const app = express();\r\n \r\n // Middlewares\r\n-app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n-app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n+app.use(cors());\r\n+app.use(express.json());\r\n \r\n+// Configuration depuis les variables d'environnement\r\n const PORT = process.env.PORT || 8079;\r\n+const APP_NAME = process.env.APP_NAME || 'EmailService'; // Utiliser le nom de l'app depuis .env\r\n+const EUREKA_ENABLED = process.env.EUREKA_ENABLED === 'true'; // Vérifier si Eureka est activé\r\n+const EUREKA_HOSTNAME = process.env.EUREKA_HOSTNAME;\r\n+const EUREKA_PREFER_IP = process.env.EUREKA_PREFER_IP === 'true'; // Note: Pas d'effet direct dans eureka-js-client\r\n+const EUREKA_URL = process.env.EUREKA_URL;\r\n \r\n+// --- Configuration et démarrage du client Eureka (si activé) ---\r\n+let eurekaClient = null;\r\n+if (EUREKA_ENABLED) {\r\n+  if (!EUREKA_HOSTNAME || !EUREKA_URL) {\r\n+    console.error(\"Erreur: Les variables d'environnement EUREKA_HOSTNAME et EUREKA_URL sont requises lorsque EUREKA_ENABLED est true.\");\r\n+    // Envisagez d'arrêter le processus si la configuration est essentielle:\r\n+    // process.exit(1); \r\n+  } else {\r\n+    console.log(\"Configuration Eureka activée. Tentative d'enregistrement...\");\r\n+    eurekaClient = new Eureka({\r\n+      instance: {\r\n+        app: APP_NAME, // Nom de l'application\r\n+        hostName: EUREKA_HOSTNAME, // Nom d'hôte de l'instance\r\n+        ipAddr: '127.0.0.1', // IP de l'instance (peut être dynamique, mais nécessaire)\r\n+        statusPageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/info`,\r\n+        healthCheckUrl: `http://${EUREKA_HOSTNAME}:${PORT}/health`,\r\n+        homePageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/`,\r\n+        port: {\r\n+          '$': PORT, // Port de l'application\r\n+          '@enabled': 'true',\r\n+        },\r\n+        vipAddress: APP_NAME, // Adresse VIP (souvent le nom de l'app)\r\n+        dataCenterInfo: {\r\n+          '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n+          name: 'MyOwn', // Nom du data center ('MyOwn' ou 'Amazon')\r\n+        },\r\n+      },\r\n+      eureka: {\r\n+        serviceUrls: {\r\n+          default: [EUREKA_URL], // URL(s) du serveur Eureka\r\n+        },\r\n+        fetchRegistry: true, // Récupérer le registre\r\n+        registerWithEureka: true, // S'enregistrer auprès d'Eureka\r\n+        heartbeatInterval: 30000, // Intervalle des heartbeats (ms)\r\n+        registryFetchInterval: 30000, // Intervalle de récupération du registre (ms)\r\n+      },\r\n+    });\r\n+\r\n+    // Démarrer le client Eureka\r\n+    eurekaClient.start((error) => {\r\n+      if (error) {\r\n+        console.error('Erreur lors du démarrage du client Eureka:', error);\r\n+      } else {\r\n+        console.log('Client Eureka démarré et enregistré avec succès.');\r\n+      }\r\n+    });\r\n+\r\n+    // Ajouter des endpoints pour le statut et la santé (requis par Eureka)\r\n+    app.get('/info', (req, res) => res.json({ status: 'UP' }));\r\n+    app.get('/health', (req, res) => res.json({ status: 'UP' }));\r\n+\r\n+    // Gérer l'arrêt propre du client Eureka\r\n+    const shutdown = () => {\r\n+      console.log('Arrêt du serveur...');\r\n+      if (eurekaClient) {\r\n+        eurekaClient.stop(() => {\r\n+          console.log('Client Eureka arrêté.');\r\n+          process.exit(0);\r\n+        });\r\n+      } else {\r\n+        process.exit(0);\r\n+      }\r\n+    };\r\n+    process.on('SIGINT', shutdown); // Capture Ctrl+C\r\n+    process.on('SIGTERM', shutdown); // Capture les signaux d'arrêt\r\n+  }\r\n+} else {\r\n+  console.log(\"Configuration Eureka désactivée.\");\r\n+}\r\n+// --- Fin de la configuration Eureka ---\r\n+\r\n+\r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n-app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n-app.use(\"/drafts\", draftRoutes); // Préfixe pour toutes les routes liées aux brouillons\r\n+app.use(\"/emails\", emailRoutes);\r\n+app.use(\"/drafts\", draftRoutes);\r\n \r\n-// Route de base pour vérifier si le serveur fonctionne\r\n+// Route de base\r\n app.get(\"/\", (req, res) => {\r\n-  res.send(\"Serveur API Gmail fonctionnel.\");\r\n+  res.send(`Serveur API ${APP_NAME} fonctionnel.`); // Utiliser le nom de l'app\r\n });\r\n \r\n-// Gestionnaire d'erreurs global (optionnel mais recommandé)\r\n+// Gestionnaire d'erreurs\r\n app.use((err, req, res, next) => {\r\n   console.error(\"Erreur non gérée:\", err.stack);\r\n   res.status(500).json({ success: false, error: \"Erreur interne du serveur.\" });\r\n });\r\n \r\n-\r\n-const eurekaClient = new Eureka({\r\n-  instance: {\r\n-    app: process.env.APP_NAME,\r\n-    instanceId: `${process.env.APP_NAME}:${process.env.PORT}`,\r\n-    hostName: process.env.EUREKA_INSTANCE_HOSTNAME,\r\n-    ipAddr: '161.97.88.195', // À remplacer par votre IP si nécessaire\r\n-    port: {\r\n-      '$': parseInt(process.env.PORT),\r\n-      '@enabled': true\r\n-    },\r\n-    vipAddress: process.env.APP_NAME,\r\n-    dataCenterInfo: {\r\n-      '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n-      name: 'MyOwn'\r\n-    },\r\n-    preferIpAddress: process.env.EUREKA_PREFER_IP_ADDRESS === 'true'\r\n-  },\r\n-  eureka: {\r\n-    serviceUrls: {\r\n-      default: [\r\n-        process.env.EUREKA_SERVICE_URL\r\n-      ]\r\n-    },\r\n-    registerWithEureka: true,\r\n-    fetchRegistry: true\r\n-  }\r\n-});\r\n-\r\n-// Démarrer Eureka une fois que le serveur Express est prêt\r\n-eurekaClient.start(error => {\r\n-  if (error) {\r\n-    console.error('Erreur lors de l’enregistrement auprès d’Eureka:', error);\r\n-  } else {\r\n-    console.log('Enregistré auprès d’Eureka avec succès');\r\n-  }\r\n-});\r\n-\r\n app.listen(PORT, () => {\r\n-  console.log(`Serveur démarré sur le port ${PORT}`);\r\n+  console.log(`Serveur ${APP_NAME} démarré sur le port ${PORT}`); // Utiliser le nom de l'app\r\n   console.log(\"Endpoints disponibles:\");\r\n   console.log(`GET  /auth/google`);\r\n   console.log(`GET  /auth/google/callback`);\r\n   console.log(`POST /auth/refresh-token`);\r\n@@ -84,4 +125,5 @@\n   console.log(`POST /emails/:emailId/restore`);\r\n   console.log(`GET  /drafts`);\r\n   console.log(`DELETE /drafts/:draftId`);\r\n });\r\n+\r\n"
                },
                {
                    "date": 1748549463925,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,118 +1,77 @@\n require(\"dotenv\").config();\r\n const express = require(\"express\");\r\n const cors = require(\"cors\");\r\n-const { Eureka } = require('eureka-js-client'); // Import Eureka client\r\n-\r\n+const Eureka = require('eureka-js-client').Eureka;\r\n // Importer les routes\r\n const authRoutes = require(\"./src/routes/authRoutes\");\r\n const emailRoutes = require(\"./src/routes/emailRoutes\");\r\n const draftRoutes = require(\"./src/routes/draftRoutes\");\r\n \r\n const app = express();\r\n \r\n // Middlewares\r\n-app.use(cors());\r\n-app.use(express.json());\r\n+app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n+app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n-// Configuration depuis les variables d'environnement\r\n const PORT = process.env.PORT || 8079;\r\n-const APP_NAME = process.env.APP_NAME || 'EmailService'; // Utiliser le nom de l'app depuis .env\r\n-const EUREKA_ENABLED = process.env.EUREKA_ENABLED === 'true'; // Vérifier si Eureka est activé\r\n-const EUREKA_HOSTNAME = process.env.EUREKA_HOSTNAME;\r\n-const EUREKA_PREFER_IP = process.env.EUREKA_PREFER_IP === 'true'; // Note: Pas d'effet direct dans eureka-js-client\r\n-const EUREKA_URL = process.env.EUREKA_URL;\r\n \r\n-// --- Configuration et démarrage du client Eureka (si activé) ---\r\n-let eurekaClient = null;\r\n-if (EUREKA_ENABLED) {\r\n-  if (!EUREKA_HOSTNAME || !EUREKA_URL) {\r\n-    console.error(\"Erreur: Les variables d'environnement EUREKA_HOSTNAME et EUREKA_URL sont requises lorsque EUREKA_ENABLED est true.\");\r\n-    // Envisagez d'arrêter le processus si la configuration est essentielle:\r\n-    // process.exit(1); \r\n-  } else {\r\n-    console.log(\"Configuration Eureka activée. Tentative d'enregistrement...\");\r\n-    eurekaClient = new Eureka({\r\n-      instance: {\r\n-        app: APP_NAME, // Nom de l'application\r\n-        hostName: EUREKA_HOSTNAME, // Nom d'hôte de l'instance\r\n-        ipAddr: '127.0.0.1', // IP de l'instance (peut être dynamique, mais nécessaire)\r\n-        statusPageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/info`,\r\n-        healthCheckUrl: `http://${EUREKA_HOSTNAME}:${PORT}/health`,\r\n-        homePageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/`,\r\n-        port: {\r\n-          '$': PORT, // Port de l'application\r\n-          '@enabled': 'true',\r\n-        },\r\n-        vipAddress: APP_NAME, // Adresse VIP (souvent le nom de l'app)\r\n-        dataCenterInfo: {\r\n-          '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n-          name: 'MyOwn', // Nom du data center ('MyOwn' ou 'Amazon')\r\n-        },\r\n-      },\r\n-      eureka: {\r\n-        serviceUrls: {\r\n-          default: [EUREKA_URL], // URL(s) du serveur Eureka\r\n-        },\r\n-        fetchRegistry: true, // Récupérer le registre\r\n-        registerWithEureka: true, // S'enregistrer auprès d'Eureka\r\n-        heartbeatInterval: 30000, // Intervalle des heartbeats (ms)\r\n-        registryFetchInterval: 30000, // Intervalle de récupération du registre (ms)\r\n-      },\r\n-    });\r\n-\r\n-    // Démarrer le client Eureka\r\n-    eurekaClient.start((error) => {\r\n-      if (error) {\r\n-        console.error('Erreur lors du démarrage du client Eureka:', error);\r\n-      } else {\r\n-        console.log('Client Eureka démarré et enregistré avec succès.');\r\n-      }\r\n-    });\r\n-\r\n-    // Ajouter des endpoints pour le statut et la santé (requis par Eureka)\r\n-    app.get('/info', (req, res) => res.json({ status: 'UP' }));\r\n-    app.get('/health', (req, res) => res.json({ status: 'UP' }));\r\n-\r\n-    // Gérer l'arrêt propre du client Eureka\r\n-    const shutdown = () => {\r\n-      console.log('Arrêt du serveur...');\r\n-      if (eurekaClient) {\r\n-        eurekaClient.stop(() => {\r\n-          console.log('Client Eureka arrêté.');\r\n-          process.exit(0);\r\n-        });\r\n-      } else {\r\n-        process.exit(0);\r\n-      }\r\n-    };\r\n-    process.on('SIGINT', shutdown); // Capture Ctrl+C\r\n-    process.on('SIGTERM', shutdown); // Capture les signaux d'arrêt\r\n-  }\r\n-} else {\r\n-  console.log(\"Configuration Eureka désactivée.\");\r\n-}\r\n-// --- Fin de la configuration Eureka ---\r\n-\r\n-\r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n-app.use(\"/emails\", emailRoutes);\r\n-app.use(\"/drafts\", draftRoutes);\r\n+app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n+app.use(\"/drafts\", draftRoutes); // Préfixe pour toutes les routes liées aux brouillons\r\n \r\n-// Route de base\r\n+// Route de base pour vérifier si le serveur fonctionne\r\n app.get(\"/\", (req, res) => {\r\n-  res.send(`Serveur API ${APP_NAME} fonctionnel.`); // Utiliser le nom de l'app\r\n+  res.send(\"Serveur API Gmail fonctionnel.\");\r\n });\r\n \r\n-// Gestionnaire d'erreurs\r\n+// Gestionnaire d'erreurs global (optionnel mais recommandé)\r\n app.use((err, req, res, next) => {\r\n   console.error(\"Erreur non gérée:\", err.stack);\r\n   res.status(500).json({ success: false, error: \"Erreur interne du serveur.\" });\r\n });\r\n \r\n+\r\n+const eurekaClient = new Eureka({\r\n+  instance: {\r\n+    app: process.env.APP_NAME,\r\n+    instanceId: `${process.env.APP_NAME}:${process.env.PORT}`,\r\n+    hostName: process.env.EUREKA_INSTANCE_HOSTNAME,\r\n+    ipAddr: '161.97.88.195', // À remplacer par votre IP si nécessaire\r\n+    port: {\r\n+      '$': parseInt(process.env.PORT),\r\n+      '@enabled': true\r\n+    },\r\n+    vipAddress: process.env.APP_NAME,\r\n+    dataCenterInfo: {\r\n+      '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n+      name: 'MyOwn'\r\n+    },\r\n+    preferIpAddress: process.env.EUREKA_PREFER_IP_ADDRESS === 'true'\r\n+  },\r\n+  eureka: {\r\n+    serviceUrls: {\r\n+      default: [\r\n+        process.env.EUREKA_SERVICE_URL\r\n+      ]\r\n+    },\r\n+    registerWithEureka: true,\r\n+    fetchRegistry: true\r\n+  }\r\n+});\r\n+\r\n+// Démarrer Eureka une fois que le serveur Express est prêt\r\n+eurekaClient.start(error => {\r\n+  if (error) {\r\n+    console.error('Erreur lors de l’enregistrement auprès d’Eureka:', error);\r\n+  } else {\r\n+    console.log('Enregistré auprès d’Eureka avec succès');\r\n+  }\r\n+});\r\n+\r\n app.listen(PORT, () => {\r\n-  console.log(`Serveur ${APP_NAME} démarré sur le port ${PORT}`); // Utiliser le nom de l'app\r\n+  console.log(`Serveur démarré sur le port ${PORT}`);\r\n   console.log(\"Endpoints disponibles:\");\r\n   console.log(`GET  /auth/google`);\r\n   console.log(`GET  /auth/google/callback`);\r\n   console.log(`POST /auth/refresh-token`);\r\n@@ -125,5 +84,4 @@\n   console.log(`POST /emails/:emailId/restore`);\r\n   console.log(`GET  /drafts`);\r\n   console.log(`DELETE /drafts/:draftId`);\r\n });\r\n-\r\n"
                },
                {
                    "date": 1748549574595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,8 +13,13 @@\n app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n const PORT = process.env.PORT || 8079;\r\n+const APP_NAME = process.env.APP_NAME || 'EmailService'; // Utiliser le nom de l'app depuis .env\r\n+const EUREKA_ENABLED = process.env.EUREKA_ENABLED === 'true'; // Vérifier si Eureka est activé\r\n+const EUREKA_HOSTNAME = process.env.EUREKA_HOSTNAME;\r\n+const EUREKA_PREFER_IP = process.env.EUREKA_PREFER_IP === 'true'; // Note: Pas d'effet direct dans eureka-js-client\r\n+const EUREKA_URL = process.env.EUREKA_URL;\r\n \r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n"
                },
                {
                    "date": 1748549616356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,8 +19,9 @@\n const EUREKA_HOSTNAME = process.env.EUREKA_HOSTNAME;\r\n const EUREKA_PREFER_IP = process.env.EUREKA_PREFER_IP === 'true'; // Note: Pas d'effet direct dans eureka-js-client\r\n const EUREKA_URL = process.env.EUREKA_URL;\r\n \r\n+\r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n app.use(\"/drafts\", draftRoutes); // Préfixe pour toutes les routes liées aux brouillons\r\n"
                },
                {
                    "date": 1748549637492,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,76 @@\n const EUREKA_HOSTNAME = process.env.EUREKA_HOSTNAME;\r\n const EUREKA_PREFER_IP = process.env.EUREKA_PREFER_IP === 'true'; // Note: Pas d'effet direct dans eureka-js-client\r\n const EUREKA_URL = process.env.EUREKA_URL;\r\n \r\n+let eurekaClient = null;\r\n+if (EUREKA_ENABLED) {\r\n+  if (!EUREKA_HOSTNAME || !EUREKA_URL) {\r\n+    console.error(\"Erreur: Les variables d'environnement EUREKA_HOSTNAME et EUREKA_URL sont requises lorsque EUREKA_ENABLED est true.\");\r\n+    // Envisagez d'arrêter le processus si la configuration est essentielle:\r\n+    // process.exit(1); \r\n+  } else {\r\n+    console.log(\"Configuration Eureka activée. Tentative d'enregistrement...\");\r\n+    eurekaClient = new Eureka({\r\n+      instance: {\r\n+        app: APP_NAME, // Nom de l'application\r\n+        hostName: EUREKA_HOSTNAME, // Nom d'hôte de l'instance\r\n+        ipAddr: '127.0.0.1', // IP de l'instance (peut être dynamique, mais nécessaire)\r\n+        statusPageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/info`,\r\n+        healthCheckUrl: `http://${EUREKA_HOSTNAME}:${PORT}/health`,\r\n+        homePageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/`,\r\n+        port: {\r\n+          '$': PORT, // Port de l'application\r\n+          '@enabled': 'true',\r\n+        },\r\n+        vipAddress: APP_NAME, // Adresse VIP (souvent le nom de l'app)\r\n+        dataCenterInfo: {\r\n+          '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n+          name: 'MyOwn', // Nom du data center ('MyOwn' ou 'Amazon')\r\n+        },\r\n+      },\r\n+      eureka: {\r\n+        serviceUrls: {\r\n+          default: [EUREKA_URL], // URL(s) du serveur Eureka\r\n+        },\r\n+        fetchRegistry: true, // Récupérer le registre\r\n+        registerWithEureka: true, // S'enregistrer auprès d'Eureka\r\n+        heartbeatInterval: 30000, // Intervalle des heartbeats (ms)\r\n+        registryFetchInterval: 30000, // Intervalle de récupération du registre (ms)\r\n+      },\r\n+    });\r\n \r\n+    // Démarrer le client Eureka\r\n+    eurekaClient.start((error) => {\r\n+      if (error) {\r\n+        console.error('Erreur lors du démarrage du client Eureka:', error);\r\n+      } else {\r\n+        console.log('Client Eureka démarré et enregistré avec succès.');\r\n+      }\r\n+    });\r\n+\r\n+    // Ajouter des endpoints pour le statut et la santé (requis par Eureka)\r\n+    app.get('/info', (req, res) => res.json({ status: 'UP' }));\r\n+    app.get('/health', (req, res) => res.json({ status: 'UP' }));\r\n+\r\n+    // Gérer l'arrêt propre du client Eureka\r\n+    const shutdown = () => {\r\n+      console.log('Arrêt du serveur...');\r\n+      if (eurekaClient) {\r\n+        eurekaClient.stop(() => {\r\n+          console.log('Client Eureka arrêté.');\r\n+          process.exit(0);\r\n+        });\r\n+      } else {\r\n+        process.exit(0);\r\n+      }\r\n+    };\r\n+    process.on('SIGINT', shutdown); // Capture Ctrl+C\r\n+    process.on('SIGTERM', shutdown); // Capture les signaux d'arrêt\r\n+  }\r\n+} else {\r\n+  console.log(\"Configuration Eureka désactivée.\");\r\n+}\r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n app.use(\"/drafts\", draftRoutes); // Préfixe pour toutes les routes liées aux brouillons\r\n@@ -37,36 +104,10 @@\n   res.status(500).json({ success: false, error: \"Erreur interne du serveur.\" });\r\n });\r\n \r\n \r\n-const eurekaClient = new Eureka({\r\n-  instance: {\r\n-    app: process.env.APP_NAME,\r\n-    instanceId: `${process.env.APP_NAME}:${process.env.PORT}`,\r\n-    hostName: process.env.EUREKA_INSTANCE_HOSTNAME,\r\n-    ipAddr: '161.97.88.195', // À remplacer par votre IP si nécessaire\r\n-    port: {\r\n-      '$': parseInt(process.env.PORT),\r\n-      '@enabled': true\r\n-    },\r\n-    vipAddress: process.env.APP_NAME,\r\n-    dataCenterInfo: {\r\n-      '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n-      name: 'MyOwn'\r\n-    },\r\n-    preferIpAddress: process.env.EUREKA_PREFER_IP_ADDRESS === 'true'\r\n-  },\r\n-  eureka: {\r\n-    serviceUrls: {\r\n-      default: [\r\n-        process.env.EUREKA_SERVICE_URL\r\n-      ]\r\n-    },\r\n-    registerWithEureka: true,\r\n-    fetchRegistry: true\r\n-  }\r\n-});\r\n \r\n+\r\n // Démarrer Eureka une fois que le serveur Express est prêt\r\n eurekaClient.start(error => {\r\n   if (error) {\r\n     console.error('Erreur lors de l’enregistrement auprès d’Eureka:', error);\r\n"
                },
                {
                    "date": 1748549655860,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,19 +104,8 @@\n   res.status(500).json({ success: false, error: \"Erreur interne du serveur.\" });\r\n });\r\n \r\n \r\n-\r\n-\r\n-// Démarrer Eureka une fois que le serveur Express est prêt\r\n-eurekaClient.start(error => {\r\n-  if (error) {\r\n-    console.error('Erreur lors de l’enregistrement auprès d’Eureka:', error);\r\n-  } else {\r\n-    console.log('Enregistré auprès d’Eureka avec succès');\r\n-  }\r\n-});\r\n-\r\n app.listen(PORT, () => {\r\n   console.log(`Serveur démarré sur le port ${PORT}`);\r\n   console.log(\"Endpoints disponibles:\");\r\n   console.log(`GET  /auth/google`);\r\n"
                },
                {
                    "date": 1748549762614,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     eurekaClient = new Eureka({\r\n       instance: {\r\n         app: APP_NAME, // Nom de l'application\r\n         hostName: EUREKA_HOSTNAME, // Nom d'hôte de l'instance\r\n-        ipAddr: '127.0.0.1', // IP de l'instance (peut être dynamique, mais nécessaire)\r\n+        ipAddr: 'eureka.systeo.tn', // IP de l'instance (peut être dynamique, mais nécessaire)\r\n         statusPageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/info`,\r\n         healthCheckUrl: `http://${EUREKA_HOSTNAME}:${PORT}/health`,\r\n         homePageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/`,\r\n         port: {\r\n"
                },
                {
                    "date": 1748550092773,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,10 +7,8 @@\n const emailRoutes = require(\"./src/routes/emailRoutes\");\r\n const draftRoutes = require(\"./src/routes/draftRoutes\");\r\n \r\n const app = express();\r\n-\r\n-// Middlewares\r\n app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n const PORT = process.env.PORT || 8079;\r\n"
                },
                {
                    "date": 1748550115180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,14 +11,10 @@\n app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n const PORT = process.env.PORT || 8079;\r\n-const APP_NAME = process.env.APP_NAME || 'EmailService'; // Utiliser le nom de l'app depuis .env\r\n-const EUREKA_ENABLED = process.env.EUREKA_ENABLED === 'true'; // Vérifier si Eureka est activé\r\n-const EUREKA_HOSTNAME = process.env.EUREKA_HOSTNAME;\r\n-const EUREKA_PREFER_IP = process.env.EUREKA_PREFER_IP === 'true'; // Note: Pas d'effet direct dans eureka-js-client\r\n-const EUREKA_URL = process.env.EUREKA_URL;\r\n \r\n+\r\n let eurekaClient = null;\r\n if (EUREKA_ENABLED) {\r\n   if (!EUREKA_HOSTNAME || !EUREKA_URL) {\r\n     console.error(\"Erreur: Les variables d'environnement EUREKA_HOSTNAME et EUREKA_URL sont requises lorsque EUREKA_ENABLED est true.\");\r\n"
                },
                {
                    "date": 1748550147909,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,76 +13,8 @@\n \r\n const PORT = process.env.PORT || 8079;\r\n \r\n \r\n-let eurekaClient = null;\r\n-if (EUREKA_ENABLED) {\r\n-  if (!EUREKA_HOSTNAME || !EUREKA_URL) {\r\n-    console.error(\"Erreur: Les variables d'environnement EUREKA_HOSTNAME et EUREKA_URL sont requises lorsque EUREKA_ENABLED est true.\");\r\n-    // Envisagez d'arrêter le processus si la configuration est essentielle:\r\n-    // process.exit(1); \r\n-  } else {\r\n-    console.log(\"Configuration Eureka activée. Tentative d'enregistrement...\");\r\n-    eurekaClient = new Eureka({\r\n-      instance: {\r\n-        app: APP_NAME, // Nom de l'application\r\n-        hostName: EUREKA_HOSTNAME, // Nom d'hôte de l'instance\r\n-        ipAddr: 'eureka.systeo.tn', // IP de l'instance (peut être dynamique, mais nécessaire)\r\n-        statusPageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/info`,\r\n-        healthCheckUrl: `http://${EUREKA_HOSTNAME}:${PORT}/health`,\r\n-        homePageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/`,\r\n-        port: {\r\n-          '$': PORT, // Port de l'application\r\n-          '@enabled': 'true',\r\n-        },\r\n-        vipAddress: APP_NAME, // Adresse VIP (souvent le nom de l'app)\r\n-        dataCenterInfo: {\r\n-          '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n-          name: 'MyOwn', // Nom du data center ('MyOwn' ou 'Amazon')\r\n-        },\r\n-      },\r\n-      eureka: {\r\n-        serviceUrls: {\r\n-          default: [EUREKA_URL], // URL(s) du serveur Eureka\r\n-        },\r\n-        fetchRegistry: true, // Récupérer le registre\r\n-        registerWithEureka: true, // S'enregistrer auprès d'Eureka\r\n-        heartbeatInterval: 30000, // Intervalle des heartbeats (ms)\r\n-        registryFetchInterval: 30000, // Intervalle de récupération du registre (ms)\r\n-      },\r\n-    });\r\n-\r\n-    // Démarrer le client Eureka\r\n-    eurekaClient.start((error) => {\r\n-      if (error) {\r\n-        console.error('Erreur lors du démarrage du client Eureka:', error);\r\n-      } else {\r\n-        console.log('Client Eureka démarré et enregistré avec succès.');\r\n-      }\r\n-    });\r\n-\r\n-    // Ajouter des endpoints pour le statut et la santé (requis par Eureka)\r\n-    app.get('/info', (req, res) => res.json({ status: 'UP' }));\r\n-    app.get('/health', (req, res) => res.json({ status: 'UP' }));\r\n-\r\n-    // Gérer l'arrêt propre du client Eureka\r\n-    const shutdown = () => {\r\n-      console.log('Arrêt du serveur...');\r\n-      if (eurekaClient) {\r\n-        eurekaClient.stop(() => {\r\n-          console.log('Client Eureka arrêté.');\r\n-          process.exit(0);\r\n-        });\r\n-      } else {\r\n-        process.exit(0);\r\n-      }\r\n-    };\r\n-    process.on('SIGINT', shutdown); // Capture Ctrl+C\r\n-    process.on('SIGTERM', shutdown); // Capture les signaux d'arrêt\r\n-  }\r\n-} else {\r\n-  console.log(\"Configuration Eureka désactivée.\");\r\n-}\r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n app.use(\"/drafts\", draftRoutes); // Préfixe pour toutes les routes liées aux brouillons\r\n@@ -96,10 +28,44 @@\n app.use((err, req, res, next) => {\r\n   console.error(\"Erreur non gérée:\", err.stack);\r\n   res.status(500).json({ success: false, error: \"Erreur interne du serveur.\" });\r\n });\r\n+// Eureka Client\r\n+if (process.env.EUREKA_ENABLED === 'true') {\r\n+  const eurekaClient = new Eureka({\r\n+    instance: {\r\n+      app: process.env.APP_NAME,\r\n+      instanceId: `${process.env.APP_NAME}:${process.env.PORT}`,\r\n+      hostName: process.env.EUREKA_INSTANCE_HOSTNAME,\r\n+      ipAddr: process.env.EUREKA_INSTANCE_HOSTNAME,\r\n+      statusPageUrl: `https://${process.env.EUREKA_INSTANCE_HOSTNAME}:${process.env.PORT}/info`,\r\n+      healthCheckUrl: `https://${process.env.EUREKA_INSTANCE_HOSTNAME}:${process.env.PORT}/health`,\r\n+      port: { '$': parseInt(process.env.PORT), '@enabled': true },\r\n+      vipAddress: process.env.APP_NAME,\r\n+      dataCenterInfo: { \r\n+        '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n+        name: 'MyOwn'\r\n+      }\r\n+    },\r\n+    eureka: {\r\n+      host: 'eureka.systeo.tn',\r\n+      port: 443,\r\n+      servicePath: '/eureka/apps/',\r\n+      maxRetries: 10\r\n+    }\r\n+  });\r\n \r\n+  eurekaClient.start(error => {\r\n+    if (error) console.error('Eureka error:', error);\r\n+    else console.log('Registered with Eureka');\r\n+  });\r\n \r\n+  process.on('SIGINT', () => {\r\n+    eurekaClient.stop(() => process.exit());\r\n+  });\r\n+}\r\n+\r\n+\r\n app.listen(PORT, () => {\r\n   console.log(`Serveur démarré sur le port ${PORT}`);\r\n   console.log(\"Endpoints disponibles:\");\r\n   console.log(`GET  /auth/google`);\r\n"
                },
                {
                    "date": 1748550389254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n     instance: {\r\n       app: process.env.APP_NAME,\r\n       instanceId: `${process.env.APP_NAME}:${process.env.PORT}`,\r\n       hostName: process.env.EUREKA_INSTANCE_HOSTNAME,\r\n-      ipAddr: process.env.EUREKA_INSTANCE_HOSTNAME,\r\n+      ipAddr: ,\r\n       statusPageUrl: `https://${process.env.EUREKA_INSTANCE_HOSTNAME}:${process.env.PORT}/info`,\r\n       healthCheckUrl: `https://${process.env.EUREKA_INSTANCE_HOSTNAME}:${process.env.PORT}/health`,\r\n       port: { '$': parseInt(process.env.PORT), '@enabled': true },\r\n       vipAddress: process.env.APP_NAME,\r\n"
                },
                {
                    "date": 1748550395219,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -35,9 +35,9 @@\n     instance: {\r\n       app: process.env.APP_NAME,\r\n       instanceId: `${process.env.APP_NAME}:${process.env.PORT}`,\r\n       hostName: process.env.EUREKA_INSTANCE_HOSTNAME,\r\n-      ipAddr: ,\r\n+      ipAddr: \"161.97.88.195\",\r\n       statusPageUrl: `https://${process.env.EUREKA_INSTANCE_HOSTNAME}:${process.env.PORT}/info`,\r\n       healthCheckUrl: `https://${process.env.EUREKA_INSTANCE_HOSTNAME}:${process.env.PORT}/health`,\r\n       port: { '$': parseInt(process.env.PORT), '@enabled': true },\r\n       vipAddress: process.env.APP_NAME,\r\n"
                },
                {
                    "date": 1748550648201,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,14 +7,88 @@\n const emailRoutes = require(\"./src/routes/emailRoutes\");\r\n const draftRoutes = require(\"./src/routes/draftRoutes\");\r\n \r\n const app = express();\r\n+\r\n+// Middlewares\r\n app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n const PORT = process.env.PORT || 8079;\r\n+const APP_NAME = process.env.APP_NAME || 'EmailService'; // Utiliser le nom de l'app depuis .env\r\n+const EUREKA_ENABLED = process.env.EUREKA_ENABLED === 'true'; // Vérifier si Eureka est activé\r\n+const EUREKA_HOSTNAME = process.env.EUREKA_HOSTNAME;\r\n+const EUREKA_PREFER_IP = process.env.EUREKA_PREFER_IP === 'true'; // Note: Pas d'effet direct dans eureka-js-client\r\n+const EUREKA_URL = process.env.EUREKA_URL;\r\n \r\n+let eurekaClient = null;\r\n+if (EUREKA_ENABLED) {\r\n+  if (!EUREKA_HOSTNAME || !EUREKA_URL) {\r\n+    console.error(\"Erreur: Les variables d'environnement EUREKA_HOSTNAME et EUREKA_URL sont requises lorsque EUREKA_ENABLED est true.\");\r\n+    // Envisagez d'arrêter le processus si la configuration est essentielle:\r\n+    // process.exit(1); \r\n+  } else {\r\n+    console.log(\"Configuration Eureka activée. Tentative d'enregistrement...\");\r\n+    eurekaClient = new Eureka({\r\n+      instance: {\r\n+        app: APP_NAME, // Nom de l'application\r\n+        hostName: EUREKA_HOSTNAME, // Nom d'hôte de l'instance\r\n+        ipAddr: 'eureka.systeo.tn', // IP de l'instance (peut être dynamique, mais nécessaire)\r\n+        statusPageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/info`,\r\n+        healthCheckUrl: `http://${EUREKA_HOSTNAME}:${PORT}/health`,\r\n+        homePageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/`,\r\n+        port: {\r\n+          '$': PORT, // Port de l'application\r\n+          '@enabled': 'true',\r\n+        },\r\n+        vipAddress: APP_NAME, // Adresse VIP (souvent le nom de l'app)\r\n+        dataCenterInfo: {\r\n+          '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n+          name: 'MyOwn', // Nom du data center ('MyOwn' ou 'Amazon')\r\n+        },\r\n+      },\r\n+      eureka: {\r\n+        serviceUrls: {\r\n+          default: [EUREKA_URL], // URL(s) du serveur Eureka\r\n+        },\r\n+        fetchRegistry: true, // Récupérer le registre\r\n+        registerWithEureka: true, // S'enregistrer auprès d'Eureka\r\n+        heartbeatInterval: 30000, // Intervalle des heartbeats (ms)\r\n+        registryFetchInterval: 30000, // Intervalle de récupération du registre (ms)\r\n+      },\r\n+    });\r\n \r\n+    // Démarrer le client Eureka\r\n+    eurekaClient.start((error) => {\r\n+      if (error) {\r\n+        console.error('Erreur lors du démarrage du client Eureka:', error);\r\n+      } else {\r\n+        console.log('Client Eureka démarré et enregistré avec succès.');\r\n+      }\r\n+    });\r\n+\r\n+    // Ajouter des endpoints pour le statut et la santé (requis par Eureka)\r\n+    app.get('/info', (req, res) => res.json({ status: 'UP' }));\r\n+    app.get('/health', (req, res) => res.json({ status: 'UP' }));\r\n+\r\n+    // Gérer l'arrêt propre du client Eureka\r\n+    const shutdown = () => {\r\n+      console.log('Arrêt du serveur...');\r\n+      if (eurekaClient) {\r\n+        eurekaClient.stop(() => {\r\n+          console.log('Client Eureka arrêté.');\r\n+          process.exit(0);\r\n+        });\r\n+      } else {\r\n+        process.exit(0);\r\n+      }\r\n+    };\r\n+    process.on('SIGINT', shutdown); // Capture Ctrl+C\r\n+    process.on('SIGTERM', shutdown); // Capture les signaux d'arrêt\r\n+  }\r\n+} else {\r\n+  console.log(\"Configuration Eureka désactivée.\");\r\n+}\r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n app.use(\"/drafts\", draftRoutes); // Préfixe pour toutes les routes liées aux brouillons\r\n@@ -28,44 +102,10 @@\n app.use((err, req, res, next) => {\r\n   console.error(\"Erreur non gérée:\", err.stack);\r\n   res.status(500).json({ success: false, error: \"Erreur interne du serveur.\" });\r\n });\r\n-// Eureka Client\r\n-if (process.env.EUREKA_ENABLED === 'true') {\r\n-  const eurekaClient = new Eureka({\r\n-    instance: {\r\n-      app: process.env.APP_NAME,\r\n-      instanceId: `${process.env.APP_NAME}:${process.env.PORT}`,\r\n-      hostName: process.env.EUREKA_INSTANCE_HOSTNAME,\r\n-      ipAddr: \"161.97.88.195\",\r\n-      statusPageUrl: `https://${process.env.EUREKA_INSTANCE_HOSTNAME}:${process.env.PORT}/info`,\r\n-      healthCheckUrl: `https://${process.env.EUREKA_INSTANCE_HOSTNAME}:${process.env.PORT}/health`,\r\n-      port: { '$': parseInt(process.env.PORT), '@enabled': true },\r\n-      vipAddress: process.env.APP_NAME,\r\n-      dataCenterInfo: { \r\n-        '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n-        name: 'MyOwn'\r\n-      }\r\n-    },\r\n-    eureka: {\r\n-      host: 'eureka.systeo.tn',\r\n-      port: 443,\r\n-      servicePath: '/eureka/apps/',\r\n-      maxRetries: 10\r\n-    }\r\n-  });\r\n \r\n-  eurekaClient.start(error => {\r\n-    if (error) console.error('Eureka error:', error);\r\n-    else console.log('Registered with Eureka');\r\n-  });\r\n \r\n-  process.on('SIGINT', () => {\r\n-    eurekaClient.stop(() => process.exit());\r\n-  });\r\n-}\r\n-\r\n-\r\n app.listen(PORT, () => {\r\n   console.log(`Serveur démarré sur le port ${PORT}`);\r\n   console.log(\"Endpoints disponibles:\");\r\n   console.log(`GET  /auth/google`);\r\n"
                },
                {
                    "date": 1748550654108,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,9 +31,9 @@\n     eurekaClient = new Eureka({\r\n       instance: {\r\n         app: APP_NAME, // Nom de l'application\r\n         hostName: EUREKA_HOSTNAME, // Nom d'hôte de l'instance\r\n-        ipAddr: 'eureka.systeo.tn', // IP de l'instance (peut être dynamique, mais nécessaire)\r\n+        ipAddr: '127.0.0.1', // IP de l'instance (peut être dynamique, mais nécessaire)\r\n         statusPageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/info`,\r\n         healthCheckUrl: `http://${EUREKA_HOSTNAME}:${PORT}/health`,\r\n         homePageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/`,\r\n         port: {\r\n@@ -104,8 +104,19 @@\n   res.status(500).json({ success: false, error: \"Erreur interne du serveur.\" });\r\n });\r\n \r\n \r\n+\r\n+\r\n+// Démarrer Eureka une fois que le serveur Express est prêt\r\n+eurekaClient.start(error => {\r\n+  if (error) {\r\n+    console.error('Erreur lors de l’enregistrement auprès d’Eureka:', error);\r\n+  } else {\r\n+    console.log('Enregistré auprès d’Eureka avec succès');\r\n+  }\r\n+});\r\n+\r\n app.listen(PORT, () => {\r\n   console.log(`Serveur démarré sur le port ${PORT}`);\r\n   console.log(\"Endpoints disponibles:\");\r\n   console.log(`GET  /auth/google`);\r\n"
                },
                {
                    "date": 1748550667918,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n require(\"dotenv\").config();\r\n const express = require(\"express\");\r\n const cors = require(\"cors\");\r\n-const Eureka = require('eureka-js-client').Eureka;\r\n+\r\n // Importer les routes\r\n const authRoutes = require(\"./src/routes/authRoutes\");\r\n const emailRoutes = require(\"./src/routes/emailRoutes\");\r\n const draftRoutes = require(\"./src/routes/draftRoutes\");\r\n@@ -13,82 +13,9 @@\n app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n const PORT = process.env.PORT || 8079;\r\n-const APP_NAME = process.env.APP_NAME || 'EmailService'; // Utiliser le nom de l'app depuis .env\r\n-const EUREKA_ENABLED = process.env.EUREKA_ENABLED === 'true'; // Vérifier si Eureka est activé\r\n-const EUREKA_HOSTNAME = process.env.EUREKA_HOSTNAME;\r\n-const EUREKA_PREFER_IP = process.env.EUREKA_PREFER_IP === 'true'; // Note: Pas d'effet direct dans eureka-js-client\r\n-const EUREKA_URL = process.env.EUREKA_URL;\r\n \r\n-let eurekaClient = null;\r\n-if (EUREKA_ENABLED) {\r\n-  if (!EUREKA_HOSTNAME || !EUREKA_URL) {\r\n-    console.error(\"Erreur: Les variables d'environnement EUREKA_HOSTNAME et EUREKA_URL sont requises lorsque EUREKA_ENABLED est true.\");\r\n-    // Envisagez d'arrêter le processus si la configuration est essentielle:\r\n-    // process.exit(1); \r\n-  } else {\r\n-    console.log(\"Configuration Eureka activée. Tentative d'enregistrement...\");\r\n-    eurekaClient = new Eureka({\r\n-      instance: {\r\n-        app: APP_NAME, // Nom de l'application\r\n-        hostName: EUREKA_HOSTNAME, // Nom d'hôte de l'instance\r\n-        ipAddr: '127.0.0.1', // IP de l'instance (peut être dynamique, mais nécessaire)\r\n-        statusPageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/info`,\r\n-        healthCheckUrl: `http://${EUREKA_HOSTNAME}:${PORT}/health`,\r\n-        homePageUrl: `http://${EUREKA_HOSTNAME}:${PORT}/`,\r\n-        port: {\r\n-          '$': PORT, // Port de l'application\r\n-          '@enabled': 'true',\r\n-        },\r\n-        vipAddress: APP_NAME, // Adresse VIP (souvent le nom de l'app)\r\n-        dataCenterInfo: {\r\n-          '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n-          name: 'MyOwn', // Nom du data center ('MyOwn' ou 'Amazon')\r\n-        },\r\n-      },\r\n-      eureka: {\r\n-        serviceUrls: {\r\n-          default: [EUREKA_URL], // URL(s) du serveur Eureka\r\n-        },\r\n-        fetchRegistry: true, // Récupérer le registre\r\n-        registerWithEureka: true, // S'enregistrer auprès d'Eureka\r\n-        heartbeatInterval: 30000, // Intervalle des heartbeats (ms)\r\n-        registryFetchInterval: 30000, // Intervalle de récupération du registre (ms)\r\n-      },\r\n-    });\r\n-\r\n-    // Démarrer le client Eureka\r\n-    eurekaClient.start((error) => {\r\n-      if (error) {\r\n-        console.error('Erreur lors du démarrage du client Eureka:', error);\r\n-      } else {\r\n-        console.log('Client Eureka démarré et enregistré avec succès.');\r\n-      }\r\n-    });\r\n-\r\n-    // Ajouter des endpoints pour le statut et la santé (requis par Eureka)\r\n-    app.get('/info', (req, res) => res.json({ status: 'UP' }));\r\n-    app.get('/health', (req, res) => res.json({ status: 'UP' }));\r\n-\r\n-    // Gérer l'arrêt propre du client Eureka\r\n-    const shutdown = () => {\r\n-      console.log('Arrêt du serveur...');\r\n-      if (eurekaClient) {\r\n-        eurekaClient.stop(() => {\r\n-          console.log('Client Eureka arrêté.');\r\n-          process.exit(0);\r\n-        });\r\n-      } else {\r\n-        process.exit(0);\r\n-      }\r\n-    };\r\n-    process.on('SIGINT', shutdown); // Capture Ctrl+C\r\n-    process.on('SIGTERM', shutdown); // Capture les signaux d'arrêt\r\n-  }\r\n-} else {\r\n-  console.log(\"Configuration Eureka désactivée.\");\r\n-}\r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n app.use(\"/drafts\", draftRoutes); // Préfixe pour toutes les routes liées aux brouillons\r\n@@ -103,20 +30,8 @@\n   console.error(\"Erreur non gérée:\", err.stack);\r\n   res.status(500).json({ success: false, error: \"Erreur interne du serveur.\" });\r\n });\r\n \r\n-\r\n-\r\n-\r\n-// Démarrer Eureka une fois que le serveur Express est prêt\r\n-eurekaClient.start(error => {\r\n-  if (error) {\r\n-    console.error('Erreur lors de l’enregistrement auprès d’Eureka:', error);\r\n-  } else {\r\n-    console.log('Enregistré auprès d’Eureka avec succès');\r\n-  }\r\n-});\r\n-\r\n app.listen(PORT, () => {\r\n   console.log(`Serveur démarré sur le port ${PORT}`);\r\n   console.log(\"Endpoints disponibles:\");\r\n   console.log(`GET  /auth/google`);\r\n"
                },
                {
                    "date": 1748550715726,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,8 @@\n require(\"dotenv\").config();\r\n const express = require(\"express\");\r\n const cors = require(\"cors\");\r\n-\r\n+const Eureka = require('eureka-js-client').Eureka;\r\n // Importer les routes\r\n const authRoutes = require(\"./src/routes/authRoutes\");\r\n const emailRoutes = require(\"./src/routes/emailRoutes\");\r\n const draftRoutes = require(\"./src/routes/draftRoutes\");\r\n"
                },
                {
                    "date": 1748550747442,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,9 +13,42 @@\n app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n const PORT = process.env.PORT || 8079;\r\n+const client = new Eureka({\r\n+  instance: {\r\n+    app: 'emailService',\r\n+    hostName: 'e5.systeo.tn', // ou l'hôte où votre service est accessible\r\n+    ipAddr: '161.97.88.195', // l'adresse IP de votre serveur\r\n+    port: {\r\n+      '$': PORT,\r\n+      '@enabled': 'true',\r\n+    },\r\n+    vipAddress: 'emailService',\r\n+    dataCenterInfo: {\r\n+      '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n+      name: 'MyOwn',\r\n+    },\r\n+  },\r\n+  eureka: {\r\n+    host: 'eureka.systeo.tn',\r\n+    port: 443, // ou le port de votre Eureka (80 pour HTTP, 443 pour HTTPS)\r\n+    servicePath: '/eureka/apps/',\r\n+    ssl: true, // si vous utilisez HTTPS\r\n+  },\r\n+});\r\n \r\n+// Démarrer le client Eureka\r\n+client.start(error => {\r\n+  console.log(error || 'Client Eureka démarré avec succès');\r\n+});\r\n+\r\n+// Gestion de la fermeture propre\r\n+process.on('SIGINT', () => {\r\n+  client.stop();\r\n+  process.exit();\r\n+});\r\n+\r\n // Utiliser les routes\r\n app.use(\"/auth\", authRoutes);\r\n app.use(\"/emails\", emailRoutes); // Préfixe pour toutes les routes liées aux emails\r\n app.use(\"/drafts\", draftRoutes); // Préfixe pour toutes les routes liées aux brouillons\r\n"
                },
                {
                    "date": 1748550756847,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n const PORT = process.env.PORT || 8079;\r\n const client = new Eureka({\r\n   instance: {\r\n     app: 'emailService',\r\n-    hostName: 'e5.systeo.tn', // ou l'hôte où votre service est accessible\r\n+    hostName: 'e8.systeo.tn', // ou l'hôte où votre service est accessible\r\n     ipAddr: '161.97.88.195', // l'adresse IP de votre serveur\r\n     port: {\r\n       '$': PORT,\r\n       '@enabled': 'true',\r\n"
                },
                {
                    "date": 1748565256723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,10 +16,11 @@\n const PORT = process.env.PORT || 8079;\r\n const client = new Eureka({\r\n   instance: {\r\n     app: 'emailService',\r\n-    hostName: 'e8.systeo.tn', // ou l'hôte où votre service est accessible\r\n-    ipAddr: '161.97.88.195', // l'adresse IP de votre serveur\r\n+    instanceId: `e8.systeo.tn:emailService:${PORT}`, // Ajoutez ceci\r\n+    hostName: 'e8.systeo.tn',\r\n+    ipAddr: '161.97.88.195',\r\n     port: {\r\n       '$': PORT,\r\n       '@enabled': 'true',\r\n     },\r\n@@ -27,14 +28,20 @@\n     dataCenterInfo: {\r\n       '@class': 'com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo',\r\n       name: 'MyOwn',\r\n     },\r\n+    // Ajoutez ces métadonnées si nécessaire\r\n+    metadata: {\r\n+      'management.port': PORT,\r\n+      'securePort': 443,\r\n+      'securePortEnabled': 'true'\r\n+    }\r\n   },\r\n   eureka: {\r\n     host: 'eureka.systeo.tn',\r\n-    port: 443, // ou le port de votre Eureka (80 pour HTTP, 443 pour HTTPS)\r\n+    port: 443,\r\n     servicePath: '/eureka/apps/',\r\n-    ssl: true, // si vous utilisez HTTPS\r\n+    ssl: true,\r\n   },\r\n });\r\n \r\n // Démarrer le client Eureka\r\n"
                },
                {
                    "date": 1748631210124,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,12 @@\n \r\n const app = express();\r\n \r\n // Middlewares\r\n-app.use(cors()); // Activer CORS pour toutes les origines (à ajuster en production)\r\n+app.use(cors({\r\n+  origin: ['http://localhost:4200', 'https://e8.systeo.tn'],\r\n+  methods: 'GET,POST'\r\n+})); // Activer CORS pour toutes les origines (à ajuster en production)\r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n const PORT = process.env.PORT || 8079;\r\n const client = new Eureka({\r\n"
                },
                {
                    "date": 1748631216912,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,10 +11,9 @@\n \r\n // Middlewares\r\n app.use(cors({\r\n   origin: ['http://localhost:4200', 'https://e8.systeo.tn'],\r\n-  methods: 'GET,POST'\r\n-})); // Activer CORS pour toutes les origines (à ajuster en production)\r\n+  methods: 'GET,POST'})); \r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n const PORT = process.env.PORT || 8079;\r\n const client = new Eureka({\r\n"
                },
                {
                    "date": 1748631222380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,11 +9,9 @@\n \r\n const app = express();\r\n \r\n // Middlewares\r\n-app.use(cors({\r\n-  origin: ['http://localhost:4200', 'https://e8.systeo.tn'],\r\n-  methods: 'GET,POST'})); \r\n+app.use(cors({origin: ['http://localhost:4200', 'https://e8.systeo.tn'],methods: 'GET,POST'})); \r\n app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n \r\n const PORT = process.env.PORT || 8079;\r\n const client = new Eureka({\r\n"
                },
                {
                    "date": 1748631250931,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,10 +10,9 @@\n const app = express();\r\n \r\n // Middlewares\r\n app.use(cors({origin: ['http://localhost:4200', 'https://e8.systeo.tn'],methods: 'GET,POST'})); \r\n-app.use(express.json()); // Pour parser le JSON des requêtes entrantes\r\n-\r\n+app.use(express.json());\r\n const PORT = process.env.PORT || 8079;\r\n const client = new Eureka({\r\n   instance: {\r\n     app: 'emailService',\r\n"
                }
            ],
            "date": 1748453070534,
            "name": "Commit-0",
            "content": "require('dotenv').config();\r\nconst express = require('express');\r\nconst cors = require('cors');\r\nconst authRoutes = require('./routes/auth');\r\nconst emailRoutes = require('./routes/email');\r\n\r\nconst app = express();\r\n\r\n// Middleware\r\napp.use(cors({\r\n  origin: process.env.FRONTEND_URL,\r\n  credentials: true\r\n}));\r\napp.use(express.json());\r\n\r\n// Routes\r\napp.use('/auth', authRoutes);\r\napp.use('/email', emailRoutes);\r\n\r\nconst PORT = process.env.PORT || 3000;\r\napp.listen(PORT, () => {\r\n  console.log(`Server running on port ${PORT}`);\r\n});"
        }
    ]
}
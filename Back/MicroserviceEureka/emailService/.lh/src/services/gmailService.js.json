{
    "sourceFile": "src/services/gmailService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 62,
            "patches": [
                {
                    "date": 1748481188069,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1748514736152,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -199,10 +199,85 @@\n     labels: response.data.labelIds,\r\n     snippet: response.data.snippet,\r\n   };\r\n };\r\n+const gmailService = require('../services/gmailService');\r\n \r\n+// Récupérer un email complet avec tous ses éléments\r\n+const getFullEmailHandler = async (req, res) => {\r\n+  try {\r\n+    const { accessToken } = req.query;\r\n+    const { emailId } = req.params;\r\n+\r\n+    if (!accessToken || !emailId) {\r\n+      return res.status(400).json({ \r\n+        success: false, \r\n+        error: \"Paramètres manquants (accessToken, emailId)\" \r\n+      });\r\n+    }\r\n+\r\n+    const email = await gmailService.getFullEmail(accessToken, emailId);\r\n+    \r\n+    // Optionnel: Récupérer les pièces jointes complètes si demandé\r\n+    if (req.query.includeAttachments === 'true') {\r\n+      for (const attachment of email.attachments) {\r\n+        attachment.fileData = await gmailService.getAttachment(\r\n+          accessToken, \r\n+          emailId, \r\n+          attachment.body.attachmentId\r\n+        );\r\n+      }\r\n+    }\r\n+\r\n+    res.json({ success: true, data: email });\r\n+  } catch (error) {\r\n+    console.error(\"Erreur récupération email complet:\", error);\r\n+    res.status(500).json({\r\n+      success: false,\r\n+      error: \"Erreur lors de la récupération de l'email\",\r\n+      details: error.message\r\n+    });\r\n+  }\r\n+};\r\n+\r\n+// Récupérer les emails avec aperçu des pièces jointes\r\n+const getEmailsWithAttachmentsHandler = async (req, res) => {\r\n+  try {\r\n+    const { accessToken, maxResults = 10 } = req.query;\r\n+    \r\n+    const emails = await gmailService.getInboxEmails(accessToken, maxResults);\r\n+    const enhancedEmails = await Promise.all(\r\n+      emails.map(async email => {\r\n+        const fullEmail = await gmailService.getFullEmail(accessToken, email.id);\r\n+        return {\r\n+          ...email,\r\n+          hasAttachments: fullEmail.attachments.length > 0,\r\n+          attachmentsPreview: fullEmail.attachments.map(a => ({\r\n+            filename: a.filename,\r\n+            mimeType: a.mimeType,\r\n+            size: a.size\r\n+          }))\r\n+        };\r\n+      })\r\n+    );\r\n+\r\n+    res.json({ success: true, data: enhancedEmails });\r\n+  } catch (error) {\r\n+    console.error(\"Erreur récupération emails avec pièces jointes:\", error);\r\n+    res.status(500).json({\r\n+      success: false,\r\n+      error: \"Erreur lors de la récupération des emails\",\r\n+      details: error.message\r\n+    });\r\n+  }\r\n+};\r\n+\r\n module.exports = {\r\n+  getFullEmailHandler,\r\n+  getEmailsWithAttachmentsHandler,\r\n+  // ... autres handlers existants\r\n+};\r\n+module.exports = {\r\n   sendEmail,\r\n   getSentEmails,\r\n   deleteEmail,\r\n   getDrafts,\r\n"
                },
                {
                    "date": 1748514742068,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -271,13 +271,14 @@\n   }\r\n };\r\n \r\n module.exports = {\r\n-  getFullEmailHandler,\r\n-  getEmailsWithAttachmentsHandler,\r\n+  \r\n   // ... autres handlers existants\r\n };\r\n module.exports = {\r\n+  getFullEmailHandler,\r\n+  getEmailsWithAttachmentsHandler,\r\n   sendEmail,\r\n   getSentEmails,\r\n   deleteEmail,\r\n   getDrafts,\r\n"
                },
                {
                    "date": 1748514777233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -199,86 +199,10 @@\n     labels: response.data.labelIds,\r\n     snippet: response.data.snippet,\r\n   };\r\n };\r\n-const gmailService = require('../services/gmailService');\r\n \r\n-// Récupérer un email complet avec tous ses éléments\r\n-const getFullEmailHandler = async (req, res) => {\r\n-  try {\r\n-    const { accessToken } = req.query;\r\n-    const { emailId } = req.params;\r\n-\r\n-    if (!accessToken || !emailId) {\r\n-      return res.status(400).json({ \r\n-        success: false, \r\n-        error: \"Paramètres manquants (accessToken, emailId)\" \r\n-      });\r\n-    }\r\n-\r\n-    const email = await gmailService.getFullEmail(accessToken, emailId);\r\n-    \r\n-    // Optionnel: Récupérer les pièces jointes complètes si demandé\r\n-    if (req.query.includeAttachments === 'true') {\r\n-      for (const attachment of email.attachments) {\r\n-        attachment.fileData = await gmailService.getAttachment(\r\n-          accessToken, \r\n-          emailId, \r\n-          attachment.body.attachmentId\r\n-        );\r\n-      }\r\n-    }\r\n-\r\n-    res.json({ success: true, data: email });\r\n-  } catch (error) {\r\n-    console.error(\"Erreur récupération email complet:\", error);\r\n-    res.status(500).json({\r\n-      success: false,\r\n-      error: \"Erreur lors de la récupération de l'email\",\r\n-      details: error.message\r\n-    });\r\n-  }\r\n-};\r\n-\r\n-// Récupérer les emails avec aperçu des pièces jointes\r\n-const getEmailsWithAttachmentsHandler = async (req, res) => {\r\n-  try {\r\n-    const { accessToken, maxResults = 10 } = req.query;\r\n-    \r\n-    const emails = await gmailService.getInboxEmails(accessToken, maxResults);\r\n-    const enhancedEmails = await Promise.all(\r\n-      emails.map(async email => {\r\n-        const fullEmail = await gmailService.getFullEmail(accessToken, email.id);\r\n-        return {\r\n-          ...email,\r\n-          hasAttachments: fullEmail.attachments.length > 0,\r\n-          attachmentsPreview: fullEmail.attachments.map(a => ({\r\n-            filename: a.filename,\r\n-            mimeType: a.mimeType,\r\n-            size: a.size\r\n-          }))\r\n-        };\r\n-      })\r\n-    );\r\n-\r\n-    res.json({ success: true, data: enhancedEmails });\r\n-  } catch (error) {\r\n-    console.error(\"Erreur récupération emails avec pièces jointes:\", error);\r\n-    res.status(500).json({\r\n-      success: false,\r\n-      error: \"Erreur lors de la récupération des emails\",\r\n-      details: error.message\r\n-    });\r\n-  }\r\n-};\r\n-\r\n module.exports = {\r\n-  \r\n-  // ... autres handlers existants\r\n-};\r\n-module.exports = {\r\n-  getFullEmailHandler,\r\n-  getEmailsWithAttachmentsHandler,\r\n   sendEmail,\r\n   getSentEmails,\r\n   deleteEmail,\r\n   getDrafts,\r\n"
                },
                {
                    "date": 1748514796798,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -199,10 +199,114 @@\n     labels: response.data.labelIds,\r\n     snippet: response.data.snippet,\r\n   };\r\n };\r\n+// Récupère le contenu complet d'un email avec tous ses éléments\r\n+const getFullEmail = async (accessToken, emailId) => {\r\n+  const oAuth2Client = new google.auth.OAuth2();\r\n+  oAuth2Client.setCredentials({ access_token: accessToken });\r\n+  const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n \r\n+  const res = await gmail.users.messages.get({\r\n+    userId: 'me',\r\n+    id: emailId,\r\n+    format: 'full'\r\n+  });\r\n+\r\n+  return parseEmail(res.data);\r\n+};\r\n+\r\n+// Parse l'email et ses composants\r\n+const parseEmail = (emailData) => {\r\n+  const result = {\r\n+    id: emailData.id,\r\n+    threadId: emailData.threadId,\r\n+    labelIds: emailData.labelIds,\r\n+    snippet: emailData.snippet,\r\n+    internalDate: new Date(parseInt(emailData.internalDate)),\r\n+    headers: {},\r\n+    parts: [],\r\n+    attachments: []\r\n+  };\r\n+\r\n+  // Extraction des headers\r\n+  emailData.payload.headers.forEach(header => {\r\n+    result.headers[header.name.toLowerCase()] = header.value;\r\n+  });\r\n+\r\n+  // Traitement des parties du message\r\n+  if (emailData.payload.parts) {\r\n+    emailData.payload.parts.forEach(part => {\r\n+      const partData = processPart(part);\r\n+      if (partData.isAttachment) {\r\n+        result.attachments.push(partData);\r\n+      } else {\r\n+        result.parts.push(partData);\r\n+      }\r\n+    });\r\n+  } else {\r\n+    // Email sans multipart\r\n+    result.parts.push(processPart(emailData.payload));\r\n+  }\r\n+\r\n+  return result;\r\n+};\r\n+\r\n+// Traite une partie du message\r\n+const processPart = (part) => {\r\n+  const partData = {\r\n+    mimeType: part.mimeType,\r\n+    body: part.body,\r\n+    isAttachment: part.filename && part.filename.length > 0,\r\n+    filename: part.filename || null,\r\n+    size: part.body.size || 0,\r\n+    content: null\r\n+  };\r\n+\r\n+  // Décodage du contenu\r\n+  if (part.body.data) {\r\n+    partData.content = Buffer.from(part.body.data, 'base64');\r\n+    \r\n+    // Conversion en texte/HTML selon le type\r\n+    if (part.mimeType === 'text/plain') {\r\n+      partData.text = partData.content.toString('utf8');\r\n+    } else if (part.mimeType === 'text/html') {\r\n+      partData.html = partData.content.toString('utf8');\r\n+    }\r\n+  }\r\n+\r\n+  // Traitement des sous-parties (pour les emails imbriqués)\r\n+  if (part.parts) {\r\n+    partData.parts = part.parts.map(processPart);\r\n+  }\r\n+\r\n+  return partData;\r\n+};\r\n+\r\n+// Récupère les pièces jointes complètes\r\n+const getAttachment = async (accessToken, emailId, attachmentId) => {\r\n+  const oAuth2Client = new google.auth.OAuth2();\r\n+  oAuth2Client.setCredentials({ access_token: accessToken });\r\n+  const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+\r\n+  const res = await gmail.users.messages.attachments.get({\r\n+    userId: 'me',\r\n+    messageId: emailId,\r\n+    id: attachmentId\r\n+  });\r\n+\r\n+  return {\r\n+    data: Buffer.from(res.data.data, 'base64'),\r\n+    size: res.data.size\r\n+  };\r\n+};\r\n+\r\n module.exports = {\r\n+  getFullEmail,\r\n+  getAttachment,\r\n+  // ... autres fonctions existantes\r\n+};\r\n+module.exports = {\r\n   sendEmail,\r\n   getSentEmails,\r\n   deleteEmail,\r\n   getDrafts,\r\n"
                },
                {
                    "date": 1748514806964,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -299,14 +299,12 @@\n     size: res.data.size\r\n   };\r\n };\r\n \r\n+\r\n module.exports = {\r\n   getFullEmail,\r\n   getAttachment,\r\n-  // ... autres fonctions existantes\r\n-};\r\n-module.exports = {\r\n   sendEmail,\r\n   getSentEmails,\r\n   deleteEmail,\r\n   getDrafts,\r\n"
                },
                {
                    "date": 1748515722786,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,8 +18,9 @@\n \r\n // Envoyer un email\r\n const sendEmail = async (accessToken, emailData) => {\r\n   const gmail = getGmailClient(accessToken);\r\n+  con\r\n   const message = [\r\n     `From: ${emailData.from}`,\r\n     `To: ${emailData.to}`,\r\n     \"Content-Type: text/html; charset=utf-8\",\r\n"
                },
                {
                    "date": 1748515728441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n \r\n // Envoyer un email\r\n const sendEmail = async (accessToken, emailData) => {\r\n   const gmail = getGmailClient(accessToken);\r\n-  con\r\n+  console\r\n   const message = [\r\n     `From: ${emailData.from}`,\r\n     `To: ${emailData.to}`,\r\n     \"Content-Type: text/html; charset=utf-8\",\r\n"
                },
                {
                    "date": 1748515734547,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n \r\n // Envoyer un email\r\n const sendEmail = async (accessToken, emailData) => {\r\n   const gmail = getGmailClient(accessToken);\r\n-  console\r\n+  console.log\r\n   const message = [\r\n     `From: ${emailData.from}`,\r\n     `To: ${emailData.to}`,\r\n     \"Content-Type: text/html; charset=utf-8\",\r\n"
                },
                {
                    "date": 1748515740564,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n \r\n // Envoyer un email\r\n const sendEmail = async (accessToken, emailData) => {\r\n   const gmail = getGmailClient(accessToken);\r\n-  console.log\r\n+  console.log(\"c'est quoin\")\r\n   const message = [\r\n     `From: ${emailData.from}`,\r\n     `To: ${emailData.to}`,\r\n     \"Content-Type: text/html; charset=utf-8\",\r\n"
                },
                {
                    "date": 1748515747737,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n \r\n // Envoyer un email\r\n const sendEmail = async (accessToken, emailData) => {\r\n   const gmail = getGmailClient(accessToken);\r\n-  console.log(\"c'est quoin\")\r\n+  console.log(\"c'est quoi le gmail\",)\r\n   const message = [\r\n     `From: ${emailData.from}`,\r\n     `To: ${emailData.to}`,\r\n     \"Content-Type: text/html; charset=utf-8\",\r\n"
                },
                {
                    "date": 1748518972147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,9 @@\n const { google } = require(\"googleapis\");\r\n const oAuth2Client = require(\"../config/googleAuth\");\r\n \r\n-// Fonction pour obtenir une instance authentifiée de l'API Gmail\r\n+// Helper function to get authenticated Gmail client\r\n const getGmailClient = (accessToken) => {\r\n-  if (!accessToken) {\r\n-    throw new Error(\"Access token manquant pour l'opération Gmail.\");\r\n-  }\r\n-  // Cloner l'objet oAuth2Client pour éviter les modifications globales\r\n   const client = new google.auth.OAuth2(\r\n     oAuth2Client.clientId_,\r\n     oAuth2Client.clientSecret_,\r\n     oAuth2Client.redirectUri_\r\n@@ -15,303 +11,297 @@\n   client.setCredentials({ access_token: accessToken });\r\n   return google.gmail({ version: \"v1\", auth: client });\r\n };\r\n \r\n-// Envoyer un email\r\n+// Helper function to process email parts\r\n+const processEmailPart = (part) => {\r\n+  const partData = {\r\n+    mimeType: part.mimeType,\r\n+    filename: part.filename || null,\r\n+    size: part.body.size || 0,\r\n+    isAttachment: !!part.filename,\r\n+    content: null,\r\n+    headers: {}\r\n+  };\r\n+\r\n+  // Process headers\r\n+  if (part.headers) {\r\n+    part.headers.forEach(header => {\r\n+      partData.headers[header.name.toLowerCase()] = header.value;\r\n+    });\r\n+  }\r\n+\r\n+  // Decode content\r\n+  if (part.body.data) {\r\n+    partData.content = Buffer.from(part.body.data, 'base64');\r\n+    if (part.mimeType === 'text/plain') {\r\n+      partData.text = partData.content.toString('utf8');\r\n+    } else if (part.mimeType === 'text/html') {\r\n+      partData.html = partData.content.toString('utf8');\r\n+    }\r\n+  }\r\n+\r\n+  // Process nested parts\r\n+  if (part.parts) {\r\n+    partData.parts = part.parts.map(processEmailPart);\r\n+  }\r\n+\r\n+  return partData;\r\n+};\r\n+\r\n+// 1. Email Sending with Attachments\r\n const sendEmail = async (accessToken, emailData) => {\r\n   const gmail = getGmailClient(accessToken);\r\n-  console.log(\"c'est quoi le gmail\",)\r\n-  const message = [\r\n+  \r\n+  const messageParts = [\r\n     `From: ${emailData.from}`,\r\n     `To: ${emailData.to}`,\r\n-    \"Content-Type: text/html; charset=utf-8\",\r\n     `Subject: ${emailData.subject}`,\r\n+    `Content-Type: multipart/mixed; boundary=\"mixed_boundary\"`,\r\n     \"\",\r\n-    emailData.body,\r\n-  ].join(\"\\n\");\r\n+    \"--mixed_boundary\",\r\n+    `Content-Type: multipart/alternative; boundary=\"alt_boundary\"`,\r\n+    \"\",\r\n+    \"--alt_boundary\",\r\n+    \"Content-Type: text/plain; charset=utf-8\",\r\n+    \"\",\r\n+    emailData.text || \"\",\r\n+    \"\",\r\n+    \"--alt_boundary\",\r\n+    \"Content-Type: text/html; charset=utf-8\",\r\n+    \"\",\r\n+    emailData.html || \"\",\r\n+    \"\",\r\n+    \"--alt_boundary--\"\r\n+  ];\r\n \r\n-  const encodedMessage = Buffer.from(message)\r\n+  // Add attachments if any\r\n+  if (emailData.attachments && emailData.attachments.length > 0) {\r\n+    emailData.attachments.forEach(attachment => {\r\n+      messageParts.push(\r\n+        \"--mixed_boundary\",\r\n+        `Content-Type: ${attachment.mimeType}`,\r\n+        `Content-Disposition: attachment; filename=\"${attachment.filename}\"`,\r\n+        \"Content-Transfer-Encoding: base64\",\r\n+        \"\",\r\n+        attachment.content.toString('base64'),\r\n+        \"\"\r\n+      );\r\n+    });\r\n+  }\r\n+\r\n+  messageParts.push(\"--mixed_boundary--\");\r\n+  \r\n+  const rawMessage = messageParts.join(\"\\n\");\r\n+  const encodedMessage = Buffer.from(rawMessage)\r\n     .toString(\"base64\")\r\n     .replace(/\\+/g, \"-\")\r\n     .replace(/\\//g, \"_\")\r\n     .replace(/=+$/, \"\");\r\n \r\n   const response = await gmail.users.messages.send({\r\n     userId: \"me\",\r\n-    requestBody: { raw: encodedMessage },\r\n+    requestBody: { raw: encodedMessage }\r\n   });\r\n   return response.data;\r\n };\r\n \r\n-// Récupérer les emails envoyés\r\n-const getSentEmails = async (accessToken, maxResults) => {\r\n+// 2. Get Full Email with All Details\r\n+const getFullEmail = async (accessToken, emailId, includeAttachmentData = false) => {\r\n   const gmail = getGmailClient(accessToken);\r\n-  const response = await gmail.users.messages.list({\r\n+  const response = await gmail.users.messages.get({\r\n     userId: \"me\",\r\n-    labelIds: [\"SENT\"],\r\n-    maxResults: parseInt(maxResults),\r\n+    id: emailId,\r\n+    format: \"full\"\r\n   });\r\n \r\n-  if (!response.data.messages) {\r\n-      return []; // Retourner un tableau vide si aucun message envoyé\r\n-  }\r\n+  const email = {\r\n+    id: response.data.id,\r\n+    threadId: response.data.threadId,\r\n+    labelIds: response.data.labelIds,\r\n+    snippet: response.data.snippet,\r\n+    internalDate: new Date(parseInt(response.data.internalDate)),\r\n+    headers: {},\r\n+    parts: [],\r\n+    attachments: [],\r\n+    isRead: !response.data.labelIds.includes(\"UNREAD\")\r\n+  };\r\n \r\n-  const messages = await Promise.all(\r\n-    response.data.messages.map(async (message) => {\r\n-      const msg = await gmail.users.messages.get({\r\n-        userId: \"me\",\r\n-        id: message.id,\r\n-        format: \"full\",\r\n-      });\r\n-      return {\r\n-        id: msg.data.id,\r\n-        snippet: msg.data.snippet,\r\n-        payload: msg.data.payload,\r\n-        internalDate: msg.data.internalDate,\r\n-        labelIds: msg.data.labelIds,\r\n-        isRead: !msg.data.labelIds.includes(\"UNREAD\"),\r\n-      };\r\n-    })\r\n-  );\r\n-  return messages;\r\n-};\r\n+  // Process headers\r\n+  response.data.payload.headers.forEach(header => {\r\n+    email.headers[header.name.toLowerCase()] = header.value;\r\n+  });\r\n \r\n-// Supprimer un email\r\n-const deleteEmail = async (accessToken, emailId, permanent) => {\r\n-  const gmail = getGmailClient(accessToken);\r\n-  if (permanent) {\r\n-    await gmail.users.messages.delete({\r\n-      userId: \"me\",\r\n-      id: emailId,\r\n+  // Process email parts\r\n+  const processParts = (parts) => {\r\n+    parts.forEach(part => {\r\n+      const processedPart = processEmailPart(part);\r\n+      if (processedPart.isAttachment) {\r\n+        email.attachments.push(processedPart);\r\n+      } else {\r\n+        email.parts.push(processedPart);\r\n+      }\r\n     });\r\n+  };\r\n+\r\n+  if (response.data.payload.parts) {\r\n+    processParts(response.data.payload.parts);\r\n   } else {\r\n-    await gmail.users.messages.trash({\r\n-      userId: \"me\",\r\n-      id: emailId,\r\n-    });\r\n+    processParts([response.data.payload]);\r\n   }\r\n+\r\n+  // Get full attachment data if requested\r\n+  if (includeAttachmentData) {\r\n+    await Promise.all(email.attachments.map(async (attachment) => {\r\n+      if (attachment.body.attachmentId) {\r\n+        const attachmentRes = await gmail.users.messages.attachments.get({\r\n+          userId: \"me\",\r\n+          messageId: emailId,\r\n+          id: attachment.body.attachmentId\r\n+        });\r\n+        attachment.content = Buffer.from(attachmentRes.data.data, 'base64');\r\n+      }\r\n+    }));\r\n+  }\r\n+\r\n+  return email;\r\n };\r\n \r\n-// Récupérer les brouillons\r\n-const getDrafts = async (accessToken, maxResults) => {\r\n+// 3. Get Received Emails\r\n+const getInboxEmails = async (accessToken, maxResults = 20) => {\r\n   const gmail = getGmailClient(accessToken);\r\n-  const response = await gmail.users.drafts.list({\r\n+  const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n-    maxResults: parseInt(maxResults),\r\n+    labelIds: [\"INBOX\"],\r\n+    maxResults: parseInt(maxResults)\r\n   });\r\n \r\n-  if (!response.data.drafts) {\r\n-      return []; // Retourner un tableau vide si aucun brouillon\r\n-  }\r\n+  if (!response.data.messages) return [];\r\n \r\n-  const drafts = await Promise.all(\r\n-    response.data.drafts.map(async (draft) => {\r\n-      const draftDetails = await gmail.users.drafts.get({\r\n-        userId: \"me\",\r\n-        id: draft.id,\r\n-        format: \"full\",\r\n-      });\r\n-      return {\r\n-        id: draft.id,\r\n-        message: draftDetails.data.message,\r\n-      };\r\n+  return Promise.all(\r\n+    response.data.messages.map(async (message) => {\r\n+      return await getFullEmail(accessToken, message.id, false);\r\n     })\r\n   );\r\n-  return drafts;\r\n };\r\n \r\n-// Supprimer un brouillon\r\n-const deleteDraft = async (accessToken, draftId) => {\r\n+// 4. Get Sent Emails\r\n+const getSentEmails = async (accessToken, maxResults = 20) => {\r\n   const gmail = getGmailClient(accessToken);\r\n-  await gmail.users.drafts.delete({\r\n-    userId: \"me\",\r\n-    id: draftId,\r\n-  });\r\n-};\r\n-\r\n-// Restaurer un email depuis la corbeille\r\n-const restoreEmail = async (accessToken, emailId) => {\r\n-  const gmail = getGmailClient(accessToken);\r\n-  await gmail.users.messages.untrash({\r\n-    userId: \"me\",\r\n-    id: emailId,\r\n-  });\r\n-};\r\n-\r\n-// Récupérer les emails entrants\r\n-const getInboxEmails = async (accessToken, maxResults) => {\r\n-  const gmail = getGmailClient(accessToken);\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n-    labelIds: [\"INBOX\"],\r\n-    maxResults: parseInt(maxResults),\r\n+    labelIds: [\"SENT\"],\r\n+    maxResults: parseInt(maxResults)\r\n   });\r\n \r\n-  if (!response.data.messages) {\r\n-      return []; // Retourner un tableau vide si aucun message dans la boîte de réception\r\n-  }\r\n+  if (!response.data.messages) return [];\r\n \r\n-  const emails = await Promise.all(\r\n+  return Promise.all(\r\n     response.data.messages.map(async (message) => {\r\n-      const msg = await gmail.users.messages.get({\r\n-        userId: \"me\",\r\n-        id: message.id,\r\n-        format: \"metadata\",\r\n-        metadataHeaders: [\"From\", \"To\", \"Subject\", \"Date\"],\r\n-      });\r\n-\r\n-      return {\r\n-        id: msg.data.id,\r\n-        from: msg.data.payload.headers.find((h) => h.name === \"From\").value,\r\n-        subject: msg.data.payload.headers.find((h) => h.name === \"Subject\").value,\r\n-        date: msg.data.payload.headers.find((h) => h.name === \"Date\").value,\r\n-        isRead: !msg.data.labelIds.includes(\"UNREAD\"),\r\n-        labels: msg.data.labelIds,\r\n-      };\r\n+      return await getFullEmail(accessToken, message.id, false);\r\n     })\r\n   );\r\n-  return emails;\r\n };\r\n \r\n-// Marquer un email comme lu\r\n+// 5. Delete Email\r\n+const deleteEmail = async (accessToken, emailId, permanent = false) => {\r\n+  const gmail = getGmailClient(accessToken);\r\n+  if (permanent) {\r\n+    await gmail.users.messages.delete({ userId: \"me\", id: emailId });\r\n+  } else {\r\n+    await gmail.users.messages.trash({ userId: \"me\", id: emailId });\r\n+  }\r\n+};\r\n+\r\n+// 6. Mark Email as Read\r\n const markAsRead = async (accessToken, emailId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   await gmail.users.messages.modify({\r\n     userId: \"me\",\r\n     id: emailId,\r\n     requestBody: {\r\n-      removeLabelIds: [\"UNREAD\"],\r\n-    },\r\n+      removeLabelIds: [\"UNREAD\"]\r\n+    }\r\n   });\r\n };\r\n \r\n-// Vérifier si un email a été lu\r\n-const checkEmailReadStatus = async (accessToken, emailId) => {\r\n+// 7. Draft Management\r\n+const createDraft = async (accessToken, draftData) => {\r\n   const gmail = getGmailClient(accessToken);\r\n-  const response = await gmail.users.messages.get({\r\n-    userId: \"me\",\r\n-    id: emailId,\r\n-    format: \"metadata\",\r\n-    metadataHeaders: [\"From\", \"To\", \"Subject\"],\r\n-  });\r\n+  \r\n+  const messageParts = [\r\n+    `From: ${draftData.from}`,\r\n+    `To: ${draftData.to}`,\r\n+    `Subject: ${draftData.subject}`,\r\n+    \"Content-Type: text/html; charset=utf-8\",\r\n+    \"\",\r\n+    draftData.body\r\n+  ];\r\n \r\n-  const isRead = !response.data.labelIds.includes(\"UNREAD\");\r\n-  return {\r\n-    isRead,\r\n-    labels: response.data.labelIds,\r\n-    snippet: response.data.snippet,\r\n-  };\r\n-};\r\n-// Récupère le contenu complet d'un email avec tous ses éléments\r\n-const getFullEmail = async (accessToken, emailId) => {\r\n-  const oAuth2Client = new google.auth.OAuth2();\r\n-  oAuth2Client.setCredentials({ access_token: accessToken });\r\n-  const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n+  const rawMessage = messageParts.join(\"\\n\");\r\n+  const encodedMessage = Buffer.from(rawMessage)\r\n+    .toString(\"base64\")\r\n+    .replace(/\\+/g, \"-\")\r\n+    .replace(/\\//g, \"_\")\r\n+    .replace(/=+$/, \"\");\r\n \r\n-  const res = await gmail.users.messages.get({\r\n-    userId: 'me',\r\n-    id: emailId,\r\n-    format: 'full'\r\n+  const response = await gmail.users.drafts.create({\r\n+    userId: \"me\",\r\n+    requestBody: {\r\n+      message: { raw: encodedMessage }\r\n+    }\r\n   });\r\n-\r\n-  return parseEmail(res.data);\r\n+  return response.data;\r\n };\r\n \r\n-// Parse l'email et ses composants\r\n-const parseEmail = (emailData) => {\r\n-  const result = {\r\n-    id: emailData.id,\r\n-    threadId: emailData.threadId,\r\n-    labelIds: emailData.labelIds,\r\n-    snippet: emailData.snippet,\r\n-    internalDate: new Date(parseInt(emailData.internalDate)),\r\n-    headers: {},\r\n-    parts: [],\r\n-    attachments: []\r\n-  };\r\n-\r\n-  // Extraction des headers\r\n-  emailData.payload.headers.forEach(header => {\r\n-    result.headers[header.name.toLowerCase()] = header.value;\r\n+const getDrafts = async (accessToken, maxResults = 10) => {\r\n+  const gmail = getGmailClient(accessToken);\r\n+  const response = await gmail.users.drafts.list({\r\n+    userId: \"me\",\r\n+    maxResults: parseInt(maxResults)\r\n   });\r\n \r\n-  // Traitement des parties du message\r\n-  if (emailData.payload.parts) {\r\n-    emailData.payload.parts.forEach(part => {\r\n-      const partData = processPart(part);\r\n-      if (partData.isAttachment) {\r\n-        result.attachments.push(partData);\r\n-      } else {\r\n-        result.parts.push(partData);\r\n-      }\r\n-    });\r\n-  } else {\r\n-    // Email sans multipart\r\n-    result.parts.push(processPart(emailData.payload));\r\n-  }\r\n+  if (!response.data.drafts) return [];\r\n \r\n-  return result;\r\n+  return Promise.all(\r\n+    response.data.drafts.map(async (draft) => {\r\n+      const draftDetails = await gmail.users.drafts.get({\r\n+        userId: \"me\",\r\n+        id: draft.id\r\n+      });\r\n+      return {\r\n+        id: draft.id,\r\n+        message: await getFullEmail(accessToken, draftDetails.data.message.id)\r\n+      };\r\n+    })\r\n+  );\r\n };\r\n \r\n-// Traite une partie du message\r\n-const processPart = (part) => {\r\n-  const partData = {\r\n-    mimeType: part.mimeType,\r\n-    body: part.body,\r\n-    isAttachment: part.filename && part.filename.length > 0,\r\n-    filename: part.filename || null,\r\n-    size: part.body.size || 0,\r\n-    content: null\r\n-  };\r\n-\r\n-  // Décodage du contenu\r\n-  if (part.body.data) {\r\n-    partData.content = Buffer.from(part.body.data, 'base64');\r\n-    \r\n-    // Conversion en texte/HTML selon le type\r\n-    if (part.mimeType === 'text/plain') {\r\n-      partData.text = partData.content.toString('utf8');\r\n-    } else if (part.mimeType === 'text/html') {\r\n-      partData.html = partData.content.toString('utf8');\r\n-    }\r\n-  }\r\n-\r\n-  // Traitement des sous-parties (pour les emails imbriqués)\r\n-  if (part.parts) {\r\n-    partData.parts = part.parts.map(processPart);\r\n-  }\r\n-\r\n-  return partData;\r\n+const deleteDraft = async (accessToken, draftId) => {\r\n+  const gmail = getGmailClient(accessToken);\r\n+  await gmail.users.drafts.delete({\r\n+    userId: \"me\",\r\n+    id: draftId\r\n+  });\r\n };\r\n \r\n-// Récupère les pièces jointes complètes\r\n-const getAttachment = async (accessToken, emailId, attachmentId) => {\r\n-  const oAuth2Client = new google.auth.OAuth2();\r\n-  oAuth2Client.setCredentials({ access_token: accessToken });\r\n-  const gmail = google.gmail({ version: 'v1', auth: oAuth2Client });\r\n-\r\n-  const res = await gmail.users.messages.attachments.get({\r\n-    userId: 'me',\r\n-    messageId: emailId,\r\n-    id: attachmentId\r\n+const sendDraft = async (accessToken, draftId) => {\r\n+  const gmail = getGmailClient(accessToken);\r\n+  const response = await gmail.users.drafts.send({\r\n+    userId: \"me\",\r\n+    requestBody: { id: draftId }\r\n   });\r\n-\r\n-  return {\r\n-    data: Buffer.from(res.data.data, 'base64'),\r\n-    size: res.data.size\r\n-  };\r\n+  return response.data;\r\n };\r\n \r\n-\r\n module.exports = {\r\n+  sendEmail,\r\n   getFullEmail,\r\n-  getAttachment,\r\n-  sendEmail,\r\n+  getInboxEmails,\r\n   getSentEmails,\r\n   deleteEmail,\r\n+  markAsRead,\r\n+  createDraft,\r\n   getDrafts,\r\n   deleteDraft,\r\n-  restoreEmail,\r\n-  getInboxEmails,\r\n-  markAsRead,\r\n-  checkEmailReadStatus,\r\n-};\r\n+  sendDraft\r\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748526060461,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n const { google } = require(\"googleapis\");\r\n const oAuth2Client = require(\"../config/googleAuth\");\r\n-\r\n+const fileStorage = require('../utils/fileStorage');\r\n // Helper function to get authenticated Gmail client\r\n const getGmailClient = (accessToken) => {\r\n   const client = new google.auth.OAuth2(\r\n     oAuth2Client.clientId_,\r\n"
                },
                {
                    "date": 1748526195064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -166,23 +166,46 @@\n   return email;\r\n };\r\n \r\n // 3. Get Received Emails\r\n-const getInboxEmails = async (accessToken, maxResults = 20) => {\r\n+const getInboxEmails = async (accessToken, maxResults = 20, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n+  \r\n+  // Charger les emails déjà sauvegardés\r\n+  const savedEmails = userId ? fileStorage.loadEmails(userId) : [];\r\n+  const lastSavedEmailId = savedEmails.length > 0 ? savedEmails[0].id : null;\r\n+\r\n+  // Récupérer les emails depuis Gmail\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"INBOX\"],\r\n     maxResults: parseInt(maxResults)\r\n   });\r\n \r\n   if (!response.data.messages) return [];\r\n \r\n-  return Promise.all(\r\n-    response.data.messages.map(async (message) => {\r\n+  // Filtrer pour ne garder que les nouveaux emails\r\n+  const newEmails = lastSavedEmailId \r\n+    ? response.data.messages.filter(msg => {\r\n+        const isNew = !savedEmails.some(e => e.id === msg.id);\r\n+        return isNew;\r\n+      })\r\n+    : response.data.messages;\r\n+\r\n+  // Récupérer les détails complets des nouveaux emails\r\n+  const fullEmails = await Promise.all(\r\n+    newEmails.map(async (message) => {\r\n       return await getFullEmail(accessToken, message.id, false);\r\n     })\r\n   );\r\n+\r\n+  // Sauvegarder les nouveaux emails\r\n+  if (userId && fullEmails.length > 0) {\r\n+    const updatedEmails = [...fullEmails, ...savedEmails];\r\n+    fileStorage.saveEmails(userId, updatedEmails);\r\n+  }\r\n+\r\n+  return fullEmails;\r\n };\r\n \r\n // 4. Get Sent Emails\r\n const getSentEmails = async (accessToken, maxResults = 20) => {\r\n"
                },
                {
                    "date": 1748526252653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -225,17 +225,22 @@\n   );\r\n };\r\n \r\n // 5. Delete Email\r\n-const deleteEmail = async (accessToken, emailId, permanent = false) => {\r\n+const deleteEmail = async (accessToken, emailId, permanent = false, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   if (permanent) {\r\n     await gmail.users.messages.delete({ userId: \"me\", id: emailId });\r\n   } else {\r\n     await gmail.users.messages.trash({ userId: \"me\", id: emailId });\r\n   }\r\n+  \r\n+  if (userId) {\r\n+    fileStorage.deleteEmailFromFile(userId, emailId);\r\n+  }\r\n };\r\n \r\n+\r\n // 6. Mark Email as Read\r\n const markAsRead = async (accessToken, emailId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   await gmail.users.messages.modify({\r\n"
                },
                {
                    "date": 1748526292299,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -277,8 +277,12 @@\n     requestBody: {\r\n       message: { raw: encodedMessage }\r\n     }\r\n   });\r\n+  if (userId && response.data) {\r\n+    fileStorage.saveDraft(userId, response.data.id, response.data);\r\n+  }\r\n+  \r\n   return response.data;\r\n };\r\n \r\n const getDrafts = async (accessToken, maxResults = 10) => {\r\n"
                },
                {
                    "date": 1748526361128,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -285,8 +285,17 @@\n   return response.data;\r\n };\r\n \r\n const getDrafts = async (accessToken, maxResults = 10) => {\r\n+  if (userId) {\r\n+    // Charger depuis les fichiers si userId est fourni\r\n+    const { draftsDir } = fileStorage.ensureUserDir(userId);\r\n+    const draftFiles = fs.readdirSync(draftsDir);\r\n+    return draftFiles.slice(0, maxResults).map(file => {\r\n+      const draftId = file.replace('.json', '');\r\n+      return fileStorage.loadDraft(userId, draftId);\r\n+    });\r\n+  } else {\r\n   const gmail = getGmailClient(accessToken);\r\n   const response = await gmail.users.drafts.list({\r\n     userId: \"me\",\r\n     maxResults: parseInt(maxResults)\r\n"
                },
                {
                    "date": 1748526374704,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -313,9 +313,9 @@\n         id: draft.id,\r\n         message: await getFullEmail(accessToken, draftDetails.data.message.id)\r\n       };\r\n     })\r\n-  );\r\n+  );}\r\n };\r\n \r\n const deleteDraft = async (accessToken, draftId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n"
                },
                {
                    "date": 1748526422004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -322,8 +322,9 @@\n   await gmail.users.drafts.delete({\r\n     userId: \"me\",\r\n     id: draftId\r\n   });\r\n+  \r\n };\r\n \r\n const sendDraft = async (accessToken, draftId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n"
                },
                {
                    "date": 1748528965066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n const { google } = require(\"googleapis\");\r\n const oAuth2Client = require(\"../config/googleAuth\");\r\n-const fileStorage = require('../utils/fileStorage');\r\n+const fileStorage = require('../utils/fileStorageService');\r\n // Helper function to get authenticated Gmail client\r\n const getGmailClient = (accessToken) => {\r\n   const client = new google.auth.OAuth2(\r\n     oAuth2Client.clientId_,\r\n@@ -322,9 +322,11 @@\n   await gmail.users.drafts.delete({\r\n     userId: \"me\",\r\n     id: draftId\r\n   });\r\n-  \r\n+  if (userId) {\r\n+    fileStorage.deleteDraftFile(userId, draftId);\r\n+  }\r\n };\r\n \r\n const sendDraft = async (accessToken, draftId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n"
                },
                {
                    "date": 1748533558368,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n const { google } = require(\"googleapis\");\r\n const oAuth2Client = require(\"../config/googleAuth\");\r\n-const fileStorage = require('../utils/fileStorageService');\r\n+const fileStorage = require('../utils/fileStorage');\r\n // Helper function to get authenticated Gmail client\r\n const getGmailClient = (accessToken) => {\r\n   const client = new google.auth.OAuth2(\r\n     oAuth2Client.clientId_,\r\n"
                },
                {
                    "date": 1748533814652,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,9 +105,9 @@\n   return response.data;\r\n };\r\n \r\n // 2. Get Full Email with All Details\r\n-const getFullEmail = async (accessToken, emailId, includeAttachmentData = false) => {\r\n+const getFullEmail = async (accessToken, emailId, includeAttachmentData = false, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   const response = await gmail.users.messages.get({\r\n     userId: \"me\",\r\n     id: emailId,\r\n@@ -162,8 +162,21 @@\n       }\r\n     }));\r\n   }\r\n \r\n+  // Determine folder based on labels\r\n+  let folder = 'inbox';\r\n+  if (response.data.labelIds.includes('SENT')) {\r\n+    folder = 'sent';\r\n+  } else if (response.data.labelIds.includes('DRAFT')) {\r\n+    folder = 'drafts';\r\n+  }\r\n+\r\n+  // Save to storage\r\n+  if (userId) {\r\n+    emailStorage.saveEmail(userId, email, folder);\r\n+  }\r\n+\r\n   return email;\r\n };\r\n \r\n // 3. Get Received Emails\r\n"
                },
                {
                    "date": 1748533838898,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -182,43 +182,41 @@\n // 3. Get Received Emails\r\n const getInboxEmails = async (accessToken, maxResults = 20, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n-  // Charger les emails déjà sauvegardés\r\n-  const savedEmails = userId ? fileStorage.loadEmails(userId) : [];\r\n-  const lastSavedEmailId = savedEmails.length > 0 ? savedEmails[0].id : null;\r\n-\r\n-  // Récupérer les emails depuis Gmail\r\n+  // First get emails from storage\r\n+  const storedEmails = emailStorage.getEmailsFromFolder(userId, 'inbox');\r\n+  \r\n+  // Then get from Gmail API to check for new emails\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"INBOX\"],\r\n     maxResults: parseInt(maxResults)\r\n   });\r\n \r\n-  if (!response.data.messages) return [];\r\n+  if (!response.data.messages) return storedEmails;\r\n \r\n-  // Filtrer pour ne garder que les nouveaux emails\r\n-  const newEmails = lastSavedEmailId \r\n-    ? response.data.messages.filter(msg => {\r\n-        const isNew = !savedEmails.some(e => e.id === msg.id);\r\n-        return isNew;\r\n-      })\r\n-    : response.data.messages;\r\n+  // Get only new emails that aren't in storage\r\n+  const newEmails = response.data.messages.filter(\r\n+    message => !storedEmails.some(e => e.id === message.id)\r\n+  );\r\n \r\n-  // Récupérer les détails complets des nouveaux emails\r\n-  const fullEmails = await Promise.all(\r\n+  // Fetch and store new emails\r\n+  await Promise.all(\r\n     newEmails.map(async (message) => {\r\n-      return await getFullEmail(accessToken, message.id, false);\r\n+      await getFullEmail(accessToken, message.id, false, userId);\r\n     })\r\n   );\r\n \r\n-  // Sauvegarder les nouveaux emails\r\n-  if (userId && fullEmails.length > 0) {\r\n-    const updatedEmails = [...fullEmails, ...savedEmails];\r\n-    fileStorage.saveEmails(userId, updatedEmails);\r\n-  }\r\n+  // Return combined list (sorted by date)\r\n+  const allEmails = [\r\n+    ...storedEmails,\r\n+    ...(await Promise.all(\r\n+      newEmails.map(message => getFullEmail(accessToken, message.id, false, userId))\r\n+    )\r\n+  ].sort((a, b) => new Date(b.internalDate) - new Date(a.internalDate));\r\n \r\n-  return fullEmails;\r\n+  return allEmails.slice(0, maxResults);\r\n };\r\n \r\n // 4. Get Sent Emails\r\n const getSentEmails = async (accessToken, maxResults = 20) => {\r\n"
                },
                {
                    "date": 1748533852580,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -210,9 +210,9 @@\n   // Return combined list (sorted by date)\r\n   const allEmails = [\r\n     ...storedEmails,\r\n     ...(await Promise.all(\r\n-      newEmails.map(message => getFullEmail(accessToken, message.id, false, userId))\r\n+      newEmails.map(message => getFullEmail(accessToken, message.id, false, userId)))\r\n     )\r\n   ].sort((a, b) => new Date(b.internalDate) - new Date(a.internalDate));\r\n \r\n   return allEmails.slice(0, maxResults);\r\n"
                },
                {
                    "date": 1748533880735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -218,23 +218,39 @@\n   return allEmails.slice(0, maxResults);\r\n };\r\n \r\n // 4. Get Sent Emails\r\n-const getSentEmails = async (accessToken, maxResults = 20) => {\r\n+const getSentEmails = async (accessToken, maxResults = 20, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n+  \r\n+  const storedEmails = emailStorage.getEmailsFromFolder(userId, 'sent');\r\n+  \r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"SENT\"],\r\n     maxResults: parseInt(maxResults)\r\n   });\r\n \r\n-  if (!response.data.messages) return [];\r\n+  if (!response.data.messages) return storedEmails;\r\n \r\n-  return Promise.all(\r\n-    response.data.messages.map(async (message) => {\r\n-      return await getFullEmail(accessToken, message.id, false);\r\n+  const newEmails = response.data.messages.filter(\r\n+    message => !storedEmails.some(e => e.id === message.id)\r\n+  );\r\n+\r\n+  await Promise.all(\r\n+    newEmails.map(async (message) => {\r\n+      await getFullEmail(accessToken, message.id, false, userId);\r\n     })\r\n   );\r\n+\r\n+  const allEmails = [\r\n+    ...storedEmails,\r\n+    ...(await Promise.all(\r\n+      newEmails.map(message => getFullEmail(accessToken, message.id, false, userId))\r\n+    ))\r\n+  ].sort((a, b) => new Date(b.internalDate) - new Date(a.internalDate));\r\n+\r\n+  return allEmails.slice(0, maxResults);\r\n };\r\n \r\n // 5. Delete Email\r\n const deleteEmail = async (accessToken, emailId, permanent = false, userId) => {\r\n"
                },
                {
                    "date": 1748533895084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -254,16 +254,28 @@\n \r\n // 5. Delete Email\r\n const deleteEmail = async (accessToken, emailId, permanent = false, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n+  \r\n+  // First determine the folder by checking where the email exists\r\n+  let folder = null;\r\n+  if (emailStorage.emailExists(userId, emailId, 'inbox')) {\r\n+    folder = 'inbox';\r\n+  } else if (emailStorage.emailExists(userId, emailId, 'sent')) {\r\n+    folder = 'sent';\r\n+  } else if (emailStorage.emailExists(userId, emailId, 'drafts')) {\r\n+    folder = 'drafts';\r\n+  }\r\n+\r\n   if (permanent) {\r\n     await gmail.users.messages.delete({ userId: \"me\", id: emailId });\r\n   } else {\r\n     await gmail.users.messages.trash({ userId: \"me\", id: emailId });\r\n   }\r\n-  \r\n-  if (userId) {\r\n-    fileStorage.deleteEmailFromFile(userId, emailId);\r\n+\r\n+  // Delete from storage if it exists\r\n+  if (folder) {\r\n+    emailStorage.deleteEmail(userId, emailId, folder);\r\n   }\r\n };\r\n \r\n \r\n"
                },
                {
                    "date": 1748533955700,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -101,8 +101,9 @@\n   const response = await gmail.users.messages.send({\r\n     userId: \"me\",\r\n     requestBody: { raw: encodedMessage }\r\n   });\r\n+  \r\n   return response.data;\r\n };\r\n \r\n // 2. Get Full Email with All Details\r\n"
                },
                {
                    "date": 1748533987606,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -101,9 +101,15 @@\n   const response = await gmail.users.messages.send({\r\n     userId: \"me\",\r\n     requestBody: { raw: encodedMessage }\r\n   });\r\n+   // Get the full sent email and save to storage\r\n+  if (userId) {\r\n+    const sentEmail = await getFullEmail(accessToken, result.data.id, false, userId);\r\n+    emailStorage.saveEmail(userId, sentEmail, 'sent');\r\n+  }\r\n   \r\n+  return result.data;\r\n   return response.data;\r\n };\r\n \r\n // 2. Get Full Email with All Details\r\n"
                },
                {
                    "date": 1748533993384,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -108,9 +108,9 @@\n     emailStorage.saveEmail(userId, sentEmail, 'sent');\r\n   }\r\n   \r\n   return result.data;\r\n-  return response.data;\r\n+\r\n };\r\n \r\n // 2. Get Full Email with All Details\r\n const getFullEmail = async (accessToken, emailId, includeAttachmentData = false, userId) => {\r\n"
                },
                {
                    "date": 1748534050180,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -323,10 +323,11 @@\n     requestBody: {\r\n       message: { raw: encodedMessage }\r\n     }\r\n   });\r\n-  if (userId && response.data) {\r\n-    fileStorage.saveDraft(userId, response.data.id, response.data);\r\n+  if (userId) {\r\n+    const draftEmail = await getFullEmail(accessToken, response.data.message.id, false, userId);\r\n+    emailStorage.saveEmail(userId, draftEmail, 'drafts');\r\n   }\r\n   \r\n   return response.data;\r\n };\r\n"
                },
                {
                    "date": 1748534115364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -331,38 +331,56 @@\n   \r\n   return response.data;\r\n };\r\n \r\n-const getDrafts = async (accessToken, maxResults = 10) => {\r\n-  if (userId) {\r\n-    // Charger depuis les fichiers si userId est fourni\r\n-    const { draftsDir } = fileStorage.ensureUserDir(userId);\r\n-    const draftFiles = fs.readdirSync(draftsDir);\r\n-    return draftFiles.slice(0, maxResults).map(file => {\r\n-      const draftId = file.replace('.json', '');\r\n-      return fileStorage.loadDraft(userId, draftId);\r\n-    });\r\n-  } else {\r\n+const getDrafts = async (accessToken, maxResults = 10, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n+  \r\n+  // First get from storage\r\n+  const storedDrafts = emailStorage.getEmailsFromFolder(userId, 'drafts');\r\n+  \r\n+  // Then get from API to check for new drafts\r\n   const response = await gmail.users.drafts.list({\r\n     userId: \"me\",\r\n     maxResults: parseInt(maxResults)\r\n   });\r\n \r\n-  if (!response.data.drafts) return [];\r\n+  if (!response.data.drafts) return storedDrafts;\r\n \r\n-  return Promise.all(\r\n-    response.data.drafts.map(async (draft) => {\r\n+  // Get only new drafts\r\n+  const newDrafts = response.data.drafts.filter(\r\n+    draft => !storedDrafts.some(d => d.id === draft.id)\r\n+  );\r\n+\r\n+  // Fetch and store new drafts\r\n+  await Promise.all(\r\n+    newDrafts.map(async (draft) => {\r\n       const draftDetails = await gmail.users.drafts.get({\r\n         userId: \"me\",\r\n         id: draft.id\r\n       });\r\n-      return {\r\n-        id: draft.id,\r\n-        message: await getFullEmail(accessToken, draftDetails.data.message.id)\r\n-      };\r\n+      await getFullEmail(accessToken, draftDetails.data.message.id, false, userId);\r\n     })\r\n-  );}\r\n+  );\r\n+\r\n+  // Return combined list\r\n+  const allDrafts = [\r\n+    ...storedDrafts,\r\n+    ...(await Promise.all(\r\n+      newDrafts.map(async (draft) => {\r\n+        const draftDetails = await gmail.users.drafts.get({\r\n+          userId: \"me\",\r\n+          id: draft.id\r\n+        });\r\n+        return {\r\n+          id: draft.id,\r\n+          message: await getFullEmail(accessToken, draftDetails.data.message.id, false, userId)\r\n+        };\r\n+      })\r\n+    ))\r\n+  ].sort((a, b) => new Date(b.message.internalDate) - new Date(a.message.internalDate));\r\n+\r\n+  return allDrafts.slice(0, maxResults);\r\n };\r\n \r\n const deleteDraft = async (accessToken, draftId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n"
                },
                {
                    "date": 1748534148324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -381,17 +381,18 @@\n \r\n   return allDrafts.slice(0, maxResults);\r\n };\r\n \r\n-const deleteDraft = async (accessToken, draftId) => {\r\n+const deleteDraft = async (accessToken, draftId, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n+  \r\n   await gmail.users.drafts.delete({\r\n     userId: \"me\",\r\n     id: draftId\r\n   });\r\n-  if (userId) {\r\n-    fileStorage.deleteDraftFile(userId, draftId);\r\n-  }\r\n+  \r\n+  // Delete from storage\r\n+  emailStorage.deleteEmail(userId, draftId, 'drafts');\r\n };\r\n \r\n const sendDraft = async (accessToken, draftId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n"
                },
                {
                    "date": 1748534168485,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -393,17 +393,38 @@\n   // Delete from storage\r\n   emailStorage.deleteEmail(userId, draftId, 'drafts');\r\n };\r\n \r\n-const sendDraft = async (accessToken, draftId) => {\r\n+const sendDraft = async (accessToken, draftId, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n+  \r\n   const response = await gmail.users.drafts.send({\r\n     userId: \"me\",\r\n     requestBody: { id: draftId }\r\n   });\r\n+  \r\n+  if (userId) {\r\n+    // Delete from drafts\r\n+    emailStorage.deleteEmail(userId, draftId, 'drafts');\r\n+    // Save to sent\r\n+    const sentEmail = await getFullEmail(accessToken, response.data.id, false, userId);\r\n+    emailStorage.saveEmail(userId, sentEmail, 'sent');\r\n+  }\r\n+  \r\n   return response.data;\r\n };\r\n \r\n+// Add a new function to get email from storage\r\n+const getEmailFromStorage = (userId, emailId) => {\r\n+  // Check in all folders\r\n+  const folders = ['inbox', 'sent', 'drafts'];\r\n+  for (const folder of folders) {\r\n+    const email = emailStorage.getEmailFromFolder(userId, emailId, folder);\r\n+    if (email) return email;\r\n+  }\r\n+  return null;\r\n+};\r\n+\r\n module.exports = {\r\n   sendEmail,\r\n   getFullEmail,\r\n   getInboxEmails,\r\n"
                },
                {
                    "date": 1748534179579,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -424,15 +424,16 @@\n   return null;\r\n };\r\n \r\n module.exports = {\r\n-  sendEmail,\r\n+ sendEmail,\r\n   getFullEmail,\r\n   getInboxEmails,\r\n   getSentEmails,\r\n   deleteEmail,\r\n   markAsRead,\r\n   createDraft,\r\n   getDrafts,\r\n   deleteDraft,\r\n-  sendDraft\r\n+  sendDraft,\r\n+  getEmailFromStorage\r\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1748535993423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n   return partData;\r\n };\r\n \r\n // 1. Email Sending with Attachments\r\n-const sendEmail = async (accessToken, emailData) => {\r\n+const sendEmail = async (accessToken, emailData,userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   const messageParts = [\r\n     `From: ${emailData.from}`,\r\n"
                },
                {
                    "date": 1748536096116,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,9 +104,9 @@\n   });\r\n    // Get the full sent email and save to storage\r\n   if (userId) {\r\n     const sentEmail = await getFullEmail(accessToken, result.data.id, false, userId);\r\n-    emailStorage.saveEmail(userId, sentEmail, 'sent');\r\n+    fileStorage.saveEmail(userId, sentEmail, 'sent');\r\n   }\r\n   \r\n   return result.data;\r\n \r\n@@ -179,9 +179,9 @@\n   }\r\n \r\n   // Save to storage\r\n   if (userId) {\r\n-    emailStorage.saveEmail(userId, email, folder);\r\n+    fileStorage.saveEmail(userId, email, folder);\r\n   }\r\n \r\n   return email;\r\n };\r\n@@ -190,9 +190,9 @@\n const getInboxEmails = async (accessToken, maxResults = 20, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   // First get emails from storage\r\n-  const storedEmails = emailStorage.getEmailsFromFolder(userId, 'inbox');\r\n+  const storedEmails = fileStorage.getEmailsFromFolder(userId, 'inbox');\r\n   \r\n   // Then get from Gmail API to check for new emails\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n@@ -228,9 +228,9 @@\n // 4. Get Sent Emails\r\n const getSentEmails = async (accessToken, maxResults = 20, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n-  const storedEmails = emailStorage.getEmailsFromFolder(userId, 'sent');\r\n+  const storedEmails = fileStorage.getEmailsFromFolder(userId, 'sent');\r\n   \r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"SENT\"],\r\n@@ -264,13 +264,13 @@\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   // First determine the folder by checking where the email exists\r\n   let folder = null;\r\n-  if (emailStorage.emailExists(userId, emailId, 'inbox')) {\r\n+  if (fileStorage.emailExists(userId, emailId, 'inbox')) {\r\n     folder = 'inbox';\r\n-  } else if (emailStorage.emailExists(userId, emailId, 'sent')) {\r\n+  } else if (fileStorage.emailExists(userId, emailId, 'sent')) {\r\n     folder = 'sent';\r\n-  } else if (emailStorage.emailExists(userId, emailId, 'drafts')) {\r\n+  } else if (fileStorage.emailExists(userId, emailId, 'drafts')) {\r\n     folder = 'drafts';\r\n   }\r\n \r\n   if (permanent) {\r\n@@ -280,9 +280,9 @@\n   }\r\n \r\n   // Delete from storage if it exists\r\n   if (folder) {\r\n-    emailStorage.deleteEmail(userId, emailId, folder);\r\n+    fileStorage.deleteEmail(userId, emailId, folder);\r\n   }\r\n };\r\n \r\n \r\n@@ -325,9 +325,9 @@\n     }\r\n   });\r\n   if (userId) {\r\n     const draftEmail = await getFullEmail(accessToken, response.data.message.id, false, userId);\r\n-    emailStorage.saveEmail(userId, draftEmail, 'drafts');\r\n+    fileStorage.saveEmail(userId, draftEmail, 'drafts');\r\n   }\r\n   \r\n   return response.data;\r\n };\r\n@@ -335,9 +335,9 @@\n const getDrafts = async (accessToken, maxResults = 10, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   // First get from storage\r\n-  const storedDrafts = emailStorage.getEmailsFromFolder(userId, 'drafts');\r\n+  const storedDrafts = fileStorage.getEmailsFromFolder(userId, 'drafts');\r\n   \r\n   // Then get from API to check for new drafts\r\n   const response = await gmail.users.drafts.list({\r\n     userId: \"me\",\r\n@@ -390,9 +390,9 @@\n     id: draftId\r\n   });\r\n   \r\n   // Delete from storage\r\n-  emailStorage.deleteEmail(userId, draftId, 'drafts');\r\n+  fileStorage.deleteEmail(userId, draftId, 'drafts');\r\n };\r\n \r\n const sendDraft = async (accessToken, draftId, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n@@ -403,12 +403,12 @@\n   });\r\n   \r\n   if (userId) {\r\n     // Delete from drafts\r\n-    emailStorage.deleteEmail(userId, draftId, 'drafts');\r\n+    fileStorage.deleteEmail(userId, draftId, 'drafts');\r\n     // Save to sent\r\n     const sentEmail = await getFullEmail(accessToken, response.data.id, false, userId);\r\n-    emailStorage.saveEmail(userId, sentEmail, 'sent');\r\n+    fileStorage.saveEmail(userId, sentEmail, 'sent');\r\n   }\r\n   \r\n   return response.data;\r\n };\r\n@@ -417,9 +417,9 @@\n const getEmailFromStorage = (userId, emailId) => {\r\n   // Check in all folders\r\n   const folders = ['inbox', 'sent', 'drafts'];\r\n   for (const folder of folders) {\r\n-    const email = emailStorage.getEmailFromFolder(userId, emailId, folder);\r\n+    const email = fileStorage.getEmailFromFolder(userId, emailId, folder);\r\n     if (email) return email;\r\n   }\r\n   return null;\r\n };\r\n"
                },
                {
                    "date": 1748536126169,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -107,9 +107,9 @@\n     const sentEmail = await getFullEmail(accessToken, result.data.id, false, userId);\r\n     fileStorage.saveEmail(userId, sentEmail, 'sent');\r\n   }\r\n   \r\n-  return result.data;\r\n+  return response.data;\r\n \r\n };\r\n \r\n // 2. Get Full Email with All Details\r\n"
                },
                {
                    "date": 1748536346033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -103,9 +103,9 @@\n     requestBody: { raw: encodedMessage }\r\n   });\r\n    // Get the full sent email and save to storage\r\n   if (userId) {\r\n-    const sentEmail = await getFullEmail(accessToken, result.data.id, false, userId);\r\n+    const sentEmail = await getFullEmail(accessToken, response.data.id, false, userId);\r\n     fileStorage.saveEmail(userId, sentEmail, 'sent');\r\n   }\r\n   \r\n   return response.data;\r\n"
                },
                {
                    "date": 1748536385680,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n   return partData;\r\n };\r\n \r\n // 1. Email Sending with Attachments\r\n-const sendEmail = async (accessToken, emailData,userId) => {\r\n+const sendEmail = async (accessToken, emailData, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   const messageParts = [\r\n     `From: ${emailData.from}`,\r\n@@ -101,16 +101,16 @@\n   const response = await gmail.users.messages.send({\r\n     userId: \"me\",\r\n     requestBody: { raw: encodedMessage }\r\n   });\r\n-   // Get the full sent email and save to storage\r\n+\r\n+  // Get the full sent email and save to storage\r\n   if (userId) {\r\n     const sentEmail = await getFullEmail(accessToken, response.data.id, false, userId);\r\n     fileStorage.saveEmail(userId, sentEmail, 'sent');\r\n   }\r\n   \r\n   return response.data;\r\n-\r\n };\r\n \r\n // 2. Get Full Email with All Details\r\n const getFullEmail = async (accessToken, emailId, includeAttachmentData = false, userId) => {\r\n"
                },
                {
                    "date": 1748540455521,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -340,8 +340,9 @@\n   \r\n   // Then get from API to check for new drafts\r\n   const response = await gmail.users.drafts.list({\r\n     userId: \"me\",\r\n+     labelIds: [\"SENT\"],\r\n     maxResults: parseInt(maxResults)\r\n   });\r\n \r\n   if (!response.data.drafts) return storedDrafts;\r\n"
                },
                {
                    "date": 1748540561263,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -340,9 +340,9 @@\n   \r\n   // Then get from API to check for new drafts\r\n   const response = await gmail.users.drafts.list({\r\n     userId: \"me\",\r\n-     labelIds: [\"SENT\"],\r\n+     labelIds: [\"DRAFT\"],\r\n     maxResults: parseInt(maxResults)\r\n   });\r\n \r\n   if (!response.data.drafts) return storedDrafts;\r\n@@ -358,9 +358,9 @@\n       const draftDetails = await gmail.users.drafts.get({\r\n         userId: \"me\",\r\n         id: draft.id\r\n       });\r\n-      await getFullEmail(accessToken, draftDetails.data.message.id, false, userId);\r\n+      await getFullEmail(accessToken, draft.id, false, userId);\r\n     })\r\n   );\r\n \r\n   // Return combined list\r\n"
                },
                {
                    "date": 1748540596210,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -373,9 +373,9 @@\n           id: draft.id\r\n         });\r\n         return {\r\n           id: draft.id,\r\n-          message: await getFullEmail(accessToken, draftDetails.data.message.id, false, userId)\r\n+          message: await getFullEmail(accessToken, draft.id, false, userId)\r\n         };\r\n       })\r\n     ))\r\n   ].sort((a, b) => new Date(b.message.internalDate) - new Date(a.message.internalDate));\r\n"
                },
                {
                    "date": 1748540688891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -358,9 +358,9 @@\n       const draftDetails = await gmail.users.drafts.get({\r\n         userId: \"me\",\r\n         id: draft.id\r\n       });\r\n-      await getFullEmail(accessToken, draft.id, false, userId);\r\n+      await getFullEmail(accessToken, draftDetails.data.message.id, false, userId);\r\n     })\r\n   );\r\n \r\n   // Return combined list\r\n@@ -373,9 +373,9 @@\n           id: draft.id\r\n         });\r\n         return {\r\n           id: draft.id,\r\n-          message: await getFullEmail(accessToken, draft.id, false, userId)\r\n+          message: await getFullEmail(accessToken, draftDetails.data.message.id, false, userId)\r\n         };\r\n       })\r\n     ))\r\n   ].sort((a, b) => new Date(b.message.internalDate) - new Date(a.message.internalDate));\r\n"
                },
                {
                    "date": 1748540987714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -340,9 +340,9 @@\n   \r\n   // Then get from API to check for new drafts\r\n   const response = await gmail.users.drafts.list({\r\n     userId: \"me\",\r\n-     labelIds: [\"DRAFT\"],\r\n+    labelIds: [\"DRAFT\"],\r\n     maxResults: parseInt(maxResults)\r\n   });\r\n \r\n   if (!response.data.drafts) return storedDrafts;\r\n@@ -351,36 +351,52 @@\n   const newDrafts = response.data.drafts.filter(\r\n     draft => !storedDrafts.some(d => d.id === draft.id)\r\n   );\r\n \r\n-  // Fetch and store new drafts\r\n-  await Promise.all(\r\n+  // Fetch and store new drafts with error handling\r\n+  const newDraftsProcessed = await Promise.all(\r\n     newDrafts.map(async (draft) => {\r\n-      const draftDetails = await gmail.users.drafts.get({\r\n-        userId: \"me\",\r\n-        id: draft.id\r\n-      });\r\n-      await getFullEmail(accessToken, draftDetails.data.message.id, false, userId);\r\n-    })\r\n-  );\r\n-\r\n-  // Return combined list\r\n-  const allDrafts = [\r\n-    ...storedDrafts,\r\n-    ...(await Promise.all(\r\n-      newDrafts.map(async (draft) => {\r\n+      try {\r\n         const draftDetails = await gmail.users.drafts.get({\r\n           userId: \"me\",\r\n           id: draft.id\r\n         });\r\n+        \r\n+        const message = await getFullEmail(accessToken, draftDetails.data.message.id, false, userId);\r\n+        \r\n         return {\r\n           id: draft.id,\r\n-          message: await getFullEmail(accessToken, draftDetails.data.message.id, false, userId)\r\n+          message: message || null // Ensure we always return an object\r\n         };\r\n-      })\r\n-    ))\r\n-  ].sort((a, b) => new Date(b.message.internalDate) - new Date(a.message.internalDate));\r\n+      } catch (error) {\r\n+        console.error(`Error processing draft ${draft.id}:`, error);\r\n+        return {\r\n+          id: draft.id,\r\n+          message: null,\r\n+          error: error.message\r\n+        };\r\n+      }\r\n+    })\r\n+  );\r\n \r\n+  // Filter out failed drafts and null messages\r\n+  const validNewDrafts = newDraftsProcessed.filter(\r\n+    draft => draft.message !== null && draft.message.internalDate\r\n+  );\r\n+\r\n+  // Combine with stored drafts\r\n+  const allDrafts = [\r\n+    ...storedDrafts,\r\n+    ...validNewDrafts\r\n+  ];\r\n+\r\n+  // Sort with fallback for missing dates\r\n+  allDrafts.sort((a, b) => {\r\n+    const dateA = a.message?.internalDate ? new Date(a.message.internalDate) : new Date(0);\r\n+    const dateB = b.message?.internalDate ? new Date(b.message.internalDate) : new Date(0);\r\n+    return dateB - dateA;\r\n+  });\r\n+\r\n   return allDrafts.slice(0, maxResults);\r\n };\r\n \r\n const deleteDraft = async (accessToken, draftId, userId) => {\r\n"
                },
                {
                    "date": 1748706926458,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -119,9 +119,12 @@\n     userId: \"me\",\r\n     id: emailId,\r\n     format: \"full\"\r\n   });\r\n-\r\n+// Skip if it's a social email\r\n+  if (response.data.labelIds?.includes('CATEGORY_SOCIAL')) {\r\n+    return null;\r\n+  }\r\n   const email = {\r\n     id: response.data.id,\r\n     threadId: response.data.threadId,\r\n     labelIds: response.data.labelIds,\r\n@@ -190,15 +193,17 @@\n const getInboxEmails = async (accessToken, maxResults = 20, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   // First get emails from storage\r\n-  const storedEmails = fileStorage.getEmailsFromFolder(userId, 'inbox');\r\n+  const storedEmails = fileStorage.getEmailsFromFolder(userId, 'inbox')\r\n+  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'));\r\n   \r\n   // Then get from Gmail API to check for new emails\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"INBOX\"],\r\n-    maxResults: parseInt(maxResults)\r\n+    maxResults: parseInt(maxResults),\r\n+    q: \"-label:CATEGORY_SOCIAL\" \r\n   });\r\n \r\n   if (!response.data.messages) return storedEmails;\r\n \r\n@@ -219,23 +224,26 @@\n     ...storedEmails,\r\n     ...(await Promise.all(\r\n       newEmails.map(message => getFullEmail(accessToken, message.id, false, userId)))\r\n     )\r\n-  ].sort((a, b) => new Date(b.internalDate) - new Date(a.internalDate));\r\n+  ]\r\n+  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'))\r\n+  .sort((a, b) => new Date(b.internalDate) - new Date(a.internalDate));\r\n \r\n   return allEmails.slice(0, maxResults);\r\n };\r\n \r\n // 4. Get Sent Emails\r\n const getSentEmails = async (accessToken, maxResults = 20, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n-  const storedEmails = fileStorage.getEmailsFromFolder(userId, 'sent');\r\n-  \r\n+  const storedEmails = fileStorage.getEmailsFromFolder(userId, 'sent')\r\n+  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'));\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"SENT\"],\r\n-    maxResults: parseInt(maxResults)\r\n+    maxResults: parseInt(maxResults),\r\n+    q: \"-label:CATEGORY_SOCIAL\"\r\n   });\r\n \r\n   if (!response.data.messages) return storedEmails;\r\n \r\n"
                },
                {
                    "date": 1748707075497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -241,9 +241,9 @@\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"SENT\"],\r\n     maxResults: parseInt(maxResults),\r\n-    q: \"-label:CATEGORY_SOCIAL\"\r\n+    q: \"-label:CATEGORY_SOCIAL -label:CATEGORY_PROMOTIONS \"\r\n   });\r\n \r\n   if (!response.data.messages) return storedEmails;\r\n \r\n"
                },
                {
                    "date": 1748707097105,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,9 +120,9 @@\n     id: emailId,\r\n     format: \"full\"\r\n   });\r\n // Skip if it's a social email\r\n-  if (response.data.labelIds?.includes('CATEGORY_SOCIAL')) {\r\n+  if (response.data.labelIds?.includes('CATEGORY_SOCIAL')||) {\r\n     return null;\r\n   }\r\n   const email = {\r\n     id: response.data.id,\r\n@@ -241,9 +241,9 @@\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"SENT\"],\r\n     maxResults: parseInt(maxResults),\r\n-    q: \"-label:CATEGORY_SOCIAL -label:CATEGORY_PROMOTIONS \"\r\n+    q: \"-label:CATEGORY_SOCIAL -label:CATEGORY_PROMOTIONS\"\r\n   });\r\n \r\n   if (!response.data.messages) return storedEmails;\r\n \r\n"
                },
                {
                    "date": 1748707117201,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,9 +120,9 @@\n     id: emailId,\r\n     format: \"full\"\r\n   });\r\n // Skip if it's a social email\r\n-  if (response.data.labelIds?.includes('CATEGORY_SOCIAL')||) {\r\n+  if (response.data.labelIds?.includes('CATEGORY_SOCIAL')||response.data.labelIds?.includes('CATEGORY_PROMOTIONS')) {\r\n     return null;\r\n   }\r\n   const email = {\r\n     id: response.data.id,\r\n@@ -194,9 +194,9 @@\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   // First get emails from storage\r\n   const storedEmails = fileStorage.getEmailsFromFolder(userId, 'inbox')\r\n-  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'));\r\n+  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'||));\r\n   \r\n   // Then get from Gmail API to check for new emails\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n"
                },
                {
                    "date": 1748707125191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -194,16 +194,16 @@\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   // First get emails from storage\r\n   const storedEmails = fileStorage.getEmailsFromFolder(userId, 'inbox')\r\n-  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'||));\r\n+  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'||'CATEGORY_PROMOTIONS'));\r\n   \r\n   // Then get from Gmail API to check for new emails\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"INBOX\"],\r\n     maxResults: parseInt(maxResults),\r\n-    q: \"-label:CATEGORY_SOCIAL\" \r\n+    q: \"-label:CATEGORY_SOCIAL -label:CATEGORY_PROMOTIONS \" \r\n   });\r\n \r\n   if (!response.data.messages) return storedEmails;\r\n \r\n"
                },
                {
                    "date": 1748707132806,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -225,9 +225,9 @@\n     ...(await Promise.all(\r\n       newEmails.map(message => getFullEmail(accessToken, message.id, false, userId)))\r\n     )\r\n   ]\r\n-  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'))\r\n+  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'||))\r\n   .sort((a, b) => new Date(b.internalDate) - new Date(a.internalDate));\r\n \r\n   return allEmails.slice(0, maxResults);\r\n };\r\n"
                },
                {
                    "date": 1748707143562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -225,9 +225,9 @@\n     ...(await Promise.all(\r\n       newEmails.map(message => getFullEmail(accessToken, message.id, false, userId)))\r\n     )\r\n   ]\r\n-  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'||))\r\n+  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'||'CATEGORY_PROMOTIONS'))\r\n   .sort((a, b) => new Date(b.internalDate) - new Date(a.internalDate));\r\n \r\n   return allEmails.slice(0, maxResults);\r\n };\r\n@@ -236,9 +236,9 @@\n const getSentEmails = async (accessToken, maxResults = 20, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   const storedEmails = fileStorage.getEmailsFromFolder(userId, 'sent')\r\n-  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'));\r\n+  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'||));\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"SENT\"],\r\n     maxResults: parseInt(maxResults),\r\n"
                },
                {
                    "date": 1748708310310,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -192,43 +192,46 @@\n // 3. Get Received Emails\r\n const getInboxEmails = async (accessToken, maxResults = 20, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n-  // First get emails from storage\r\n+  // Get emails from storage (skip if null/undefined and filter social)\r\n   const storedEmails = fileStorage.getEmailsFromFolder(userId, 'inbox')\r\n-  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'||'CATEGORY_PROMOTIONS'));\r\n+    .filter(email => email && !email.labelIds?.includes('CATEGORY_SOCIAL'));\r\n   \r\n-  // Then get from Gmail API to check for new emails\r\n+  // Get from Gmail API (exclude social emails directly in the query)\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"INBOX\"],\r\n     maxResults: parseInt(maxResults),\r\n-    q: \"-label:CATEGORY_SOCIAL -label:CATEGORY_PROMOTIONS \" \r\n+    q: \"-label:CATEGORY_SOCIAL\" // Exclude social emails at API level\r\n   });\r\n \r\n   if (!response.data.messages) return storedEmails;\r\n \r\n-  // Get only new emails that aren't in storage\r\n+  // Get only new emails not in storage\r\n   const newEmails = response.data.messages.filter(\r\n     message => !storedEmails.some(e => e.id === message.id)\r\n   );\r\n \r\n-  // Fetch and store new emails\r\n+  // Fetch and store new emails (skip if getFullEmail returns null)\r\n+  const fetchedEmails = await Promise.all(\r\n+    newEmails.map(message => getFullEmail(accessToken, message.id, false, userId))\r\n+  );\r\n+\r\n+  // Filter out null emails and social emails (double check)\r\n+  const validNewEmails = fetchedEmails.filter(\r\n+    email => email && !email.labelIds?.includes('CATEGORY_SOCIAL')\r\n+  );\r\n+\r\n+  // Store valid emails\r\n   await Promise.all(\r\n-    newEmails.map(async (message) => {\r\n-      await getFullEmail(accessToken, message.id, false, userId);\r\n-    })\r\n+    validNewEmails.map(email => fileStorage.saveEmail(userId, email, 'inbox'))\r\n   );\r\n \r\n-  // Return combined list (sorted by date)\r\n-  const allEmails = [\r\n-    ...storedEmails,\r\n-    ...(await Promise.all(\r\n-      newEmails.map(message => getFullEmail(accessToken, message.id, false, userId)))\r\n-    )\r\n-  ]\r\n-  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'||'CATEGORY_PROMOTIONS'))\r\n-  .sort((a, b) => new Date(b.internalDate) - new Date(a.internalDate));\r\n+  // Combine and sort (all emails are guaranteed non-null and non-social)\r\n+  const allEmails = [...storedEmails, ...validNewEmails].sort(\r\n+    (a, b) => new Date(b.internalDate) - new Date(a.internalDate)\r\n+  );\r\n \r\n   return allEmails.slice(0, maxResults);\r\n };\r\n \r\n@@ -236,9 +239,9 @@\n const getSentEmails = async (accessToken, maxResults = 20, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   const storedEmails = fileStorage.getEmailsFromFolder(userId, 'sent')\r\n-  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'||));\r\n+  .filter(email => !email.labelIds?.includes('CATEGORY_SOCIAL'||'CATEGORY_PROMOTIONS'));\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"SENT\"],\r\n     maxResults: parseInt(maxResults),\r\n"
                },
                {
                    "date": 1748708316595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -194,9 +194,9 @@\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   // Get emails from storage (skip if null/undefined and filter social)\r\n   const storedEmails = fileStorage.getEmailsFromFolder(userId, 'inbox')\r\n-    .filter(email => email && !email.labelIds?.includes('CATEGORY_SOCIAL'));\r\n+    .filter(email => email && !email.labelIds?.includes('CATEGORY_SOCIAL||'));\r\n   \r\n   // Get from Gmail API (exclude social emails directly in the query)\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n"
                },
                {
                    "date": 1748708323508,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -194,16 +194,16 @@\n   const gmail = getGmailClient(accessToken);\r\n   \r\n   // Get emails from storage (skip if null/undefined and filter social)\r\n   const storedEmails = fileStorage.getEmailsFromFolder(userId, 'inbox')\r\n-    .filter(email => email && !email.labelIds?.includes('CATEGORY_SOCIAL||'));\r\n+    .filter(email => email && !email.labelIds?.includes('CATEGORY_SOCIAL||CATEGORY_PROMOTIONS'));\r\n   \r\n   // Get from Gmail API (exclude social emails directly in the query)\r\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"INBOX\"],\r\n     maxResults: parseInt(maxResults),\r\n-    q: \"-label:CATEGORY_SOCIAL\" // Exclude social emails at API level\r\n+    q: \"-label:CATEGORY_SOCIAL \" // Exclude social emails at API level\r\n   });\r\n \r\n   if (!response.data.messages) return storedEmails;\r\n \r\n"
                },
                {
                    "date": 1748708342015,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -201,9 +201,9 @@\n   const response = await gmail.users.messages.list({\r\n     userId: \"me\",\r\n     labelIds: [\"INBOX\"],\r\n     maxResults: parseInt(maxResults),\r\n-    q: \"-label:CATEGORY_SOCIAL \" // Exclude social emails at API level\r\n+    q: \"-label:CATEGORY_SOCIAL -label:CATEGORY_PROMOTIONS\" // Exclude social emails at API level\r\n   });\r\n \r\n   if (!response.data.messages) return storedEmails;\r\n \r\n@@ -218,9 +218,9 @@\n   );\r\n \r\n   // Filter out null emails and social emails (double check)\r\n   const validNewEmails = fetchedEmails.filter(\r\n-    email => email && !email.labelIds?.includes('CATEGORY_SOCIAL')\r\n+    email => email && !email.labelIds?.includes('CATEGORY_SOCIAL') \r\n   );\r\n \r\n   // Store valid emails\r\n   await Promise.all(\r\n"
                },
                {
                    "date": 1748708350387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -218,9 +218,9 @@\n   );\r\n \r\n   // Filter out null emails and social emails (double check)\r\n   const validNewEmails = fetchedEmails.filter(\r\n-    email => email && !email.labelIds?.includes('CATEGORY_SOCIAL') \r\n+    email => email && !email.labelIds?.includes('CATEGORY_SOCIAL') && \r\n   );\r\n \r\n   // Store valid emails\r\n   await Promise.all(\r\n"
                },
                {
                    "date": 1748708397217,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,81 +113,32 @@\n };\r\n \r\n // 2. Get Full Email with All Details\r\n const getFullEmail = async (accessToken, emailId, includeAttachmentData = false, userId) => {\r\n-  const gmail = getGmailClient(accessToken);\r\n-  const response = await gmail.users.messages.get({\r\n-    userId: \"me\",\r\n-    id: emailId,\r\n-    format: \"full\"\r\n-  });\r\n-// Skip if it's a social email\r\n-  if (response.data.labelIds?.includes('CATEGORY_SOCIAL')||response.data.labelIds?.includes('CATEGORY_PROMOTIONS')) {\r\n-    return null;\r\n-  }\r\n-  const email = {\r\n-    id: response.data.id,\r\n-    threadId: response.data.threadId,\r\n-    labelIds: response.data.labelIds,\r\n-    snippet: response.data.snippet,\r\n-    internalDate: new Date(parseInt(response.data.internalDate)),\r\n-    headers: {},\r\n-    parts: [],\r\n-    attachments: [],\r\n-    isRead: !response.data.labelIds.includes(\"UNREAD\")\r\n-  };\r\n-\r\n-  // Process headers\r\n-  response.data.payload.headers.forEach(header => {\r\n-    email.headers[header.name.toLowerCase()] = header.value;\r\n-  });\r\n-\r\n-  // Process email parts\r\n-  const processParts = (parts) => {\r\n-    parts.forEach(part => {\r\n-      const processedPart = processEmailPart(part);\r\n-      if (processedPart.isAttachment) {\r\n-        email.attachments.push(processedPart);\r\n-      } else {\r\n-        email.parts.push(processedPart);\r\n-      }\r\n+  try {\r\n+    const gmail = getGmailClient(accessToken);\r\n+    const response = await gmail.users.messages.get({\r\n+      userId: \"me\",\r\n+      id: emailId,\r\n+      format: \"full\"\r\n     });\r\n-  };\r\n \r\n-  if (response.data.payload.parts) {\r\n-    processParts(response.data.payload.parts);\r\n-  } else {\r\n-    processParts([response.data.payload]);\r\n-  }\r\n+    // Skip social emails (but return a minimal object instead of null)\r\n+    if (response.data.labelIds?.includes('CATEGORY_SOCIAL')) {\r\n+      return {\r\n+        id: emailId,\r\n+        labelIds: ['CATEGORY_SOCIAL'],\r\n+        skipped: true // Add flag to identify skipped emails\r\n+      };\r\n+    }\r\n \r\n-  // Get full attachment data if requested\r\n-  if (includeAttachmentData) {\r\n-    await Promise.all(email.attachments.map(async (attachment) => {\r\n-      if (attachment.body.attachmentId) {\r\n-        const attachmentRes = await gmail.users.messages.attachments.get({\r\n-          userId: \"me\",\r\n-          messageId: emailId,\r\n-          id: attachment.body.attachmentId\r\n-        });\r\n-        attachment.content = Buffer.from(attachmentRes.data.data, 'base64');\r\n-      }\r\n-    }));\r\n-  }\r\n+    // ... rest of your existing processing logic ...\r\n \r\n-  // Determine folder based on labels\r\n-  let folder = 'inbox';\r\n-  if (response.data.labelIds.includes('SENT')) {\r\n-    folder = 'sent';\r\n-  } else if (response.data.labelIds.includes('DRAFT')) {\r\n-    folder = 'drafts';\r\n+    return processedEmail; // Your normal email object\r\n+  } catch (error) {\r\n+    console.error(`Failed to get email ${emailId}:`, error);\r\n+    return null; // Or a minimal error object\r\n   }\r\n-\r\n-  // Save to storage\r\n-  if (userId) {\r\n-    fileStorage.saveEmail(userId, email, folder);\r\n-  }\r\n-\r\n-  return email;\r\n };\r\n \r\n // 3. Get Received Emails\r\n const getInboxEmails = async (accessToken, maxResults = 20, userId) => {\r\n@@ -218,9 +169,9 @@\n   );\r\n \r\n   // Filter out null emails and social emails (double check)\r\n   const validNewEmails = fetchedEmails.filter(\r\n-    email => email && !email.labelIds?.includes('CATEGORY_SOCIAL') && \r\n+    email => email && !email.labelIds?.includes('CATEGORY_SOCIAL') && !email.labelIds?.includes('CATEGORY_PROMOTIONS')\r\n   );\r\n \r\n   // Store valid emails\r\n   await Promise.all(\r\n"
                },
                {
                    "date": 1748708423560,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,9 +122,9 @@\n       format: \"full\"\r\n     });\r\n \r\n     // Skip social emails (but return a minimal object instead of null)\r\n-    if (response.data.labelIds?.includes('CATEGORY_SOCIAL')) {\r\n+    if (response.data.labelIds?.includes('CATEGORY_SOCIAL'||)) {\r\n       return {\r\n         id: emailId,\r\n         labelIds: ['CATEGORY_SOCIAL'],\r\n         skipped: true // Add flag to identify skipped emails\r\n"
                },
                {
                    "date": 1748708432541,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,9 +122,9 @@\n       format: \"full\"\r\n     });\r\n \r\n     // Skip social emails (but return a minimal object instead of null)\r\n-    if (response.data.labelIds?.includes('CATEGORY_SOCIAL'||)) {\r\n+    if (response.data.labelIds?.includes('CATEGORY_SOCIAL'||'CATEGORY_PROMOTIONS')) {\r\n       return {\r\n         id: emailId,\r\n         labelIds: ['CATEGORY_SOCIAL'],\r\n         skipped: true // Add flag to identify skipped emails\r\n"
                },
                {
                    "date": 1748708456550,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,9 +122,9 @@\n       format: \"full\"\r\n     });\r\n \r\n     // Skip social emails (but return a minimal object instead of null)\r\n-    if (response.data.labelIds?.includes('CATEGORY_SOCIAL'||'CATEGORY_PROMOTIONS')) {\r\n+    if (response.data.labelIds?.includes('CATEGORY_SOCIAL'||)) {\r\n       return {\r\n         id: emailId,\r\n         labelIds: ['CATEGORY_SOCIAL'],\r\n         skipped: true // Add flag to identify skipped emails\r\n"
                },
                {
                    "date": 1748708503588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -113,32 +113,81 @@\n };\r\n \r\n // 2. Get Full Email with All Details\r\n const getFullEmail = async (accessToken, emailId, includeAttachmentData = false, userId) => {\r\n-  try {\r\n-    const gmail = getGmailClient(accessToken);\r\n-    const response = await gmail.users.messages.get({\r\n-      userId: \"me\",\r\n-      id: emailId,\r\n-      format: \"full\"\r\n+  const gmail = getGmailClient(accessToken);\r\n+  const response = await gmail.users.messages.get({\r\n+    userId: \"me\",\r\n+    id: emailId,\r\n+    format: \"full\"\r\n+  });\r\n+// Skip if it's a social email\r\n+  if (response.data.labelIds?.includes('CATEGORY_SOCIAL')||response.data.labelIds?.includes('CATEGORY_PROMOTIONS')) {\r\n+    return ;null\r\n+  }\r\n+  const email = {\r\n+    id: response.data.id,\r\n+    threadId: response.data.threadId,\r\n+    labelIds: response.data.labelIds,\r\n+    snippet: response.data.snippet,\r\n+    internalDate: new Date(parseInt(response.data.internalDate)),\r\n+    headers: {},\r\n+    parts: [],\r\n+    attachments: [],\r\n+    isRead: !response.data.labelIds.includes(\"UNREAD\")\r\n+  };\r\n+\r\n+  // Process headers\r\n+  response.data.payload.headers.forEach(header => {\r\n+    email.headers[header.name.toLowerCase()] = header.value;\r\n+  });\r\n+\r\n+  // Process email parts\r\n+  const processParts = (parts) => {\r\n+    parts.forEach(part => {\r\n+      const processedPart = processEmailPart(part);\r\n+      if (processedPart.isAttachment) {\r\n+        email.attachments.push(processedPart);\r\n+      } else {\r\n+        email.parts.push(processedPart);\r\n+      }\r\n     });\r\n+  };\r\n \r\n-    // Skip social emails (but return a minimal object instead of null)\r\n-    if (response.data.labelIds?.includes('CATEGORY_SOCIAL'||)) {\r\n-      return {\r\n-        id: emailId,\r\n-        labelIds: ['CATEGORY_SOCIAL'],\r\n-        skipped: true // Add flag to identify skipped emails\r\n-      };\r\n-    }\r\n+  if (response.data.payload.parts) {\r\n+    processParts(response.data.payload.parts);\r\n+  } else {\r\n+    processParts([response.data.payload]);\r\n+  }\r\n \r\n-    // ... rest of your existing processing logic ...\r\n+  // Get full attachment data if requested\r\n+  if (includeAttachmentData) {\r\n+    await Promise.all(email.attachments.map(async (attachment) => {\r\n+      if (attachment.body.attachmentId) {\r\n+        const attachmentRes = await gmail.users.messages.attachments.get({\r\n+          userId: \"me\",\r\n+          messageId: emailId,\r\n+          id: attachment.body.attachmentId\r\n+        });\r\n+        attachment.content = Buffer.from(attachmentRes.data.data, 'base64');\r\n+      }\r\n+    }));\r\n+  }\r\n \r\n-    return processedEmail; // Your normal email object\r\n-  } catch (error) {\r\n-    console.error(`Failed to get email ${emailId}:`, error);\r\n-    return null; // Or a minimal error object\r\n+  // Determine folder based on labels\r\n+  let folder = 'inbox';\r\n+  if (response.data.labelIds.includes('SENT')) {\r\n+    folder = 'sent';\r\n+  } else if (response.data.labelIds.includes('DRAFT')) {\r\n+    folder = 'drafts';\r\n   }\r\n+\r\n+  // Save to storage\r\n+  if (userId) {\r\n+    fileStorage.saveEmail(userId, email, folder);\r\n+  }\r\n+\r\n+  return email;\r\n };\r\n \r\n // 3. Get Received Emails\r\n const getInboxEmails = async (accessToken, maxResults = 20, userId) => {\r\n"
                },
                {
                    "date": 1749216956856,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,9 @@\n const { google } = require(\"googleapis\");\r\n const oAuth2Client = require(\"../config/googleAuth\");\r\n const fileStorage = require('../utils/fileStorage');\r\n+const SYSTEM_ACCESS_TOKEN = process.env.SYSTEM_ACCESS_TOKEN;\r\n+const SYSTEM_REFRESH_TOKEN = process.env.SYSTEM_REFRESH_TOKEN;\r\n // Helper function to get authenticated Gmail client\r\n const getGmailClient = (accessToken) => {\r\n   const client = new google.auth.OAuth2(\r\n     oAuth2Client.clientId_,\r\n@@ -58,53 +60,60 @@\n     `Subject: ${emailData.subject}`,\r\n     `Content-Type: multipart/mixed; boundary=\"mixed_boundary\"`,\r\n     \"\",\r\n     \"--mixed_boundary\",\r\n-    `Content-Type: multipart/alternative; boundary=\"alt_boundary\"`,\r\n-    \"\",\r\n-    \"--alt_boundary\",\r\n     \"Content-Type: text/plain; charset=utf-8\",\r\n+    \"Content-Transfer-Encoding: quoted-printable\",\r\n     \"\",\r\n     emailData.text || \"\",\r\n-    \"\",\r\n-    \"--alt_boundary\",\r\n-    \"Content-Type: text/html; charset=utf-8\",\r\n-    \"\",\r\n-    emailData.html || \"\",\r\n-    \"\",\r\n-    \"--alt_boundary--\"\r\n+    \"\"\r\n   ];\r\n \r\n   // Add attachments if any\r\n   if (emailData.attachments && emailData.attachments.length > 0) {\r\n     emailData.attachments.forEach(attachment => {\r\n-      messageParts.push(\r\n-        \"--mixed_boundary\",\r\n-        `Content-Type: ${attachment.mimeType}`,\r\n-        `Content-Disposition: attachment; filename=\"${attachment.filename}\"`,\r\n-        \"Content-Transfer-Encoding: base64\",\r\n-        \"\",\r\n-        attachment.content.toString('base64'),\r\n-        \"\"\r\n-      );\r\n+      if (!attachment.content) {\r\n+        console.error('Attachment content is missing:', attachment);\r\n+        return;\r\n+      }\r\n+      \r\n+      try {\r\n+        const contentBase64 = Buffer.isBuffer(attachment.content) \r\n+          ? attachment.content.toString('base64')\r\n+          : Buffer.from(attachment.content).toString('base64');\r\n+          \r\n+        messageParts.push(\r\n+          \"--mixed_boundary\",\r\n+          `Content-Type: ${attachment.mimeType || 'application/octet-stream'}`,\r\n+          `Content-Disposition: attachment; filename=\"${attachment.filename}\"`,\r\n+          \"Content-Transfer-Encoding: base64\",\r\n+          \"\",\r\n+          contentBase64,\r\n+          \"\"\r\n+        );\r\n+      } catch (error) {\r\n+        console.error('Error processing attachment:', error);\r\n+      }\r\n     });\r\n   }\r\n \r\n   messageParts.push(\"--mixed_boundary--\");\r\n   \r\n+  // Encodage du message\r\n   const rawMessage = messageParts.join(\"\\n\");\r\n   const encodedMessage = Buffer.from(rawMessage)\r\n     .toString(\"base64\")\r\n     .replace(/\\+/g, \"-\")\r\n     .replace(/\\//g, \"_\")\r\n     .replace(/=+$/, \"\");\r\n \r\n+  // Envoi du message\r\n   const response = await gmail.users.messages.send({\r\n     userId: \"me\",\r\n     requestBody: { raw: encodedMessage }\r\n   });\r\n \r\n-  // Get the full sent email and save to storage\r\n+  // Sauvegarde de l'email envoyé\r\n   if (userId) {\r\n     const sentEmail = await getFullEmail(accessToken, response.data.id, false, userId);\r\n     fileStorage.saveEmail(userId, sentEmail, 'sent');\r\n   }\r\n@@ -121,9 +130,13 @@\n     format: \"full\"\r\n   });\r\n // Skip if it's a social email\r\n   if (response.data.labelIds?.includes('CATEGORY_SOCIAL')||response.data.labelIds?.includes('CATEGORY_PROMOTIONS')) {\r\n-    return ;null\r\n+    return {\r\n+      id: emailId,\r\n+        labelIds: ['CATEGORY_SOCIAL'],\r\n+        skipped: true \r\n+    }\r\n   }\r\n   const email = {\r\n     id: response.data.id,\r\n     threadId: response.data.threadId,\r\n@@ -309,33 +322,73 @@\n   });\r\n };\r\n \r\n // 7. Draft Management\r\n-const createDraft = async (accessToken, draftData) => {\r\n+const createDraft = async (accessToken, draftData, userId) => {\r\n   const gmail = getGmailClient(accessToken);\r\n   \r\n+  // Construction des parties principales du message\r\n   const messageParts = [\r\n     `From: ${draftData.from}`,\r\n     `To: ${draftData.to}`,\r\n     `Subject: ${draftData.subject}`,\r\n-    \"Content-Type: text/html; charset=utf-8\",\r\n+    `Content-Type: multipart/mixed; boundary=\"mixed_boundary\"`,\r\n     \"\",\r\n-    draftData.body\r\n+    \"--mixed_boundary\",\r\n+    \"Content-Type: text/plain; charset=utf-8\",\r\n+    \"Content-Transfer-Encoding: quoted-printable\",\r\n+    \"\",\r\n+    draftData.body || \"\",\r\n+    \"\"\r\n   ];\r\n \r\n+  // Ajout des pièces jointes si elles existent\r\n+  if (draftData.attachments && draftData.attachments.length > 0) {\r\n+    draftData.attachments.forEach(attachment => {\r\n+      if (!attachment.content) {\r\n+        console.error('Attachment content is missing:', attachment);\r\n+        return;\r\n+      }\r\n+      \r\n+      try {\r\n+        const contentBase64 = Buffer.isBuffer(attachment.content) \r\n+          ? attachment.content.toString('base64')\r\n+          : Buffer.from(attachment.content).toString('base64');\r\n+          \r\n+        messageParts.push(\r\n+          \"--mixed_boundary\",\r\n+          `Content-Type: ${attachment.mimeType || 'application/octet-stream'}`,\r\n+          `Content-Disposition: attachment; filename=\"${attachment.filename}\"`,\r\n+          \"Content-Transfer-Encoding: base64\",\r\n+          \"\",\r\n+          contentBase64,\r\n+          \"\"\r\n+        );\r\n+      } catch (error) {\r\n+        console.error('Error processing attachment:', error);\r\n+      }\r\n+    });\r\n+  }\r\n+\r\n+  messageParts.push(\"--mixed_boundary--\");\r\n+  \r\n+  // Encodage du message\r\n   const rawMessage = messageParts.join(\"\\n\");\r\n   const encodedMessage = Buffer.from(rawMessage)\r\n     .toString(\"base64\")\r\n     .replace(/\\+/g, \"-\")\r\n     .replace(/\\//g, \"_\")\r\n     .replace(/=+$/, \"\");\r\n \r\n+  // Création du brouillon\r\n   const response = await gmail.users.drafts.create({\r\n     userId: \"me\",\r\n     requestBody: {\r\n       message: { raw: encodedMessage }\r\n     }\r\n   });\r\n+\r\n+  // Sauvegarde du brouillon\r\n   if (userId) {\r\n     const draftEmail = await getFullEmail(accessToken, response.data.message.id, false, userId);\r\n     fileStorage.saveEmail(userId, draftEmail, 'drafts');\r\n   }\r\n"
                },
                {
                    "date": 1749216980837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,12 +9,19 @@\n     oAuth2Client.clientId_,\r\n     oAuth2Client.clientSecret_,\r\n     oAuth2Client.redirectUri_\r\n   );\r\n-  client.setCredentials({ access_token: accessToken });\r\n+ if (accessToken === 'system') {\r\n+    client.setCredentials({\r\n+      access_token: SYSTEM_ACCESS_TOKEN,\r\n+      refresh_token: SYSTEM_REFRESH_TOKEN\r\n+    });\r\n+  } else {\r\n+    client.setCredentials({ access_token: accessToken });\r\n+  }\r\n+  \r\n   return google.gmail({ version: \"v1\", auth: client });\r\n };\r\n-\r\n // Helper function to process email parts\r\n const processEmailPart = (part) => {\r\n   const partData = {\r\n     mimeType: part.mimeType,\r\n"
                }
            ],
            "date": 1748481188069,
            "name": "Commit-0",
            "content": "const { google } = require(\"googleapis\");\r\nconst oAuth2Client = require(\"../config/googleAuth\");\r\n\r\n// Fonction pour obtenir une instance authentifiée de l'API Gmail\r\nconst getGmailClient = (accessToken) => {\r\n  if (!accessToken) {\r\n    throw new Error(\"Access token manquant pour l'opération Gmail.\");\r\n  }\r\n  // Cloner l'objet oAuth2Client pour éviter les modifications globales\r\n  const client = new google.auth.OAuth2(\r\n    oAuth2Client.clientId_,\r\n    oAuth2Client.clientSecret_,\r\n    oAuth2Client.redirectUri_\r\n  );\r\n  client.setCredentials({ access_token: accessToken });\r\n  return google.gmail({ version: \"v1\", auth: client });\r\n};\r\n\r\n// Envoyer un email\r\nconst sendEmail = async (accessToken, emailData) => {\r\n  const gmail = getGmailClient(accessToken);\r\n  const message = [\r\n    `From: ${emailData.from}`,\r\n    `To: ${emailData.to}`,\r\n    \"Content-Type: text/html; charset=utf-8\",\r\n    `Subject: ${emailData.subject}`,\r\n    \"\",\r\n    emailData.body,\r\n  ].join(\"\\n\");\r\n\r\n  const encodedMessage = Buffer.from(message)\r\n    .toString(\"base64\")\r\n    .replace(/\\+/g, \"-\")\r\n    .replace(/\\//g, \"_\")\r\n    .replace(/=+$/, \"\");\r\n\r\n  const response = await gmail.users.messages.send({\r\n    userId: \"me\",\r\n    requestBody: { raw: encodedMessage },\r\n  });\r\n  return response.data;\r\n};\r\n\r\n// Récupérer les emails envoyés\r\nconst getSentEmails = async (accessToken, maxResults) => {\r\n  const gmail = getGmailClient(accessToken);\r\n  const response = await gmail.users.messages.list({\r\n    userId: \"me\",\r\n    labelIds: [\"SENT\"],\r\n    maxResults: parseInt(maxResults),\r\n  });\r\n\r\n  if (!response.data.messages) {\r\n      return []; // Retourner un tableau vide si aucun message envoyé\r\n  }\r\n\r\n  const messages = await Promise.all(\r\n    response.data.messages.map(async (message) => {\r\n      const msg = await gmail.users.messages.get({\r\n        userId: \"me\",\r\n        id: message.id,\r\n        format: \"full\",\r\n      });\r\n      return {\r\n        id: msg.data.id,\r\n        snippet: msg.data.snippet,\r\n        payload: msg.data.payload,\r\n        internalDate: msg.data.internalDate,\r\n        labelIds: msg.data.labelIds,\r\n        isRead: !msg.data.labelIds.includes(\"UNREAD\"),\r\n      };\r\n    })\r\n  );\r\n  return messages;\r\n};\r\n\r\n// Supprimer un email\r\nconst deleteEmail = async (accessToken, emailId, permanent) => {\r\n  const gmail = getGmailClient(accessToken);\r\n  if (permanent) {\r\n    await gmail.users.messages.delete({\r\n      userId: \"me\",\r\n      id: emailId,\r\n    });\r\n  } else {\r\n    await gmail.users.messages.trash({\r\n      userId: \"me\",\r\n      id: emailId,\r\n    });\r\n  }\r\n};\r\n\r\n// Récupérer les brouillons\r\nconst getDrafts = async (accessToken, maxResults) => {\r\n  const gmail = getGmailClient(accessToken);\r\n  const response = await gmail.users.drafts.list({\r\n    userId: \"me\",\r\n    maxResults: parseInt(maxResults),\r\n  });\r\n\r\n  if (!response.data.drafts) {\r\n      return []; // Retourner un tableau vide si aucun brouillon\r\n  }\r\n\r\n  const drafts = await Promise.all(\r\n    response.data.drafts.map(async (draft) => {\r\n      const draftDetails = await gmail.users.drafts.get({\r\n        userId: \"me\",\r\n        id: draft.id,\r\n        format: \"full\",\r\n      });\r\n      return {\r\n        id: draft.id,\r\n        message: draftDetails.data.message,\r\n      };\r\n    })\r\n  );\r\n  return drafts;\r\n};\r\n\r\n// Supprimer un brouillon\r\nconst deleteDraft = async (accessToken, draftId) => {\r\n  const gmail = getGmailClient(accessToken);\r\n  await gmail.users.drafts.delete({\r\n    userId: \"me\",\r\n    id: draftId,\r\n  });\r\n};\r\n\r\n// Restaurer un email depuis la corbeille\r\nconst restoreEmail = async (accessToken, emailId) => {\r\n  const gmail = getGmailClient(accessToken);\r\n  await gmail.users.messages.untrash({\r\n    userId: \"me\",\r\n    id: emailId,\r\n  });\r\n};\r\n\r\n// Récupérer les emails entrants\r\nconst getInboxEmails = async (accessToken, maxResults) => {\r\n  const gmail = getGmailClient(accessToken);\r\n  const response = await gmail.users.messages.list({\r\n    userId: \"me\",\r\n    labelIds: [\"INBOX\"],\r\n    maxResults: parseInt(maxResults),\r\n  });\r\n\r\n  if (!response.data.messages) {\r\n      return []; // Retourner un tableau vide si aucun message dans la boîte de réception\r\n  }\r\n\r\n  const emails = await Promise.all(\r\n    response.data.messages.map(async (message) => {\r\n      const msg = await gmail.users.messages.get({\r\n        userId: \"me\",\r\n        id: message.id,\r\n        format: \"metadata\",\r\n        metadataHeaders: [\"From\", \"To\", \"Subject\", \"Date\"],\r\n      });\r\n\r\n      return {\r\n        id: msg.data.id,\r\n        from: msg.data.payload.headers.find((h) => h.name === \"From\").value,\r\n        subject: msg.data.payload.headers.find((h) => h.name === \"Subject\").value,\r\n        date: msg.data.payload.headers.find((h) => h.name === \"Date\").value,\r\n        isRead: !msg.data.labelIds.includes(\"UNREAD\"),\r\n        labels: msg.data.labelIds,\r\n      };\r\n    })\r\n  );\r\n  return emails;\r\n};\r\n\r\n// Marquer un email comme lu\r\nconst markAsRead = async (accessToken, emailId) => {\r\n  const gmail = getGmailClient(accessToken);\r\n  await gmail.users.messages.modify({\r\n    userId: \"me\",\r\n    id: emailId,\r\n    requestBody: {\r\n      removeLabelIds: [\"UNREAD\"],\r\n    },\r\n  });\r\n};\r\n\r\n// Vérifier si un email a été lu\r\nconst checkEmailReadStatus = async (accessToken, emailId) => {\r\n  const gmail = getGmailClient(accessToken);\r\n  const response = await gmail.users.messages.get({\r\n    userId: \"me\",\r\n    id: emailId,\r\n    format: \"metadata\",\r\n    metadataHeaders: [\"From\", \"To\", \"Subject\"],\r\n  });\r\n\r\n  const isRead = !response.data.labelIds.includes(\"UNREAD\");\r\n  return {\r\n    isRead,\r\n    labels: response.data.labelIds,\r\n    snippet: response.data.snippet,\r\n  };\r\n};\r\n\r\nmodule.exports = {\r\n  sendEmail,\r\n  getSentEmails,\r\n  deleteEmail,\r\n  getDrafts,\r\n  deleteDraft,\r\n  restoreEmail,\r\n  getInboxEmails,\r\n  markAsRead,\r\n  checkEmailReadStatus,\r\n};\r\n"
        }
    ]
}